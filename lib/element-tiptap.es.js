import { defineComponent, ref, onMounted, onBeforeUnmount, h, reactive, customRef, markRaw, getCurrentInstance, watchEffect, nextTick, unref, Teleport, shallowRef, provide, computed, watch, inject, openBlock, createElementBlock, Fragment as Fragment$6, renderList, createBlock, resolveDynamicComponent, mergeProps, toHandlers, defineAsyncComponent, getCurrentScope, onScopeDispose, createElementVNode, warn, toRef, onUnmounted, isRef, onBeforeMount, renderSlot, useAttrs as useAttrs$1, useSlots, onUpdated, withDirectives, createCommentVNode, normalizeClass, withCtx, withModifiers, createVNode, toDisplayString, normalizeStyle, vShow, Transition, cloneVNode, Text as Text$2, Comment, toRefs, resolveComponent, readonly, onDeactivated, vModelCheckbox, createTextVNode, createSlots, normalizeProps, guardReactiveProps, TransitionGroup, withKeys, createApp, isVNode, render as render$H, toRaw, createStaticVNode } from "vue";
function OrderedMap(content4) {
  this.content = content4;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key2) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key2)
        return i;
    return -1;
  },
  get: function(key2) {
    var found2 = this.find(key2);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key2, value, newKey) {
    var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
    var found2 = self2.find(key2), content4 = self2.content.slice();
    if (found2 == -1) {
      content4.push(newKey || key2, value);
    } else {
      content4[found2 + 1] = value;
      if (newKey)
        content4[found2] = newKey;
    }
    return new OrderedMap(content4);
  },
  remove: function(key2) {
    var found2 = this.find(key2);
    if (found2 == -1)
      return this;
    var content4 = this.content.slice();
    content4.splice(found2, 2);
    return new OrderedMap(content4);
  },
  addToStart: function(key2, value) {
    return new OrderedMap([key2, value].concat(this.remove(key2).content));
  },
  addToEnd: function(key2, value) {
    var content4 = this.remove(key2).content.slice();
    content4.push(key2, value);
    return new OrderedMap(content4);
  },
  addBefore: function(place, key2, value) {
    var without = this.remove(key2), content4 = without.content.slice();
    var found2 = without.find(place);
    content4.splice(found2 == -1 ? content4.length : found2, 0, key2, value);
    return new OrderedMap(content4);
  },
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  prepend: function(map30) {
    map30 = OrderedMap.from(map30);
    if (!map30.size)
      return this;
    return new OrderedMap(map30.content.concat(this.subtract(map30).content));
  },
  append: function(map30) {
    map30 = OrderedMap.from(map30);
    if (!map30.size)
      return this;
    return new OrderedMap(this.subtract(map30).content.concat(map30.content));
  },
  subtract: function(map30) {
    var result2 = this;
    map30 = OrderedMap.from(map30);
    for (var i = 0; i < map30.content.length; i += 2)
      result2 = result2.remove(map30.content[i]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content4 = [];
  if (value)
    for (var prop in value)
      content4.push(prop, value[prop]);
  return new OrderedMap(content4);
};
var orderedmap = OrderedMap;
function findDiffStart$5(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$5(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$5(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$5(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$5 = function Fragment(content4, size) {
  this.content = content4;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content4.length; i++) {
      this.size += content4[i].nodeSize;
    }
  }
};
var prototypeAccessors$i = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment$5.prototype.nodesBetween = function nodesBetween(from8, to, f, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child11 = this.content[i], end7 = pos + child11.nodeSize;
    if (end7 > from8 && f(child11, nodeStart + pos, parent, i) !== false && child11.content.size) {
      var start8 = pos + 1;
      child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
    }
    pos = end7;
  }
};
Fragment$5.prototype.descendants = function descendants(f) {
  this.nodesBetween(0, this.size, f);
};
Fragment$5.prototype.textBetween = function textBetween(from8, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isText) {
      text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node8.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node8) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node8.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment$5.prototype.append = function append(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content4[content4.length - 1] = last.withText(last.text + first2.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content4.push(other.content[i]);
  }
  return new Fragment$5(content4, this.size + other.size);
};
Fragment$5.prototype.cut = function cut(from8, to) {
  if (to == null) {
    to = this.size;
  }
  if (from8 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from8) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8) {
        if (pos < from8 || end7 > to) {
          if (child11.isText) {
            child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
          } else {
            child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
        }
        result2.push(child11);
        size += child11.nodeSize;
      }
      pos = end7;
    }
  }
  return new Fragment$5(result2, size);
};
Fragment$5.prototype.cutByIndex = function cutByIndex(from8, to) {
  if (from8 == to) {
    return Fragment$5.empty;
  }
  if (from8 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$5(this.content.slice(from8, to));
};
Fragment$5.prototype.replaceChild = function replaceChild(index6, node8) {
  var current = this.content[index6];
  if (current == node8) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node8.nodeSize - current.nodeSize;
  copy12[index6] = node8;
  return new Fragment$5(copy12, size);
};
Fragment$5.prototype.addToStart = function addToStart(node8) {
  return new Fragment$5([node8].concat(this.content), this.size + node8.nodeSize);
};
Fragment$5.prototype.addToEnd = function addToEnd(node8) {
  return new Fragment$5(this.content.concat(node8), this.size + node8.nodeSize);
};
Fragment$5.prototype.eq = function eq(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$i.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$i.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$i.childCount.get = function() {
  return this.content.length;
};
Fragment$5.prototype.child = function child(index6) {
  var found2 = this.content[index6];
  if (!found2) {
    throw new RangeError("Index " + index6 + " out of range for " + this);
  }
  return found2;
};
Fragment$5.prototype.maybeChild = function maybeChild(index6) {
  return this.content[index6];
};
Fragment$5.prototype.forEach = function forEach(f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child11 = this.content[i];
    f(child11, p, i);
    p += child11.nodeSize;
  }
};
Fragment$5.prototype.findDiffStart = function findDiffStart$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$5(this, other, pos);
};
Fragment$5.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$5(this, other, pos, otherPos);
};
Fragment$5.prototype.findIndex = function findIndex(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex$5(0, pos);
  }
  if (pos == this.size) {
    return retIndex$5(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this.child(i), end7 = curPos + cur.nodeSize;
    if (end7 >= pos) {
      if (end7 == pos || round2 > 0) {
        return retIndex$5(i + 1, end7);
      }
      return retIndex$5(i, curPos);
    }
    curPos = end7;
  }
};
Fragment$5.prototype.toString = function toString() {
  return "<" + this.toStringInner() + ">";
};
Fragment$5.prototype.toStringInner = function toStringInner() {
  return this.content.join(", ");
};
Fragment$5.prototype.toJSON = function toJSON() {
  return this.content.length ? this.content.map(function(n) {
    return n.toJSON();
  }) : null;
};
Fragment$5.fromJSON = function fromJSON(schema, value) {
  if (!value) {
    return Fragment$5.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$5(value.map(schema.nodeFromJSON));
};
Fragment$5.fromArray = function fromArray(array4) {
  if (!array4.length) {
    return Fragment$5.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array4.length; i++) {
    var node8 = array4[i];
    size += node8.nodeSize;
    if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
      if (!joined) {
        joined = array4.slice(0, i);
      }
      joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
    } else if (joined) {
      joined.push(node8);
    }
  }
  return new Fragment$5(joined || array4, size);
};
Fragment$5.from = function from(nodes) {
  if (!nodes) {
    return Fragment$5.empty;
  }
  if (nodes instanceof Fragment$5) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment$5([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment$5.prototype, prototypeAccessors$i);
var found$5 = { index: 0, offset: 0 };
function retIndex$5(index6, offset6) {
  found$5.index = index6;
  found$5.offset = offset6;
  return found$5;
}
Fragment$5.empty = new Fragment$5([], 0);
function compareDeep$4(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array4 = Array.isArray(a);
  if (Array.isArray(b) != array4) {
    return false;
  }
  if (array4) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$4(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep$4(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$5 = function Mark(type4, attrs) {
  this.type = type4;
  this.attrs = attrs;
};
Mark$5.prototype.addToSet = function addToSet(set3) {
  var copy12, placed = false;
  for (var i = 0; i < set3.length; i++) {
    var other = set3[i];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set3.slice(0, i);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy12) {
          copy12 = set3.slice(0, i);
        }
        copy12.push(this);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set3.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$5.prototype.removeFromSet = function removeFromSet(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return set3.slice(0, i).concat(set3.slice(i + 1));
    }
  }
  return set3;
};
Mark$5.prototype.isInSet = function isInSet(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return true;
    }
  }
  return false;
};
Mark$5.prototype.eq = function eq2(other) {
  return this == other || this.type == other.type && compareDeep$4(this.attrs, other.attrs);
};
Mark$5.prototype.toJSON = function toJSON2() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark$5.fromJSON = function fromJSON2(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type4 = schema.marks[json.type];
  if (!type4) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type4.create(json.attrs);
};
Mark$5.sameSet = function sameSet(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$5.setFrom = function setFrom(marks6) {
  if (!marks6 || marks6.length == 0) {
    return Mark$5.none;
  }
  if (marks6 instanceof Mark$5) {
    return [marks6];
  }
  var copy12 = marks6.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$5.none = [];
function ReplaceError$4(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = ReplaceError$4.prototype;
  return err6;
}
ReplaceError$4.prototype = Object.create(Error.prototype);
ReplaceError$4.prototype.constructor = ReplaceError$4;
ReplaceError$4.prototype.name = "ReplaceError";
var Slice$5 = function Slice(content4, openStart, openEnd) {
  this.content = content4;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$f = { size: { configurable: true } };
prototypeAccessors$1$f.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$5.prototype.insertAt = function insertAt(pos, fragment) {
  var content4 = insertInto$5(this.content, pos + this.openStart, fragment, null);
  return content4 && new Slice$5(content4, this.openStart, this.openEnd);
};
Slice$5.prototype.removeBetween = function removeBetween(from8, to) {
  return new Slice$5(removeRange$5(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$5.prototype.eq = function eq3(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$5.prototype.toString = function toString2() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$5.prototype.toJSON = function toJSON3() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$5.fromJSON = function fromJSON3(schema, json) {
  if (!json) {
    return Slice$5.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$5(Fragment$5.fromJSON(schema, json.content), openStart, openEnd);
};
Slice$5.maxOpen = function maxOpen(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
    openStart++;
  }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
    openEnd++;
  }
  return new Slice$5(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$5.prototype, prototypeAccessors$1$f);
function removeRange$5(content4, from8, to) {
  var ref2 = content4.findIndex(from8);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  var ref$1 = content4.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content4.replaceChild(index6, child11.copy(removeRange$5(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto$5(content4, dist, insert, parent) {
  var ref2 = content4.findIndex(dist);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert)) {
      return null;
    }
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  var inner = insertInto$5(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
Slice$5.empty = new Slice$5(Fragment$5.empty, 0, 0);
function replace$4($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$4("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$4("Inconsistent open depths");
  }
  return replaceOuter$4($from, $to, slice11, 0);
}
function replaceOuter$4($from, $to, slice11, depth) {
  var index6 = $from.index(depth), node8 = $from.node(depth);
  if (index6 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$4($from, $to, slice11, depth + 1);
    return node8.copy(node8.content.replaceChild(index6, inner));
  } else if (!slice11.content.size) {
    return close$4(node8, replaceTwoWay$4($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content4 = parent.content;
    return close$4(parent, content4.cut(0, $from.parentOffset).append(slice11.content).append(content4.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace$4(slice11, $from);
    var start8 = ref2.start;
    var end7 = ref2.end;
    return close$4(node8, replaceThreeWay$4($from, start8, end7, $to, depth));
  }
}
function checkJoin$4(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError$4("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$5($before, $after, depth) {
  var node8 = $before.node(depth);
  checkJoin$4(node8, $after.node(depth));
  return node8;
}
function addNode$4(child11, target) {
  var last = target.length - 1;
  if (last >= 0 && child11.isText && child11.sameMarkup(target[last])) {
    target[last] = child11.withText(target[last].text + child11.text);
  } else {
    target.push(child11);
  }
}
function addRange$4($start, $end, depth, target) {
  var node8 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node8.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode$4($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i = startIndex2; i < endIndex2; i++) {
    addNode$4(node8.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$4($end.nodeBefore, target);
  }
}
function close$4(node8, content4) {
  if (!node8.type.validContent(content4)) {
    throw new ReplaceError$4("Invalid content for node " + node8.type.name);
  }
  return node8.copy(content4);
}
function replaceThreeWay$4($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$5($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$5($end, $to, depth + 1);
  var content4 = [];
  addRange$4(null, $from, depth, content4);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$4(openStart, openEnd);
    addNode$4(close$4(openStart, replaceThreeWay$4($from, $start, $end, $to, depth + 1)), content4);
  } else {
    if (openStart) {
      addNode$4(close$4(openStart, replaceTwoWay$4($from, $start, depth + 1)), content4);
    }
    addRange$4($start, $end, depth, content4);
    if (openEnd) {
      addNode$4(close$4(openEnd, replaceTwoWay$4($end, $to, depth + 1)), content4);
    }
  }
  addRange$4($to, null, depth, content4);
  return new Fragment$5(content4);
}
function replaceTwoWay$4($from, $to, depth) {
  var content4 = [];
  addRange$4(null, $from, depth, content4);
  if ($from.depth > depth) {
    var type4 = joinable$5($from, $to, depth + 1);
    addNode$4(close$4(type4, replaceTwoWay$4($from, $to, depth + 1)), content4);
  }
  addRange$4($to, null, depth, content4);
  return new Fragment$5(content4);
}
function prepareSliceForReplace$4(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node8 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node8 = $along.node(i).copy(Fragment$5.from(node8));
  }
  return {
    start: node8.resolveNoCache(slice11.openStart + extra),
    end: node8.resolveNoCache(node8.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$4 = function ResolvedPos(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$5 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos$4.prototype.resolveDepth = function resolveDepth(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$5.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$5.doc.get = function() {
  return this.node(0);
};
ResolvedPos$4.prototype.node = function node(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$4.prototype.index = function index(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$4.prototype.indexAfter = function indexAfter(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$4.prototype.start = function start(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$4.prototype.end = function end(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$4.prototype.before = function before(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$4.prototype.after = function after(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$5.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$5.nodeAfter.get = function() {
  var parent = this.parent, index6 = this.index(this.depth);
  if (index6 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child11 = parent.child(index6);
  return dOff ? parent.child(index6).cut(dOff) : child11;
};
prototypeAccessors$2$5.nodeBefore.get = function() {
  var index6 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index6).cut(0, dOff);
  }
  return index6 == 0 ? null : this.parent.child(index6 - 1);
};
ResolvedPos$4.prototype.posAtIndex = function posAtIndex(index6, depth) {
  depth = this.resolveDepth(depth);
  var node8 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index6; i++) {
    pos += node8.child(i).nodeSize;
  }
  return pos;
};
ResolvedPos$4.prototype.marks = function marks() {
  var parent = this.parent, index6 = this.index();
  if (parent.content.size == 0) {
    return Mark$5.none;
  }
  if (this.textOffset) {
    return parent.child(index6).marks;
  }
  var main2 = parent.maybeChild(index6 - 1), other = parent.maybeChild(index6);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks6 = main2.marks;
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!other || !marks6[i].isInSet(other.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$4.prototype.marksAcross = function marksAcross($end) {
  var after6 = this.parent.maybeChild(this.index());
  if (!after6 || !after6.isInline) {
    return null;
  }
  var marks6 = after6.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!next || !marks6[i].isInSet(next.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$4.prototype.sharedDepth = function sharedDepth(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$4.prototype.blockRange = function blockRange(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
      return new NodeRange$4(this, other, d);
    }
  }
};
ResolvedPos$4.prototype.sameParent = function sameParent(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$4.prototype.max = function max(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$4.prototype.min = function min(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$4.prototype.toString = function toString3() {
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$4.resolve = function resolve(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start8 = 0, parentOffset = pos;
  for (var node8 = doc2; ; ) {
    var ref2 = node8.content.findIndex(parentOffset);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    var rem = parentOffset - offset6;
    path.push(node8, index6, start8 + offset6);
    if (!rem) {
      break;
    }
    node8 = node8.child(index6);
    if (node8.isText) {
      break;
    }
    parentOffset = rem - 1;
    start8 += offset6 + 1;
  }
  return new ResolvedPos$4(pos, path, parentOffset);
};
ResolvedPos$4.resolveCached = function resolveCached(doc2, pos) {
  for (var i = 0; i < resolveCache$4.length; i++) {
    var cached = resolveCache$4[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$4[resolveCachePos$4] = ResolvedPos$4.resolve(doc2, pos);
  resolveCachePos$4 = (resolveCachePos$4 + 1) % resolveCacheSize$4;
  return result2;
};
Object.defineProperties(ResolvedPos$4.prototype, prototypeAccessors$2$5);
var resolveCache$4 = [], resolveCachePos$4 = 0, resolveCacheSize$4 = 12;
var NodeRange$4 = function NodeRange($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$4 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$4.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$4.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$4.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$4.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$4.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$4.prototype, prototypeAccessors$1$1$4);
var emptyAttrs$4 = /* @__PURE__ */ Object.create(null);
var Node$5 = function Node(type4, attrs, content4, marks6) {
  this.type = type4;
  this.attrs = attrs;
  this.content = content4 || Fragment$5.empty;
  this.marks = marks6 || Mark$5.none;
};
var prototypeAccessors$3$4 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$4.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$4.childCount.get = function() {
  return this.content.childCount;
};
Node$5.prototype.child = function child2(index6) {
  return this.content.child(index6);
};
Node$5.prototype.maybeChild = function maybeChild2(index6) {
  return this.content.maybeChild(index6);
};
Node$5.prototype.forEach = function forEach2(f) {
  this.content.forEach(f);
};
Node$5.prototype.nodesBetween = function nodesBetween2(from8, to, f, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from8, to, f, startPos, this);
};
Node$5.prototype.descendants = function descendants2(f) {
  this.nodesBetween(0, this.content.size, f);
};
prototypeAccessors$3$4.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$5.prototype.textBetween = function textBetween2(from8, to, blockSeparator, leafText) {
  return this.content.textBetween(from8, to, blockSeparator, leafText);
};
prototypeAccessors$3$4.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$4.lastChild.get = function() {
  return this.content.lastChild;
};
Node$5.prototype.eq = function eq4(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$5.prototype.sameMarkup = function sameMarkup(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$5.prototype.hasMarkup = function hasMarkup(type4, attrs, marks6) {
  return this.type == type4 && compareDeep$4(this.attrs, attrs || type4.defaultAttrs || emptyAttrs$4) && Mark$5.sameSet(this.marks, marks6 || Mark$5.none);
};
Node$5.prototype.copy = function copy(content4) {
  if (content4 === void 0)
    content4 = null;
  if (content4 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content4, this.marks);
};
Node$5.prototype.mark = function mark(marks6) {
  return marks6 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks6);
};
Node$5.prototype.cut = function cut2(from8, to) {
  if (from8 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from8, to));
};
Node$5.prototype.slice = function slice(from8, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from8 == to) {
    return Slice$5.empty;
  }
  var $from = this.resolve(from8), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start8 = $from.start(depth), node8 = $from.node(depth);
  var content4 = node8.content.cut($from.pos - start8, $to.pos - start8);
  return new Slice$5(content4, $from.depth - depth, $to.depth - depth);
};
Node$5.prototype.replace = function replace$1(from8, to, slice11) {
  return replace$4(this.resolve(from8), this.resolve(to), slice11);
};
Node$5.prototype.nodeAt = function nodeAt(pos) {
  for (var node8 = this; ; ) {
    var ref2 = node8.content.findIndex(pos);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    node8 = node8.maybeChild(index6);
    if (!node8) {
      return null;
    }
    if (offset6 == pos || node8.isText) {
      return node8;
    }
    pos -= offset6 + 1;
  }
};
Node$5.prototype.childAfter = function childAfter(pos) {
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  return { node: this.content.maybeChild(index6), index: index6, offset: offset6 };
};
Node$5.prototype.childBefore = function childBefore(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  if (offset6 < pos) {
    return { node: this.content.child(index6), index: index6, offset: offset6 };
  }
  var node8 = this.content.child(index6 - 1);
  return { node: node8, index: index6 - 1, offset: offset6 - node8.nodeSize };
};
Node$5.prototype.resolve = function resolve2(pos) {
  return ResolvedPos$4.resolveCached(this, pos);
};
Node$5.prototype.resolveNoCache = function resolveNoCache(pos) {
  return ResolvedPos$4.resolve(this, pos);
};
Node$5.prototype.rangeHasMark = function rangeHasMark(from8, to, type4) {
  var found2 = false;
  if (to > from8) {
    this.nodesBetween(from8, to, function(node8) {
      if (type4.isInSet(node8.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$4.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$4.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$4.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$4.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$4.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$4.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$4.isAtom.get = function() {
  return this.type.isAtom;
};
Node$5.prototype.toString = function toString4() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$4(this.marks, name);
};
Node$5.prototype.contentMatchAt = function contentMatchAt(index6) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index6);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node$5.prototype.canReplace = function canReplace(from8, to, replacement, start8, end7) {
  if (replacement === void 0)
    replacement = Fragment$5.empty;
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = replacement.childCount;
  var one = this.contentMatchAt(from8).matchFragment(replacement, start8, end7);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start8; i < end7; i++) {
    if (!this.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$5.prototype.canReplaceWith = function canReplaceWith(from8, to, type4, marks6) {
  if (marks6 && !this.type.allowsMarks(marks6)) {
    return false;
  }
  var start8 = this.contentMatchAt(from8).matchType(type4);
  var end7 = start8 && start8.matchFragment(this.content, to);
  return end7 ? end7.validEnd : false;
};
Node$5.prototype.canAppend = function canAppend(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$5.prototype.check = function check() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy12 = Mark$5.none;
  for (var i = 0; i < this.marks.length; i++) {
    copy12 = this.marks[i].addToSet(copy12);
  }
  if (!Mark$5.sameSet(copy12, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
      return m.type.name;
    }));
  }
  this.content.forEach(function(node8) {
    return node8.check();
  });
};
Node$5.prototype.toJSON = function toJSON4() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n) {
      return n.toJSON();
    });
  }
  return obj;
};
Node$5.fromJSON = function fromJSON4(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks6 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks6 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks6);
  }
  var content4 = Fragment$5.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content4, marks6);
};
Object.defineProperties(Node$5.prototype, prototypeAccessors$3$4);
var TextNode = /* @__PURE__ */ function(Node7) {
  function TextNode2(type4, attrs, content4, marks6) {
    Node7.call(this, type4, attrs, null, marks6);
    if (!content4) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content4;
  }
  if (Node7)
    TextNode2.__proto__ = Node7;
  TextNode2.prototype = Object.create(Node7 && Node7.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
  TextNode2.prototype.toString = function toString32() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks$4(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween11(from8, to) {
    return this.text.slice(from8, to);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark7(marks6) {
    return marks6 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks6);
  };
  TextNode2.prototype.withText = function withText(text3) {
    if (text3 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text3, this.marks);
  };
  TextNode2.prototype.cut = function cut11(from8, to) {
    if (from8 === void 0)
      from8 = 0;
    if (to === void 0)
      to = this.text.length;
    if (from8 == 0 && to == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from8, to));
  };
  TextNode2.prototype.eq = function eq29(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON28() {
    var base2 = Node7.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node$5);
function wrapMarks$4(marks6, str) {
  for (var i = marks6.length - 1; i >= 0; i--) {
    str = marks6[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$4 = function ContentMatch(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch$4.parse = function parse(string3, nodeTypes) {
  var stream = new TokenStream$4(string3, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$4.empty;
  }
  var expr = parseExpr$4(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa$4(nfa$4(expr));
  checkForDeadEnds$4(match, stream);
  return match;
};
ContentMatch$4.prototype.matchType = function matchType(type4) {
  for (var i = 0; i < this.next.length; i += 2) {
    if (this.next[i] == type4) {
      return this.next[i + 1];
    }
  }
  return null;
};
ContentMatch$4.prototype.matchFragment = function matchFragment(frag, start8, end7) {
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = frag.childCount;
  var cur = this;
  for (var i = start8; cur && i < end7; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$4$4.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4$4.defaultType.get = function() {
  for (var i = 0; i < this.next.length; i += 2) {
    var type4 = this.next[i];
    if (!(type4.isText || type4.hasRequiredAttrs())) {
      return type4;
    }
  }
};
ContentMatch$4.prototype.compatible = function compatible(other) {
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$4.prototype.fillBefore = function fillBefore(after6, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match, types2) {
    var finished = match.matchFragment(after6, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$5.from(types2.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i], next = match.next[i + 1];
      if (!(type4.isText || type4.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types2.concat(type4));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$4.prototype.findWrapping = function findWrapping(target) {
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this.wrapCache[i] == target) {
      return this.wrapCache[i + 1];
    }
  }
  var computed2 = this.computeWrapping(target);
  this.wrapCache.push(target, computed2);
  return computed2;
};
ContentMatch$4.prototype.computeWrapping = function computeWrapping(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i];
      if (!type4.isLeaf && !type4.hasRequiredAttrs() && !(type4.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({ match: type4.contentMatch, type: type4, via: current });
        seen[type4.name] = true;
      }
    }
  }
};
prototypeAccessors$4$4.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$4.prototype.edge = function edge(n) {
  var i = n << 1;
  if (i >= this.next.length) {
    throw new RangeError("There's no " + n + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$4.prototype.toString = function toString5() {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2) {
      if (seen.indexOf(m.next[i]) == -1) {
        scan(m.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$4.prototype, prototypeAccessors$4$4);
ContentMatch$4.empty = new ContentMatch$4(true);
var TokenStream$4 = function TokenStream(string3, nodeTypes) {
  this.string = string3;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string3.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$4 = { next: { configurable: true } };
prototypeAccessors$1$2$4.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$4.prototype.eat = function eat(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$4.prototype.err = function err(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$4.prototype, prototypeAccessors$1$2$4);
function parseExpr$4(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$4(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$4(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$4(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$4(stream) {
  var expr = parseExprAtom$4(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$4(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$4(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$4(stream, expr) {
  var min7 = parseNum$4(stream), max7 = min7;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max7 = parseNum$4(stream);
    } else {
      max7 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min7, max: max7, expr };
}
function resolveName$4(stream, name) {
  var types2 = stream.nodeTypes, type4 = types2[name];
  if (type4) {
    return [type4];
  }
  var result2 = [];
  for (var typeName in types2) {
    var type$12 = types2[typeName];
    if (type$12.groups.indexOf(name) > -1) {
      result2.push(type$12);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$4(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$4(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$4(stream, stream.next).map(function(type4) {
      if (stream.inline == null) {
        stream.inline = type4.isInline;
      } else if (stream.inline != type4.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type4 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$4(expr) {
  var nfa2 = [[]];
  connect(compile11(expr, 0), node8());
  return nfa2;
  function node8() {
    return nfa2.push([]) - 1;
  }
  function edge6(from8, to, term) {
    var edge7 = { term, to };
    nfa2[from8].push(edge7);
    return edge7;
  }
  function connect(edges, to) {
    edges.forEach(function(edge7) {
      return edge7.to = to;
    });
  }
  function compile11(expr2, from8) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile11(expr3, from8));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile11(expr2.exprs[i], from8);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from8 = node8());
      }
    } else if (expr2.type == "star") {
      var loop = node8();
      edge6(from8, loop);
      connect(compile11(expr2.expr, loop), loop);
      return [edge6(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node8();
      connect(compile11(expr2.expr, from8), loop$1);
      connect(compile11(expr2.expr, loop$1), loop$1);
      return [edge6(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge6(from8)].concat(compile11(expr2.expr, from8));
    } else if (expr2.type == "range") {
      var cur = from8;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node8();
        connect(compile11(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile11(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node8();
          edge6(cur, next$2);
          connect(compile11(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge6(cur)];
    } else if (expr2.type == "name") {
      return [edge6(from8, null, expr2.value)];
    }
  }
}
function cmp$4(a, b) {
  return b - a;
}
function nullFrom$4(nfa2, node8) {
  var result2 = [];
  scan(node8);
  return result2.sort(cmp$4);
  function scan(node9) {
    var edges = nfa2[node9];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node9);
    for (var i = 0; i < edges.length; i++) {
      var ref2 = edges[i];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$4(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$4(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node8) {
      nfa2[node8].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom$4(nfa2, to).forEach(function(node9) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node9) == -1) {
            set3.push(node9);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$4(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$4);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$4(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node8 = state.next[j], next = state.next[j + 1];
      nodes.push(node8.name);
      if (dead && !(node8.isText || node8.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs$4(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs$4(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$4(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$4(attrs[name]);
    }
  }
  return result2;
}
var NodeType$6 = function NodeType(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$4(spec.attrs);
  this.defaultAttrs = defaultAttrs$4(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$4 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$4.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$4.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$4.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$4.empty;
};
prototypeAccessors$5$4.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$4.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$6.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
  for (var n in this.attrs) {
    if (this.attrs[n].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$6.prototype.compatibleContent = function compatibleContent(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$6.prototype.computeAttrs = function computeAttrs$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$4(this.attrs, attrs);
  }
};
NodeType$6.prototype.create = function create(attrs, content4, marks6) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$5(this, this.computeAttrs(attrs), Fragment$5.from(content4), Mark$5.setFrom(marks6));
};
NodeType$6.prototype.createChecked = function createChecked(attrs, content4, marks6) {
  content4 = Fragment$5.from(content4);
  if (!this.validContent(content4)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$5(this, this.computeAttrs(attrs), content4, Mark$5.setFrom(marks6));
};
NodeType$6.prototype.createAndFill = function createAndFill(attrs, content4, marks6) {
  attrs = this.computeAttrs(attrs);
  content4 = Fragment$5.from(content4);
  if (content4.size) {
    var before6 = this.contentMatch.fillBefore(content4);
    if (!before6) {
      return null;
    }
    content4 = before6.append(content4);
  }
  var after6 = this.contentMatch.matchFragment(content4).fillBefore(Fragment$5.empty, true);
  if (!after6) {
    return null;
  }
  return new Node$5(this, attrs, content4.append(after6), Mark$5.setFrom(marks6));
};
NodeType$6.prototype.validContent = function validContent(content4) {
  var result2 = this.contentMatch.matchFragment(content4);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content4.childCount; i++) {
    if (!this.allowsMarks(content4.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$6.prototype.allowsMarkType = function allowsMarkType(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$6.prototype.allowsMarks = function allowsMarks(marks6) {
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$6.prototype.allowedMarks = function allowedMarks(marks6) {
  if (this.markSet == null) {
    return marks6;
  }
  var copy12;
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      if (!copy12) {
        copy12 = marks6.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks6[i]);
    }
  }
  return !copy12 ? marks6 : copy12.length ? copy12 : Mark$5.empty;
};
NodeType$6.compile = function compile(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$6(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$6.prototype, prototypeAccessors$5$4);
var Attribute$4 = function Attribute(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$4 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$4.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$4.prototype, prototypeAccessors$1$3$4);
var MarkType$4 = function MarkType(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs$4(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs$4(this.attrs);
  this.instance = defaults2 && new Mark$5(this, defaults2);
};
MarkType$4.prototype.create = function create2(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$5(this, computeAttrs$4(this.attrs, attrs));
};
MarkType$4.compile = function compile2(marks6, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks6.forEach(function(name, spec) {
    return result2[name] = new MarkType$4(name, rank++, schema, spec);
  });
  return result2;
};
MarkType$4.prototype.removeFromSet = function removeFromSet2(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      set3 = set3.slice(0, i).concat(set3.slice(i + 1));
      i--;
    }
  }
  return set3;
};
MarkType$4.prototype.isInSet = function isInSet2(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      return set3[i];
    }
  }
};
MarkType$4.prototype.excludes = function excludes(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema$1 = function Schema(spec) {
  this.spec = {};
  for (var prop in spec) {
    this.spec[prop] = spec[prop];
  }
  this.spec.nodes = orderedmap.from(spec.nodes);
  this.spec.marks = orderedmap.from(spec.marks);
  this.nodes = NodeType$6.compile(this.spec.nodes, this);
  this.marks = MarkType$4.compile(this.spec.marks, this);
  var contentExprCache = /* @__PURE__ */ Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type4 = this.nodes[prop$1], contentExpr = type4.spec.content || "", markExpr = type4.spec.marks;
    type4.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch$4.parse(contentExpr, this.nodes));
    type4.inlineContent = type4.contentMatch.inlineContent;
    type4.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type4.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$12 = this.marks[prop$2], excl = type$12.spec.excludes;
    type$12.excluded = excl == null ? [type$12] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = /* @__PURE__ */ Object.create(null);
  this.cached.wrappings = /* @__PURE__ */ Object.create(null);
};
Schema$1.prototype.node = function node2(type4, attrs, content4, marks6) {
  if (typeof type4 == "string") {
    type4 = this.nodeType(type4);
  } else if (!(type4 instanceof NodeType$6)) {
    throw new RangeError("Invalid node type: " + type4);
  } else if (type4.schema != this) {
    throw new RangeError("Node type from different schema used (" + type4.name + ")");
  }
  return type4.createChecked(attrs, content4, marks6);
};
Schema$1.prototype.text = function text(text$1, marks6) {
  var type4 = this.nodes.text;
  return new TextNode(type4, type4.defaultAttrs, text$1, Mark$5.setFrom(marks6));
};
Schema$1.prototype.mark = function mark2(type4, attrs) {
  if (typeof type4 == "string") {
    type4 = this.marks[type4];
  }
  return type4.create(attrs);
};
Schema$1.prototype.nodeFromJSON = function nodeFromJSON(json) {
  return Node$5.fromJSON(this, json);
};
Schema$1.prototype.markFromJSON = function markFromJSON(json) {
  return Mark$5.fromJSON(this, json);
};
Schema$1.prototype.nodeType = function nodeType(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks(schema, marks6) {
  var found2 = [];
  for (var i = 0; i < marks6.length; i++) {
    var name = marks6[i], mark7 = schema.marks[name], ok5 = mark7;
    if (mark7) {
      found2.push(mark7);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok5 = mark$1);
        }
      }
    }
    if (!ok5) {
      throw new SyntaxError("Unknown mark type: '" + marks6[i] + "'");
    }
  }
  return found2;
}
var DOMParser$1 = function DOMParser(schema, rules2) {
  var this$1$1 = this;
  this.schema = schema;
  this.rules = rules2;
  this.tags = [];
  this.styles = [];
  rules2.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
  this.normalizeLists = !this.tags.some(function(r) {
    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
      return false;
    }
    var node8 = schema.nodes[r.node];
    return node8.contentMatch.matchType(node8);
  });
};
DOMParser$1.prototype.parse = function parse2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$4(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser$1.prototype.parseSlice = function parseSlice(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$4(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$5.maxOpen(context.finish());
};
DOMParser$1.prototype.matchTag = function matchTag(dom, context, after6) {
  for (var i = after6 ? this.tags.indexOf(after6) + 1 : 0; i < this.tags.length; i++) {
    var rule = this.tags[i];
    if (matches$1(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser$1.prototype.matchStyle = function matchStyle(prop, value, context, after6) {
  for (var i = after6 ? this.styles.indexOf(after6) + 1 : 0; i < this.styles.length; i++) {
    var rule = this.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser$1.schemaRules = function schemaRules(schema) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next = result2[i], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules2 = schema.marks[name2].spec.parseDOM;
    if (rules2) {
      rules2.forEach(function(rule) {
        insert(rule = copy$1(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy$1(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema.nodes)
    loop$1();
  return result2;
};
DOMParser$1.fromSchema = function fromSchema(schema) {
  return schema.cached.domParser || (schema.cached.domParser = new DOMParser$1(schema, DOMParser$1.schemaRules(schema)));
};
var blockTags$4 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$4 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$4 = { ol: true, ul: true };
var OPT_PRESERVE_WS$4 = 1, OPT_PRESERVE_WS_FULL$4 = 2, OPT_OPEN_LEFT$4 = 4;
function wsOptionsFor$4(type4, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS$4 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$4 : 0);
  }
  return type4 && type4.whitespace == "pre" ? OPT_PRESERVE_WS$4 | OPT_PRESERVE_WS_FULL$4 : base2 & ~OPT_OPEN_LEFT$4;
}
var NodeContext$4 = function NodeContext(type4, attrs, marks6, pendingMarks, solid, match, options) {
  this.type = type4;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT$4 ? null : type4.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks6;
  this.activeMarks = Mark$5.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext$4.prototype.findWrapping = function findWrapping2(node8) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$5.from(node8));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start8 = this.type.contentMatch, wrap2;
      if (wrap2 = start8.findWrapping(node8.type)) {
        this.match = start8;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node8.type);
};
NodeContext$4.prototype.finish = function finish(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$4)) {
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
  }
  var content4 = Fragment$5.from(this.content);
  if (!openEnd && this.match) {
    content4 = content4.append(this.match.fillBefore(Fragment$5.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content4, this.marks) : content4;
};
NodeContext$4.prototype.popFromStashMark = function popFromStashMark(mark7) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--) {
    if (mark7.eq(this.stashMarks[i])) {
      return this.stashMarks.splice(i, 1)[0];
    }
  }
};
NodeContext$4.prototype.applyPending = function applyPending(nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark7 = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark7.type) : markMayApply$4(mark7.type, nextType)) && !mark7.isInSet(this.activeMarks)) {
      this.activeMarks = mark7.addToSet(this.activeMarks);
      this.pendingMarks = mark7.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext$4.prototype.inlineContext = function inlineContext(node8) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node8.parentNode && !blockTags$4.hasOwnProperty(node8.parentNode.nodeName.toLowerCase());
};
var ParseContext$4 = function ParseContext(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$4(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT$4 : 0);
  if (topNode) {
    topContext = new NodeContext$4(topNode.type, topNode.attrs, Mark$5.none, Mark$5.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext$4(null, null, Mark$5.none, Mark$5.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$4(parser.schema.topNodeType, null, Mark$5.none, Mark$5.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$4 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6$4.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$4.prototype.addDOM = function addDOM(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks6 = style2 ? this.readStyles(parseStyles$4(style2)) : null, top2 = this.top;
    if (marks6 != null) {
      for (var i = 0; i < marks6.length; i++) {
        this.addPendingMark(marks6[i]);
      }
    }
    this.addElement(dom);
    if (marks6 != null) {
      for (var i$1 = 0; i$1 < marks6.length; i$1++) {
        this.removePendingMark(marks6[i$1], top2);
      }
    }
  }
};
ParseContext$4.prototype.addTextNode = function addTextNode(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL$4 || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS$4)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL$4)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$4.prototype.addElement = function addElement(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags$4.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList$4(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags$4.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync6, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$4.hasOwnProperty(name)) {
      sync6 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync6) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext$4.prototype.leafFallback = function leafFallback(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext$4.prototype.ignoreFallback = function ignoreFallback(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext$4.prototype.readStyles = function readStyles(styles) {
  var marks6 = Mark$5.none;
  style:
    for (var i = 0; i < styles.length; i += 2) {
      for (var after6 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after6);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks6 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks6);
        if (rule.consuming === false) {
          after6 = rule;
        } else {
          break;
        }
      }
    }
  return marks6;
};
ParseContext$4.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync6, nodeType2, markType, mark7;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync6 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark7 = markType.create(rule.attrs);
    this.addPendingMark(mark7);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node8) {
      return this$1$1.insertNode(node8);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync6);
  }
  if (sync6) {
    this.sync(startIn);
    this.open--;
  }
  if (mark7) {
    this.removePendingMark(mark7, startIn);
  }
};
ParseContext$4.prototype.addAll = function addAll(parent, sync6, startIndex2, endIndex2) {
  var index6 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end7 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end7; dom = dom.nextSibling, ++index6) {
    this.findAtPoint(parent, index6);
    this.addDOM(dom);
    if (sync6 && blockTags$4.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync6);
    }
  }
  this.findAtPoint(parent, index6);
};
ParseContext$4.prototype.findPlace = function findPlace(node8) {
  var route, sync6;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node8);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync6 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync6);
  for (var i = 0; i < route.length; i++) {
    this.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$4.prototype.insertNode = function insertNode(node8) {
  if (node8.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node8)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node8.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node8.type);
    }
    var marks6 = top2.activeMarks;
    for (var i = 0; i < node8.marks.length; i++) {
      if (!top2.type || top2.type.allowsMarkType(node8.marks[i].type)) {
        marks6 = node8.marks[i].addToSet(marks6);
      }
    }
    top2.content.push(node8.mark(marks6));
    return true;
  }
  return false;
};
ParseContext$4.prototype.enter = function enter(type4, attrs, preserveWS) {
  var ok5 = this.findPlace(type4.create(attrs));
  if (ok5) {
    this.enterInner(type4, attrs, true, preserveWS);
  }
  return ok5;
};
ParseContext$4.prototype.enterInner = function enterInner(type4, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type4);
  top2.match = top2.match && top2.match.matchType(type4, attrs);
  var options = wsOptionsFor$4(type4, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT$4 && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT$4;
  }
  this.nodes.push(new NodeContext$4(type4, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext$4.prototype.closeExtra = function closeExtra(openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$4.prototype.finish = function finish2() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$4.prototype.sync = function sync(to) {
  for (var i = this.open; i >= 0; i--) {
    if (this.nodes[i] == to) {
      this.open = i;
      return;
    }
  }
};
prototypeAccessors$6$4.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content4 = this.nodes[i].content;
    for (var j = content4.length - 1; j >= 0; j--) {
      pos += content4[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$4.prototype.findAtPoint = function findAtPoint(parent, offset6) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset6) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$4.prototype.findInside = function findInside(parent) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$4.prototype.findAround = function findAround(parent, content4, before6) {
  if (parent != content4 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        var pos = content4.compareDocumentPosition(this.find[i].node);
        if (pos & (before6 ? 2 : 4)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext$4.prototype.findInText = function findInText(textNode) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode) {
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }
};
ParseContext$4.prototype.matchesContext = function matchesContext(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext$4.prototype.textblockFromContext = function textblockFromContext() {
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type4 = this.parser.schema.nodes[name];
    if (type4.isTextblock && type4.defaultAttrs) {
      return type4;
    }
  }
};
ParseContext$4.prototype.addPendingMark = function addPendingMark(mark7) {
  var found2 = findSameMarkInSet$4(mark7, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark7.addToSet(this.top.pendingMarks);
};
ParseContext$4.prototype.removePendingMark = function removePendingMark(mark7, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark7);
    if (found2 > -1) {
      level.pendingMarks = mark7.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark7.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark7);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext$4.prototype, prototypeAccessors$6$4);
function normalizeList$4(dom) {
  for (var child11 = dom.firstChild, prevItem = null; child11; child11 = child11.nextSibling) {
    var name = child11.nodeType == 1 ? child11.nodeName.toLowerCase() : null;
    if (name && listTags$4.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child11);
      child11 = prevItem;
    } else if (name == "li") {
      prevItem = child11;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$1(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$4(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style2)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function copy$1(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
function markMayApply$4(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref2 = match.edge(i);
        var type4 = ref2.type;
        var next = ref2.next;
        if (type4 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet$4(mark7, set3) {
  for (var i = 0; i < set3.length; i++) {
    if (mark7.eq(set3[i])) {
      return set3[i];
    }
  }
}
var DOMSerializer$1 = function DOMSerializer(nodes, marks6) {
  this.nodes = nodes || {};
  this.marks = marks6 || {};
};
DOMSerializer$1.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$2(options).createDocumentFragment();
  }
  var top2 = target, active = null;
  fragment.forEach(function(node8) {
    if (active || node8.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node8.marks.length) {
        var next = node8.marks[rendered];
        if (!this$1$1.marks[next.type.name]) {
          rendered++;
          continue;
        }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top2 = active.pop();
        active.pop();
      }
      while (rendered < node8.marks.length) {
        var add2 = node8.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add2, node8.isInline, options);
        if (markDOM) {
          active.push(add2, top2);
          top2.appendChild(markDOM.dom);
          top2 = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top2.appendChild(this$1$1.serializeNodeInner(node8, options));
  });
  return target;
};
DOMSerializer$1.prototype.serializeNodeInner = function serializeNodeInner(node8, options) {
  if (options === void 0)
    options = {};
  var ref2 = DOMSerializer$1.renderSpec(doc$2(options), this.nodes[node8.type.name](node8));
  var dom = ref2.dom;
  var contentDOM = ref2.contentDOM;
  if (contentDOM) {
    if (node8.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node8, contentDOM, options);
    } else {
      this.serializeFragment(node8.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer$1.prototype.serializeNode = function serializeNode(node8, options) {
  if (options === void 0)
    options = {};
  var dom = this.serializeNodeInner(node8, options);
  for (var i = node8.marks.length - 1; i >= 0; i--) {
    var wrap2 = this.serializeMark(node8.marks[i], node8.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer$1.prototype.serializeMark = function serializeMark(mark7, inline2, options) {
  if (options === void 0)
    options = {};
  var toDOM = this.marks[mark7.type.name];
  return toDOM && DOMSerializer$1.renderSpec(doc$2(options), toDOM(mark7, inline2));
};
DOMSerializer$1.renderSpec = function renderSpec(doc2, structure, xmlNS) {
  if (xmlNS === void 0)
    xmlNS = null;
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  if (structure.dom && structure.dom.nodeType != null) {
    return structure;
  }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  var attrs = structure[1], start8 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start8 = 2;
    for (var name in attrs) {
      if (attrs[name] != null) {
        var space$1 = name.indexOf(" ");
        if (space$1 > 0) {
          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
        } else {
          dom.setAttribute(name, attrs[name]);
        }
      }
    }
  }
  for (var i = start8; i < structure.length; i++) {
    var child11 = structure[i];
    if (child11 === 0) {
      if (i < structure.length - 1 || i > start8) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref2 = DOMSerializer$1.renderSpec(doc2, child11, xmlNS);
      var inner = ref2.dom;
      var innerContent = ref2.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer$1.fromSchema = function fromSchema2(schema) {
  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer$1(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
};
DOMSerializer$1.nodesFromSchema = function nodesFromSchema(schema) {
  var result2 = gatherToDOM$1(schema.nodes);
  if (!result2.text) {
    result2.text = function(node8) {
      return node8.text;
    };
  }
  return result2;
};
DOMSerializer$1.marksFromSchema = function marksFromSchema(schema) {
  return gatherToDOM$1(schema.marks);
};
function gatherToDOM$1(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc$2(options) {
  return options.document || window.document;
}
var lower16$4 = 65535;
var factor16$4 = Math.pow(2, 16);
function makeRecover$4(index6, offset6) {
  return index6 + offset6 * factor16$4;
}
function recoverIndex$4(value) {
  return value & lower16$4;
}
function recoverOffset$4(value) {
  return (value - (value & lower16$4)) / factor16$4;
}
var MapResult$4 = function MapResult(pos, deleted, recover5) {
  if (deleted === void 0)
    deleted = false;
  if (recover5 === void 0)
    recover5 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover5;
};
var StepMap$4 = function StepMap(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap$4.prototype.recover = function recover(value) {
  var diff = 0, index6 = recoverIndex$4(value);
  if (!this.inverted) {
    for (var i = 0; i < index6; i++) {
      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    }
  }
  return this.ranges[index6 * 3] + diff + recoverOffset$4(value);
};
StepMap$4.prototype.mapResult = function mapResult(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap$4.prototype.map = function map(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap$4.prototype._map = function _map(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end7 = start8 + oldSize;
    if (pos <= end7) {
      var side = !oldSize ? assoc : pos == start8 ? -1 : pos == end7 ? 1 : assoc;
      var result2 = start8 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover5 = pos == (assoc < 0 ? start8 : end7) ? null : makeRecover$4(i / 3, pos - start8);
      return new MapResult$4(result2, assoc < 0 ? pos != start8 : pos != end7, recover5);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult$4(pos + diff);
};
StepMap$4.prototype.touches = function touches(pos, recover5) {
  var diff = 0, index6 = recoverIndex$4(recover5);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], end7 = start8 + oldSize;
    if (pos <= end7 && i == index6 * 3) {
      return true;
    }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false;
};
StepMap$4.prototype.forEach = function forEach3(f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i], oldStart = start8 - (this.inverted ? diff : 0), newStart = start8 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap$4.prototype.invert = function invert() {
  return new StepMap$4(this.ranges, !this.inverted);
};
StepMap$4.prototype.toString = function toString6() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap$4.offset = function offset(n) {
  return n == 0 ? StepMap$4.empty : new StepMap$4(n < 0 ? [0, -n, 0] : [0, 0, n]);
};
StepMap$4.empty = new StepMap$4([]);
var Mapping$4 = function Mapping(maps, mirror, from8, to) {
  this.maps = maps || [];
  this.from = from8 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping$4.prototype.slice = function slice2(from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping$4(this.maps, this.mirror, from8, to);
};
Mapping$4.prototype.copy = function copy2() {
  return new Mapping$4(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping$4.prototype.appendMap = function appendMap(map30, mirrors) {
  this.to = this.maps.push(map30);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping$4.prototype.appendMapping = function appendMapping(mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};
Mapping$4.prototype.getMirror = function getMirror(n) {
  if (this.mirror) {
    for (var i = 0; i < this.mirror.length; i++) {
      if (this.mirror[i] == n) {
        return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping$4.prototype.setMirror = function setMirror(n, m) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n, m);
};
Mapping$4.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};
Mapping$4.prototype.invert = function invert2() {
  var inverse = new Mapping$4();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping$4.prototype.map = function map2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i = this.from; i < this.to; i++) {
    pos = this.maps[i].map(pos, assoc);
  }
  return pos;
};
Mapping$4.prototype.mapResult = function mapResult2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping$4.prototype._map = function _map2(pos, assoc, simple) {
  var deleted = false;
  for (var i = this.from; i < this.to; i++) {
    var map30 = this.maps[i], result2 = map30.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult$4(pos, deleted);
};
function TransformError$4(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = TransformError$4.prototype;
  return err6;
}
TransformError$4.prototype = Object.create(Error.prototype);
TransformError$4.prototype.constructor = TransformError$4;
TransformError$4.prototype.name = "TransformError";
var Transform$4 = function Transform(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping$4();
};
var prototypeAccessors$h = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$h.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform$4.prototype.step = function step(object4) {
  var result2 = this.maybeStep(object4);
  if (result2.failed) {
    throw new TransformError$4(result2.failed);
  }
  return this;
};
Transform$4.prototype.maybeStep = function maybeStep(step5) {
  var result2 = step5.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step5, result2.doc);
  }
  return result2;
};
prototypeAccessors$h.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform$4.prototype.addStep = function addStep(step5, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step5);
  this.mapping.appendMap(step5.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform$4.prototype, prototypeAccessors$h);
function mustOverride$3() {
  throw new Error("Override me");
}
var stepsByID$4 = /* @__PURE__ */ Object.create(null);
var Step$4 = function Step() {
};
Step$4.prototype.apply = function apply(_doc) {
  return mustOverride$3();
};
Step$4.prototype.getMap = function getMap() {
  return StepMap$4.empty;
};
Step$4.prototype.invert = function invert3(_doc) {
  return mustOverride$3();
};
Step$4.prototype.map = function map3(_mapping) {
  return mustOverride$3();
};
Step$4.prototype.merge = function merge(_other) {
  return null;
};
Step$4.prototype.toJSON = function toJSON5() {
  return mustOverride$3();
};
Step$4.fromJSON = function fromJSON5(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type4 = stepsByID$4[json.stepType];
  if (!type4) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type4.fromJSON(schema, json);
};
Step$4.jsonID = function jsonID(id, stepClass) {
  if (id in stepsByID$4) {
    throw new RangeError("Duplicate use of step JSON ID " + id);
  }
  stepsByID$4[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass;
};
var StepResult$4 = function StepResult(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult$4.ok = function ok(doc2) {
  return new StepResult$4(doc2, null);
};
StepResult$4.fail = function fail(message) {
  return new StepResult$4(null, message);
};
StepResult$4.fromReplace = function fromReplace(doc2, from8, to, slice11) {
  try {
    return StepResult$4.ok(doc2.replace(from8, to, slice11));
  } catch (e) {
    if (e instanceof ReplaceError$4) {
      return StepResult$4.fail(e.message);
    }
    throw e;
  }
};
var ReplaceStep$4 = /* @__PURE__ */ function(Step6) {
  function ReplaceStep2(from8, to, slice11, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.slice = slice11;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceStep2.__proto__ = Step6;
  ReplaceStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && contentBetween$4(doc2, this.from, this.to)) {
      return StepResult$4.fail("Structure replace would overwrite content");
    }
    return StepResult$4.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap5() {
    return new StepMap$4([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert13(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from8.pos, Math.max(from8.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge6(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice11 = this.slice.size + other.slice.size == 0 ? Slice$5.empty : new Slice$5(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice$5.empty : new Slice$5(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON28() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice$5.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step$4);
Step$4.jsonID("replace", ReplaceStep$4);
var ReplaceAroundStep$4 = /* @__PURE__ */ function(Step6) {
  function ReplaceAroundStep2(from8, to, gapFrom, gapTo, slice11, insert, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceAroundStep2.__proto__ = Step6;
  ReplaceAroundStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && (contentBetween$4(doc2, this.from, this.gapFrom) || contentBetween$4(doc2, this.gapTo, this.to))) {
      return StepResult$4.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult$4.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult$4.fail("Content does not fit in gap");
    }
    return StepResult$4.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap5() {
    return new StepMap$4([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert13(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from8.deleted && to.deleted || gapFrom < from8.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from8.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON28() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice$5.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step$4);
Step$4.jsonID("replaceAround", ReplaceAroundStep$4);
function contentBetween$4(doc2, from8, to) {
  var $from = doc2.resolve(from8), dist = to - from8, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function canCut(node8, start8, end7) {
  return (start8 == 0 || node8.canReplace(start8, node8.childCount)) && (end7 == node8.childCount || node8.canReplace(0, end7));
}
function liftTarget(range3) {
  var parent = range3.parent;
  var content4 = parent.content.cutByIndex(range3.startIndex, range3.endIndex);
  for (var depth = range3.depth; ; --depth) {
    var node8 = range3.$from.node(depth);
    var index6 = range3.$from.index(depth), endIndex2 = range3.$to.indexAfter(depth);
    if (depth < range3.depth && node8.canReplace(index6, endIndex2, content4)) {
      return depth;
    }
    if (depth == 0 || node8.type.spec.isolating || !canCut(node8, index6, endIndex2)) {
      break;
    }
  }
}
Transform$4.prototype.lift = function(range3, target) {
  var $from = range3.$from;
  var $to = range3.$to;
  var depth = range3.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start8 = gapStart, end7 = gapEnd;
  var before6 = Fragment$5.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before6 = Fragment$5.from($from.node(d).copy(before6));
      openStart++;
    } else {
      start8--;
    }
  }
  var after6 = Fragment$5.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after6 = Fragment$5.from($to.node(d$1).copy(after6));
      openEnd++;
    } else {
      end7++;
    }
  }
  return this.step(new ReplaceAroundStep$4(start8, end7, gapStart, gapEnd, new Slice$5(before6.append(after6), openStart, openEnd), before6.size - openStart, true));
};
function findWrapping3(range3, nodeType2, attrs, innerRange) {
  if (innerRange === void 0)
    innerRange = range3;
  var around = findWrappingOutside(range3, nodeType2);
  var inner = around && findWrappingInside(innerRange, nodeType2);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type4) {
  return { type: type4, attrs: null };
}
function findWrappingOutside(range3, type4) {
  var parent = range3.parent;
  var startIndex2 = range3.startIndex;
  var endIndex2 = range3.endIndex;
  var around = parent.contentMatchAt(startIndex2).findWrapping(type4);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type4;
  return parent.canReplaceWith(startIndex2, endIndex2, outer) ? around : null;
}
function findWrappingInside(range3, type4) {
  var parent = range3.parent;
  var startIndex2 = range3.startIndex;
  var endIndex2 = range3.endIndex;
  var inner = parent.child(startIndex2);
  var inside = type4.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type4;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex2; innerMatch && i < endIndex2; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
Transform$4.prototype.wrap = function(range3, wrappers) {
  var content4 = Fragment$5.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content4 = Fragment$5.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  var start8 = range3.start, end7 = range3.end;
  return this.step(new ReplaceAroundStep$4(start8, end7, start8, end7, new Slice$5(content4, 0, 0), wrappers.length, true));
};
Transform$4.prototype.setBlockType = function(from8, to, type4, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from8;
  if (!type4.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isTextblock && !node8.hasMarkup(type4, attrs) && canChangeType$4(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type4)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type4);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node8.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep$4(startM, endM, startM + 1, endM - 1, new Slice$5(Fragment$5.from(type4.create(attrs, null, node8.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType$4(doc2, pos, type4) {
  var $pos = doc2.resolve(pos), index6 = $pos.index();
  return $pos.parent.canReplaceWith(index6, index6 + 1, type4);
}
Transform$4.prototype.setNodeMarkup = function(pos, type4, attrs, marks6) {
  var node8 = this.doc.nodeAt(pos);
  if (!node8) {
    throw new RangeError("No node at given position");
  }
  if (!type4) {
    type4 = node8.type;
  }
  var newNode = type4.create(attrs, null, marks6 || node8.marks);
  if (node8.isLeaf) {
    return this.replaceWith(pos, pos + node8.nodeSize, newNode);
  }
  if (!type4.validContent(node8.content)) {
    throw new RangeError("Invalid content for node type " + type4.name);
  }
  return this.step(new ReplaceAroundStep$4(pos, pos + node8.nodeSize, pos + 1, pos + node8.nodeSize - 1, new Slice$5(Fragment$5.from(newNode), 0, 0), 1, true));
};
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    var node8 = $pos.node(d), index$1 = $pos.index(d);
    if (node8.type.spec.isolating) {
      return false;
    }
    var rest = node8.content.cutByIndex(index$1, node8.childCount);
    var after6 = typesAfter && typesAfter[i] || node8;
    if (after6 != node8) {
      rest = rest.replaceChild(0, after6.type.create(after6.attrs));
    }
    if (!node8.canReplace(index$1 + 1, node8.childCount) || !after6.type.validContent(rest)) {
      return false;
    }
  }
  var index6 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index6, index6, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
Transform$4.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before6 = Fragment$5.empty, after6 = Fragment$5.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before6 = Fragment$5.from($pos.node(d).copy(before6));
    var typeAfter = typesAfter && typesAfter[i];
    after6 = Fragment$5.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after6) : $pos.node(d).copy(after6));
  }
  return this.step(new ReplaceStep$4(pos, pos, new Slice$5(before6.append(after6), depth, depth), true));
};
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index6 = $pos.index();
  return joinable$4($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index6, index6 + 1);
}
function joinable$4(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b);
}
Transform$4.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step5 = new ReplaceStep$4(pos - depth, pos + depth, Slice$5.empty, true);
  return this.step(step5);
};
function insertPoint$4(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index6 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2)) {
        return $pos.before(d + 1);
      }
      if (index6 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint$1(doc2, pos, slice11) {
  var $pos = doc2.resolve(pos);
  if (!slice11.content.size) {
    return pos;
  }
  var content4 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content4 = content4.firstChild.content;
  }
  for (var pass = 1; pass <= (slice11.openStart == 0 && slice11.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content4);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content4.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
  }
  return null;
}
function mapFragment$4(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child11 = fragment.child(i);
    if (child11.content.size) {
      child11 = child11.copy(mapFragment$4(child11.content, f, child11));
    }
    if (child11.isInline) {
      child11 = f(child11, parent, i);
    }
    mapped.push(child11);
  }
  return Fragment$5.fromArray(mapped);
}
var AddMarkStep$4 = /* @__PURE__ */ function(Step6) {
  function AddMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    AddMarkStep2.__proto__ = Step6;
  AddMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice11 = new Slice$5(mapFragment$4(oldSlice.content, function(node8, parent2) {
      if (!node8.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node8;
      }
      return node8.mark(this$1$1.mark.addToSet(node8.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$4.fromReplace(doc2, this.from, this.to, slice11);
  };
  AddMarkStep2.prototype.invert = function invert13() {
    return new RemoveMarkStep$4(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from8.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step$4);
Step$4.jsonID("addMark", AddMarkStep$4);
var RemoveMarkStep$4 = /* @__PURE__ */ function(Step6) {
  function RemoveMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    RemoveMarkStep2.__proto__ = Step6;
  RemoveMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice11 = new Slice$5(mapFragment$4(oldSlice.content, function(node8) {
      return node8.mark(this$1$1.mark.removeFromSet(node8.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$4.fromReplace(doc2, this.from, this.to, slice11);
  };
  RemoveMarkStep2.prototype.invert = function invert13() {
    return new AddMarkStep$4(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from8.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step$4);
Step$4.jsonID("removeMark", RemoveMarkStep$4);
Transform$4.prototype.addMark = function(from8, to, mark7) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from8, to, function(node8, pos, parent) {
    if (!node8.isInline) {
      return;
    }
    var marks6 = node8.marks;
    if (!mark7.isInSet(marks6) && parent.type.allowsMarkType(mark7.type)) {
      var start8 = Math.max(pos, from8), end7 = Math.min(pos + node8.nodeSize, to);
      var newSet = mark7.addToSet(marks6);
      for (var i = 0; i < marks6.length; i++) {
        if (!marks6[i].isInSet(newSet)) {
          if (removing && removing.to == start8 && removing.mark.eq(marks6[i])) {
            removing.to = end7;
          } else {
            removed.push(removing = new RemoveMarkStep$4(start8, end7, marks6[i]));
          }
        }
      }
      if (adding && adding.to == start8) {
        adding.to = end7;
      } else {
        added.push(adding = new AddMarkStep$4(start8, end7, mark7));
      }
    }
  });
  removed.forEach(function(s) {
    return this$1$1.step(s);
  });
  added.forEach(function(s) {
    return this$1$1.step(s);
  });
  return this;
};
Transform$4.prototype.removeMark = function(from8, to, mark7) {
  var this$1$1 = this;
  if (mark7 === void 0)
    mark7 = null;
  var matched = [], step5 = 0;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (!node8.isInline) {
      return;
    }
    step5++;
    var toRemove = null;
    if (mark7 instanceof MarkType$4) {
      var set3 = node8.marks, found2;
      while (found2 = mark7.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark7) {
      if (mark7.isInSet(node8.marks)) {
        toRemove = [mark7];
      }
    } else {
      toRemove = node8.marks;
    }
    if (toRemove && toRemove.length) {
      var end7 = Math.min(pos + node8.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style2 = toRemove[i], found$12 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step5 - 1 && style2.eq(matched[j].style)) {
            found$12 = m;
          }
        }
        if (found$12) {
          found$12.to = end7;
          found$12.step = step5;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from8), to: end7, step: step5 });
        }
      }
    }
  });
  matched.forEach(function(m) {
    return this$1$1.step(new RemoveMarkStep$4(m.from, m.to, m.style));
  });
  return this;
};
Transform$4.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node8 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node8.childCount; i++) {
    var child11 = node8.child(i), end7 = cur + child11.nodeSize;
    var allowed = match.matchType(child11.type, child11.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep$4(cur, end7, Slice$5.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child11.marks.length; j++) {
        if (!parentType.allowsMarkType(child11.marks[j].type)) {
          this.step(new RemoveMarkStep$4(cur, end7, child11.marks[j]));
        }
      }
    }
    cur = end7;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment$5.empty, true);
    this.replace(cur, cur, new Slice$5(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep$4(doc2, from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$5.empty;
  if (from8 == to && !slice11.size) {
    return null;
  }
  var $from = doc2.resolve(from8), $to = doc2.resolve(to);
  if (fitsTrivially$4($from, $to, slice11)) {
    return new ReplaceStep$4(from8, to, slice11);
  }
  return new Fitter$4($from, $to, slice11).fit();
}
Transform$4.prototype.replace = function(from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$5.empty;
  var step5 = replaceStep$4(this.doc, from8, to, slice11);
  if (step5) {
    this.step(step5);
  }
  return this;
};
Transform$4.prototype.replaceWith = function(from8, to, content4) {
  return this.replace(from8, to, new Slice$5(Fragment$5.from(content4), 0, 0));
};
Transform$4.prototype.delete = function(from8, to) {
  return this.replace(from8, to, Slice$5.empty);
};
Transform$4.prototype.insert = function(pos, content4) {
  return this.replaceWith(pos, pos, content4);
};
function fitsTrivially$4($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
var Fitter$4 = function Fitter($from, $to, slice11) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice11;
  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node8 = $from.node(i);
    this.frontier.push({
      type: node8.type,
      match: node8.contentMatchAt($from.indexAfter(i))
    });
  }
  this.placed = Fragment$5.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment$5.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$e = { depth: { configurable: true } };
prototypeAccessors$1$e.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter$4.prototype.fit = function fit() {
  while (this.unplaced.size) {
    var fit5 = this.findFittable();
    if (fit5) {
      this.placeNodes(fit5);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content4 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content4.childCount == 1) {
    content4 = content4.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice11 = new Slice$5(content4, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep$4($from.pos, moveInline, this.$to.pos, this.$to.end(), slice11, placedSize);
  }
  if (slice11.size || $from.pos != this.$to.pos) {
    return new ReplaceStep$4($from.pos, $to.pos, slice11);
  }
};
Fitter$4.prototype.findFittable = function findFittable() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt$4(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first2 = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref2 = this.frontier[frontierDepth];
        var type4 = ref2.type;
        var match = ref2.match;
        var wrap2 = void 0, inject2 = void 0;
        if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment$5.from(first2), false)) : type4.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject: inject2 };
        } else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type))) {
          return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter$4.prototype.openMore = function openMore() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$4(content4, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice$5(content4, openStart + 1, Math.max(openEnd, inner.size + openStart >= content4.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter$4.prototype.dropNode = function dropNode() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$4(content4, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content4.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice$5(dropFromFragment$4(content4, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice$5(dropFromFragment$4(content4, openStart, 1), openStart, openEnd);
  }
};
Fitter$4.prototype.placeNodes = function placeNodes(ref2) {
  var sliceDepth = ref2.sliceDepth;
  var frontierDepth = ref2.frontierDepth;
  var parent = ref2.parent;
  var inject2 = ref2.inject;
  var wrap2 = ref2.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap2) {
    for (var i = 0; i < wrap2.length; i++) {
      this.openFrontierNode(wrap2[i]);
    }
  }
  var slice11 = this.unplaced, fragment = parent ? parent.content : slice11.content;
  var openStart = slice11.openStart - sliceDepth;
  var taken = 0, add2 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type4 = ref$1.type;
  if (inject2) {
    for (var i$1 = 0; i$1 < inject2.childCount; i$1++) {
      add2.push(inject2.child(i$1));
    }
    match = match.matchFragment(inject2);
  }
  var openEndCount = fragment.size + sliceDepth - (slice11.content.size - slice11.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add2.push(closeNodeStart$4(next.mark(type4.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment$4(this.placed, frontierDepth, Fragment$5.from(add2));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node8 = cur.lastChild;
    this.frontier.push({ type: node8.type, match: node8.contentMatchAt(node8.childCount) });
    cur = node8.content;
  }
  this.unplaced = !toEnd ? new Slice$5(dropFromFragment$4(slice11.content, sliceDepth, taken), slice11.openStart, slice11.openEnd) : sliceDepth == 0 ? Slice$5.empty : new Slice$5(dropFromFragment$4(slice11.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice11.openEnd : sliceDepth - 1);
};
Fitter$4.prototype.mustMoveInline = function mustMoveInline() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits$4(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref2 = this.$to;
  var depth = ref2.depth;
  var after6 = this.$to.after(depth);
  while (depth > 1 && after6 == this.$to.end(--depth)) {
    ++after6;
  }
  return after6;
};
Fitter$4.prototype.findCloseLevel = function findCloseLevel($to) {
  scan:
    for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      var ref2 = this.frontier[i];
      var match = ref2.match;
      var type4 = ref2.type;
      var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      var fit5 = contentAfterFits$4($to, i, type4, match, dropInner);
      if (!fit5) {
        continue;
      }
      for (var d = i - 1; d >= 0; d--) {
        var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$12 = ref$1.type;
        var matches2 = contentAfterFits$4($to, d, type$12, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i, fit: fit5, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
};
Fitter$4.prototype.close = function close($to) {
  var close6 = this.findCloseLevel($to);
  if (!close6) {
    return null;
  }
  while (this.depth > close6.depth) {
    this.closeFrontierNode();
  }
  if (close6.fit.childCount) {
    this.placed = addToFragment$4(this.placed, close6.depth, close6.fit);
  }
  $to = close6.move;
  for (var d = close6.depth + 1; d <= $to.depth; d++) {
    var node8 = $to.node(d), add2 = node8.type.contentMatch.fillBefore(node8.content, true, $to.index(d));
    this.openFrontierNode(node8.type, node8.attrs, add2);
  }
  return $to;
};
Fitter$4.prototype.openFrontierNode = function openFrontierNode(type4, attrs, content4) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type4);
  this.placed = addToFragment$4(this.placed, this.depth, Fragment$5.from(type4.create(attrs, content4)));
  this.frontier.push({ type: type4, match: type4.contentMatch });
};
Fitter$4.prototype.closeFrontierNode = function closeFrontierNode() {
  var open = this.frontier.pop();
  var add2 = open.match.fillBefore(Fragment$5.empty, true);
  if (add2.childCount) {
    this.placed = addToFragment$4(this.placed, this.frontier.length, add2);
  }
};
Object.defineProperties(Fitter$4.prototype, prototypeAccessors$1$e);
function dropFromFragment$4(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment$4(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment$4(fragment, depth, content4) {
  if (depth == 0) {
    return fragment.append(content4);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment$4(fragment.lastChild.content, depth - 1, content4)));
}
function contentAt$4(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart$4(node8, openStart, openEnd) {
  if (openStart <= 0) {
    return node8;
  }
  var frag = node8.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart$4(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node8.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node8.type.contentMatch.matchFragment(frag).fillBefore(Fragment$5.empty, true));
    }
  }
  return node8.copy(frag);
}
function contentAfterFits$4($to, depth, type4, match, open) {
  var node8 = $to.node(depth), index6 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index6 == node8.childCount && !type4.compatibleContent(node8.type)) {
    return null;
  }
  var fit5 = match.fillBefore(node8.content, true, index6);
  return fit5 && !invalidMarks$4(type4, node8.content, index6) ? fit5 : null;
}
function invalidMarks$4(type4, fragment, start8) {
  for (var i = start8; i < fragment.childCount; i++) {
    if (!type4.allowsMarks(fragment.child(i).marks)) {
      return true;
    }
  }
  return false;
}
Transform$4.prototype.replaceRange = function(from8, to, slice11) {
  if (!slice11.size) {
    return this.deleteRange(from8, to);
  }
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  if (fitsTrivially$4($from, $to, slice11)) {
    return this.step(new ReplaceStep$4(from8, to, slice11));
  }
  var targetDepths = coveredDepths$4($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d) > -1) {
      preferredTarget = d;
    } else if ($from.before(d) == pos) {
      targetDepths.splice(1, 0, -d);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice11.openStart;
  for (var content4 = slice11.content, i = 0; ; i++) {
    var node8 = content4.firstChild;
    leftNodes.push(node8);
    if (i == slice11.openStart) {
      break;
    }
    content4 = node8.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice11.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index6 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index6, index6, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice$5(closeFragment$4(slice11.content, 0, slice11.openStart, openDepth), openDepth, slice11.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from8, to, slice11);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from8 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment$4(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment$4(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start8 = match.fillBefore(fragment).append(fragment);
    fragment = start8.append(match.matchFragment(start8).fillBefore(Fragment$5.empty, true));
  }
  return fragment;
}
Transform$4.prototype.replaceRangeWith = function(from8, to, node8) {
  if (!node8.isInline && from8 == to && this.doc.resolve(from8).parent.content.size) {
    var point = insertPoint$4(this.doc, from8, node8.type);
    if (point != null) {
      from8 = to = point;
    }
  }
  return this.replaceRange(from8, to, new Slice$5(Fragment$5.from(node8), 0, 0));
};
Transform$4.prototype.deleteRange = function(from8, to) {
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  var covered = coveredDepths$4($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from8 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
      return this.delete($from.before(d), to);
    }
  }
  return this.delete(from8, to);
};
function coveredDepths$4($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start8 = $from.start(d);
    if (start8 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start8 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start8 - 1) {
      result2.push(d);
    }
  }
  return result2;
}
var classesById$3 = /* @__PURE__ */ Object.create(null);
var Selection$3 = function Selection($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange$3($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$g = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$g.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$g.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$g.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$g.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$g.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$g.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$g.empty.get = function() {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    if (ranges[i].$from.pos != ranges[i].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection$3.prototype.content = function content() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection$3.prototype.replace = function replace(tr, content4) {
  if (content4 === void 0)
    content4 = Slice$5.empty;
  var lastNode = content4.content.lastChild, lastParent = null;
  for (var i = 0; i < content4.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref2 = ranges[i$1];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice$5.empty : content4);
    if (i$1 == 0) {
      selectionToInsertionEnd$4(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection$3.prototype.replaceWith = function replaceWith(tr, node8) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref2 = ranges[i];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from8 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from8, to);
    } else {
      tr.replaceRangeWith(from8, to, node8);
      selectionToInsertionEnd$4(tr, mapFrom, node8.isInline ? -1 : 1);
    }
  }
};
Selection$3.findFrom = function findFrom($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection$3($pos) : findSelectionIn$3($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn$3($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn$3($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection$3.near = function near($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection$3($pos.node(0));
};
Selection$3.atStart = function atStart(doc2) {
  return findSelectionIn$3(doc2, doc2, 0, 0, 1) || new AllSelection$3(doc2);
};
Selection$3.atEnd = function atEnd(doc2) {
  return findSelectionIn$3(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection$3(doc2);
};
Selection$3.fromJSON = function fromJSON6(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById$3[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection$3.jsonID = function jsonID2(id, selectionClass) {
  if (id in classesById$3) {
    throw new RangeError("Duplicate use of selection JSON ID " + id);
  }
  classesById$3[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass;
};
Selection$3.prototype.getBookmark = function getBookmark() {
  return TextSelection$3.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection$3.prototype, prototypeAccessors$g);
Selection$3.prototype.visible = true;
var SelectionRange$3 = function SelectionRange($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection$3 = /* @__PURE__ */ function(Selection5) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection5.call(this, $anchor, $head);
  }
  if (Selection5)
    TextSelection2.__proto__ = Selection5;
  TextSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map30(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection5.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$5.empty;
    Selection5.prototype.replace.call(this, tr, content4);
    if (content4 == Slice$5.empty) {
      var marks6 = this.$from.marksAcross(this.$to);
      if (marks6) {
        tr.ensureMarks(marks6);
      }
    }
  };
  TextSelection2.prototype.eq = function eq29(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark4() {
    return new TextBookmark$3(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON28() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create15(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection5.findFrom($head, bias, true) || Selection5.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection5.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection5.findFrom($anchor, -bias, true) || Selection5.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection$3);
Selection$3.jsonID("text", TextSelection$3);
var TextBookmark$3 = function TextBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark$3.prototype.map = function map4(mapping) {
  return new TextBookmark$3(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark$3.prototype.resolve = function resolve3(doc2) {
  return TextSelection$3.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection$3 = /* @__PURE__ */ function(Selection5) {
  function NodeSelection2($pos) {
    var node8 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node8.nodeSize);
    Selection5.call(this, $pos, $end);
    this.node = node8;
  }
  if (Selection5)
    NodeSelection2.__proto__ = Selection5;
  NodeSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map30(doc2, mapping) {
    var ref2 = mapping.mapResult(this.anchor);
    var deleted = ref2.deleted;
    var pos = ref2.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection5.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content4() {
    return new Slice$5(Fragment$5.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq29(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON28() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark4() {
    return new NodeBookmark$3(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create15(doc2, from8) {
    return new this(doc2.resolve(from8));
  };
  NodeSelection2.isSelectable = function isSelectable2(node8) {
    return !node8.isText && node8.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection$3);
NodeSelection$3.prototype.visible = false;
Selection$3.jsonID("node", NodeSelection$3);
var NodeBookmark$3 = function NodeBookmark(anchor) {
  this.anchor = anchor;
};
NodeBookmark$3.prototype.map = function map5(mapping) {
  var ref2 = mapping.mapResult(this.anchor);
  var deleted = ref2.deleted;
  var pos = ref2.pos;
  return deleted ? new TextBookmark$3(pos, pos) : new NodeBookmark$3(pos);
};
NodeBookmark$3.prototype.resolve = function resolve4(doc2) {
  var $pos = doc2.resolve(this.anchor), node8 = $pos.nodeAfter;
  if (node8 && NodeSelection$3.isSelectable(node8)) {
    return new NodeSelection$3($pos);
  }
  return Selection$3.near($pos);
};
var AllSelection$3 = /* @__PURE__ */ function(Selection5) {
  function AllSelection2(doc2) {
    Selection5.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection5)
    AllSelection2.__proto__ = Selection5;
  AllSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$5.empty;
    if (content4 == Slice$5.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection5.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection5.prototype.replace.call(this, tr, content4);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON28() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON31(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map30(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq29(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark4() {
    return AllBookmark$3;
  };
  return AllSelection2;
}(Selection$3);
Selection$3.jsonID("all", AllSelection$3);
var AllBookmark$3 = {
  map: function map6() {
    return this;
  },
  resolve: function resolve5(doc2) {
    return new AllSelection$3(doc2);
  }
};
function findSelectionIn$3(doc2, node8, pos, index6, dir, text3) {
  if (node8.inlineContent) {
    return TextSelection$3.create(doc2, pos);
  }
  for (var i = index6 - (dir > 0 ? 0 : 1); dir > 0 ? i < node8.childCount : i >= 0; i += dir) {
    var child11 = node8.child(i);
    if (!child11.isAtom) {
      var inner = findSelectionIn$3(doc2, child11, pos + dir, dir < 0 ? child11.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection$3.isSelectable(child11)) {
      return NodeSelection$3.create(doc2, pos - (dir < 0 ? child11.nodeSize : 0));
    }
    pos += child11.nodeSize * dir;
  }
}
function selectionToInsertionEnd$4(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step5 = tr.steps[last];
  if (!(step5 instanceof ReplaceStep$4 || step5 instanceof ReplaceAroundStep$4)) {
    return;
  }
  var map30 = tr.mapping.maps[last], end7;
  map30.forEach(function(_from, _to, _newFrom, newTo) {
    if (end7 == null) {
      end7 = newTo;
    }
  });
  tr.setSelection(Selection$3.near(tr.doc.resolve(end7), bias));
}
var UPDATED_SEL$2 = 1, UPDATED_MARKS$2 = 2, UPDATED_SCROLL$2 = 4;
var Transaction$2 = /* @__PURE__ */ function(Transform6) {
  function Transaction2(state) {
    Transform6.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform6)
    Transaction2.__proto__ = Transform6;
  Transaction2.prototype = Object.create(Transform6 && Transform6.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection2(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL$2) & ~UPDATED_MARKS$2;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL$2) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks6) {
    this.storedMarks = marks6;
    this.updated |= UPDATED_MARKS$2;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks2(marks6) {
    if (!Mark$5.sameSet(this.storedMarks || this.selection.$from.marks(), marks6)) {
      this.setStoredMarks(marks6);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark7) {
    return this.ensureMarks(mark7.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark7) {
    return this.ensureMarks(mark7.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS$2) > 0;
  };
  Transaction2.prototype.addStep = function addStep5(step5, doc2) {
    Transform6.prototype.addStep.call(this, step5, doc2);
    this.updated = this.updated & ~UPDATED_MARKS$2;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice11) {
    this.selection.replace(this, slice11);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node8, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node8 = node8.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$5.none));
    }
    selection.replaceWith(this, node8);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text3, from8, to) {
    if (to === void 0)
      to = from8;
    var schema = this.doc.type.schema;
    if (from8 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from8, to);
      }
      var marks6 = this.storedMarks;
      if (!marks6) {
        var $from = this.doc.resolve(from8);
        marks6 = to == from8 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from8, to, schema.text(text3, marks6));
      if (!this.selection.empty) {
        this.setSelection(Selection$3.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta2(key2, value) {
    this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key2) {
    return this.meta[typeof key2 == "string" ? key2 : key2.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _ in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView2() {
    this.updated |= UPDATED_SCROLL$2;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL$2) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform$4);
function bind$3(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc$3 = function FieldDesc(name, desc, self2) {
  this.name = name;
  this.init = bind$3(desc.init, self2);
  this.apply = bind$3(desc.apply, self2);
};
var baseFields$2 = [
  new FieldDesc$3("doc", {
    init: function init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply: function apply2(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc$3("selection", {
    init: function init2(config, instance) {
      return config.selection || Selection$3.atStart(instance.doc);
    },
    apply: function apply3(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc$3("storedMarks", {
    init: function init3(config) {
      return config.storedMarks || null;
    },
    apply: function apply4(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc$3("scrollToSelection", {
    init: function init4() {
      return 0;
    },
    apply: function apply5(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration$2 = function Configuration(schema, plugins) {
  var this$1$1 = this;
  this.schema = schema;
  this.fields = baseFields$2.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc$3(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState$2 = function EditorState(config) {
  this.config = config;
};
var prototypeAccessors$1$d = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$d.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$d.plugins.get = function() {
  return this.config.plugins;
};
EditorState$2.prototype.apply = function apply6(tr) {
  return this.applyTransaction(tr).state;
};
EditorState$2.prototype.filterTransaction = function filterTransaction(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i = 0; i < this.config.plugins.length; i++) {
    if (i != ignore) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState$2.prototype.applyTransaction = function applyTransaction(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++) {
              seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState$2.prototype.applyInner = function applyInner(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState$2(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners$2.length; i$1++) {
    applyListeners$2[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$d.tr.get = function() {
  return new Transaction$2(this);
};
EditorState$2.create = function create3(config) {
  var $config = new Configuration$2(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState$2($config);
  for (var i = 0; i < $config.fields.length; i++) {
    instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
  }
  return instance;
};
EditorState$2.prototype.reconfigure = function reconfigure(config) {
  var $config = new Configuration$2(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState$2($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance;
};
EditorState$2.prototype.toJSON = function toJSON6(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m) {
      return m.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState$2.fromJSON = function fromJSON7(config, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration$2(config.schema, config.plugins);
  var instance = new EditorState$2($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node$5.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection$3.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance;
};
EditorState$2.addApplyListener = function addApplyListener(f) {
  applyListeners$2.push(f);
};
EditorState$2.removeApplyListener = function removeApplyListener(f) {
  var found2 = applyListeners$2.indexOf(f);
  if (found2 > -1) {
    applyListeners$2.splice(found2, 1);
  }
};
Object.defineProperties(EditorState$2.prototype, prototypeAccessors$1$d);
var applyListeners$2 = [];
function bindProps$1(obj, self2, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) {
      val = val.bind(self2);
    } else if (prop == "handleDOMEvents") {
      val = bindProps$1(val, self2, {});
    }
    target[prop] = val;
  }
  return target;
}
var Plugin$1 = function Plugin(spec) {
  this.props = {};
  if (spec.props) {
    bindProps$1(spec.props, this, this.props);
  }
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey$1("plugin");
};
Plugin$1.prototype.getState = function getState(state) {
  return state[this.key];
};
var keys$2 = /* @__PURE__ */ Object.create(null);
function createKey$1(name) {
  if (name in keys$2) {
    return name + "$" + ++keys$2[name];
  }
  keys$2[name] = 0;
  return name + "$";
}
var PluginKey$1 = function PluginKey(name) {
  if (name === void 0)
    name = "key";
  this.key = createKey$1(name);
};
PluginKey$1.prototype.get = function get(state) {
  return state.config.pluginsByKey[this.key];
};
PluginKey$1.prototype.getState = function getState2(state) {
  return state[this.key];
};
function deleteSelection$2(state, dispatch2) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward$2(state, dispatch2, view) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range3 = $cursor.blockRange(), target = range3 && liftTarget(range3);
    if (target == null) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.lift(range3, target).scrollIntoView());
    }
    return true;
  }
  var before6 = $cut.nodeBefore;
  if (!before6.type.spec.isolating && deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before6, "end") || NodeSelection$3.isSelectable(before6))) {
    var delStep = replaceStep$4(state.doc, $cursor.before(), $cursor.after(), Slice$5.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before6, "end") ? Selection$3.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection$3.create(tr.doc, $cut.pos - before6.nodeSize));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before6.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos - before6.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node8, side, only) {
  for (; node8; node8 = side == "start" ? node8.firstChild : node8.lastChild) {
    if (node8.isTextblock) {
      return true;
    }
    if (only && node8.childCount != 1) {
      return false;
    }
  }
  return false;
}
function selectNodeBackward$2(state, dispatch2, view) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var empty2 = ref2.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
      return false;
    }
    $cut = findCutBefore($head);
  }
  var node8 = $cut && $cut.nodeBefore;
  if (!node8 || !NodeSelection$3.isSelectable(node8)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection$3.create(state.doc, $cut.pos - node8.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0) {
        return $pos.doc.resolve($pos.before(i + 1));
      }
      if ($pos.node(i).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward$2(state, dispatch2, view) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after6 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after6, "start") || NodeSelection$3.isSelectable(after6))) {
    var delStep = replaceStep$4(state.doc, $cursor.before(), $cursor.after(), Slice$5.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after6, "start") ? Selection$3.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection$3.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after6.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after6.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward$2(state, dispatch2, view) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var empty2 = ref2.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
      return false;
    }
    $cut = findCutAfter($head);
  }
  var node8 = $cut && $cut.nodeAfter;
  if (!node8 || !NodeSelection$3.isSelectable(node8)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection$3.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      var parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function lift$2(state, dispatch2) {
  var ref2 = state.selection;
  var $from = ref2.$from;
  var $to = ref2.$to;
  var range3 = $from.blockRange($to), target = range3 && liftTarget(range3);
  if (target == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range3, target).scrollIntoView());
  }
  return true;
}
function newlineInCode$2(state, dispatch2) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var ref2 = match.edge(i);
    var type4 = ref2.type;
    if (type4.isTextblock && !type4.hasRequiredAttrs()) {
      return type4;
    }
  }
  return null;
}
function exitCode$2(state, dispatch2) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after6 = $head.indexAfter(-1), type4 = defaultBlockAt(above.contentMatchAt(after6));
  if (!above.canReplaceWith(after6, after6, type4)) {
    return false;
  }
  if (dispatch2) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type4.createAndFill());
    tr.setSelection(Selection$3.near(tr.doc.resolve(pos), 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear$2(state, dispatch2) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof AllSelection$3 || $from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type4 = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type4 || !type4.isTextblock) {
    return false;
  }
  if (dispatch2) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type4.createAndFill());
    tr.setSelection(TextSelection$3.create(tr.doc, side + 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock$2(state, dispatch2) {
  var ref2 = state.selection;
  var $cursor = ref2.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before6 = $cursor.before();
    if (canSplit(state.doc, before6)) {
      if (dispatch2) {
        dispatch2(state.tr.split(before6).scrollIntoView());
      }
      return true;
    }
  }
  var range3 = $cursor.blockRange(), target = range3 && liftTarget(range3);
  if (target == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range3, target).scrollIntoView());
  }
  return true;
}
function splitBlock$2(state, dispatch2) {
  var ref2 = state.selection;
  var $from = ref2.$from;
  var $to = ref2.$to;
  if (state.selection instanceof NodeSelection$3 && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    var atEnd4 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof TextSelection$3 || state.selection instanceof AllSelection$3) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types2 = atEnd4 && deflt ? [{ type: deflt }] : null;
    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types2);
    if (!types2 && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types2 = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types2);
      if (!atEnd4 && !$from.parentOffset && $from.parent.type != deflt) {
        var first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function selectParentNode$2(state, dispatch2) {
  var ref2 = state.selection;
  var $from = ref2.$from;
  var to = ref2.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) {
    return false;
  }
  pos = $from.before(same);
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection$3.create(state.doc, pos)));
  }
  return true;
}
function selectAll$3(state, dispatch2) {
  if (dispatch2) {
    dispatch2(state.tr.setSelection(new AllSelection$3(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch2) {
  var before6 = $pos.nodeBefore, after6 = $pos.nodeAfter, index6 = $pos.index();
  if (!before6 || !after6 || !before6.type.compatibleContent(after6.type)) {
    return false;
  }
  if (!before6.content.size && $pos.parent.canReplace(index6 - 1, index6)) {
    if (dispatch2) {
      dispatch2(state.tr.delete($pos.pos - before6.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index6, index6 + 1) || !(after6.isTextblock || canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.clearIncompatible($pos.pos, before6.type, before6.contentMatchAt(before6.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch2) {
  var before6 = $cut.nodeBefore, after6 = $cut.nodeAfter, conn, match;
  if (before6.type.spec.isolating || after6.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch2)) {
    return true;
  }
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before6.contentMatchAt(before6.childCount)).findWrapping(after6.type)) && match.matchType(conn[0] || after6.type).validEnd) {
    if (dispatch2) {
      var end7 = $cut.pos + after6.nodeSize, wrap2 = Fragment$5.empty;
      for (var i = conn.length - 1; i >= 0; i--) {
        wrap2 = Fragment$5.from(conn[i].create(null, wrap2));
      }
      wrap2 = Fragment$5.from(before6.copy(wrap2));
      var tr = state.tr.step(new ReplaceAroundStep$4($cut.pos - 1, end7, $cut.pos, end7, new Slice$5(wrap2, 1, 0), conn.length, true));
      var joinAt = end7 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection$3.findFrom($cut, 1);
  var range3 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range3 && liftTarget(range3);
  if (target != null && target >= $cut.depth) {
    if (dispatch2) {
      dispatch2(state.tr.lift(range3, target).scrollIntoView());
    }
    return true;
  }
  if (canDelAfter && textblockAt(after6, "start", true) && textblockAt(before6, "end")) {
    var at2 = before6, wrap$1 = [];
    for (; ; ) {
      wrap$1.push(at2);
      if (at2.isTextblock) {
        break;
      }
      at2 = at2.lastChild;
    }
    var afterText = after6, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        var end$1 = Fragment$5.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
          end$1 = Fragment$5.from(wrap$1[i$1].copy(end$1));
        }
        var tr$1 = state.tr.step(new ReplaceAroundStep$4($cut.pos - wrap$1.length, $cut.pos + after6.nodeSize, $cut.pos + afterDepth, $cut.pos + after6.nodeSize - afterDepth, new Slice$5(end$1, wrap$1.length, 0), 0, true));
        dispatch2(tr$1.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth) {
        return false;
      }
      depth--;
    }
    if (!$pos.node(depth).isTextblock) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setSelection(TextSelection$3.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    }
    return true;
  };
}
var selectTextblockStart$2 = selectTextblockSide(-1);
var selectTextblockEnd$2 = selectTextblockSide(1);
function wrapIn$2(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range3 = $from.blockRange($to), wrapping = range3 && findWrapping3(range3, nodeType2, attrs);
    if (!wrapping) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.wrap(range3, wrapping).scrollIntoView());
    }
    return true;
  };
}
function setBlockType$1(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var from8 = ref2.from;
    var to = ref2.to;
    var applicable = false;
    state.doc.nodesBetween(from8, to, function(node8, pos) {
      if (applicable) {
        return false;
      }
      if (!node8.isTextblock || node8.hasMarkup(nodeType2, attrs)) {
        return;
      }
      if (node8.type == nodeType2) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index6 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index6, index6 + 1, nodeType2);
      }
    });
    if (!applicable) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setBlockType(from8, to, nodeType2, attrs).scrollIntoView());
    }
    return true;
  };
}
function chainCommands() {
  var commands = [], len = arguments.length;
  while (len--)
    commands[len] = arguments[len];
  return function(state, dispatch2, view) {
    for (var i = 0; i < commands.length; i++) {
      if (commands[i](state, dispatch2, view)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection$2, joinBackward$2, selectNodeBackward$2);
var del = chainCommands(deleteSelection$2, joinForward$2, selectNodeForward$2);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode$2, createParagraphNear$2, liftEmptyBlock$2, splitBlock$2),
  "Mod-Enter": exitCode$2,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll$3
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart$2,
  "Ctrl-e": selectTextblockEnd$2
};
for (var key$2 in pcBaseKeymap) {
  macBaseKeymap[key$2] = pcBaseKeymap[key$2];
}
pcBaseKeymap.Home = selectTextblockStart$2;
pcBaseKeymap.End = selectTextblockEnd$2;
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
function wrapInList$2(listType, attrs) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range3 = $from.blockRange($to), doJoin = false, outerRange = range3;
    if (!range3) {
      return false;
    }
    if (range3.depth >= 2 && $from.node(range3.depth - 1).type.compatibleContent(listType) && range3.startIndex == 0) {
      if ($from.index(range3.depth - 1) == 0) {
        return false;
      }
      var $insert = state.doc.resolve(range3.start - 2);
      outerRange = new NodeRange$4($insert, $insert, range3.depth);
      if (range3.endIndex < range3.parent.childCount) {
        range3 = new NodeRange$4($from, state.doc.resolve($to.end(range3.depth)), range3.depth);
      }
      doJoin = true;
    }
    var wrap2 = findWrapping3(outerRange, listType, attrs, range3);
    if (!wrap2) {
      return false;
    }
    if (dispatch2) {
      dispatch2(doWrapInList(state.tr, range3, wrap2, doJoin, listType).scrollIntoView());
    }
    return true;
  };
}
function doWrapInList(tr, range3, wrappers, joinBefore, listType) {
  var content4 = Fragment$5.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content4 = Fragment$5.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  tr.step(new ReplaceAroundStep$4(range3.start - (joinBefore ? 2 : 0), range3.end, range3.start, range3.end, new Slice$5(content4, 0, 0), wrappers.length, true));
  var found2 = 0;
  for (var i$1 = 0; i$1 < wrappers.length; i$1++) {
    if (wrappers[i$1].type == listType) {
      found2 = i$1 + 1;
    }
  }
  var splitDepth = wrappers.length - found2;
  var splitPos = range3.start + wrappers.length - (joinBefore ? 2 : 0), parent = range3.parent;
  for (var i$2 = range3.startIndex, e = range3.endIndex, first2 = true; i$2 < e; i$2++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i$2).nodeSize;
  }
  return tr;
}
function liftListItem$2(itemType) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range3 = $from.blockRange($to, function(node8) {
      return node8.childCount && node8.firstChild.type == itemType;
    });
    if (!range3) {
      return false;
    }
    if (!dispatch2) {
      return true;
    }
    if ($from.node(range3.depth - 1).type == itemType) {
      return liftToOuterList(state, dispatch2, itemType, range3);
    } else {
      return liftOutOfList(state, dispatch2, range3);
    }
  };
}
function liftToOuterList(state, dispatch2, itemType, range3) {
  var tr = state.tr, end7 = range3.end, endOfList = range3.$to.end(range3.depth);
  if (end7 < endOfList) {
    tr.step(new ReplaceAroundStep$4(end7 - 1, endOfList, end7, endOfList, new Slice$5(Fragment$5.from(itemType.create(null, range3.parent.copy())), 1, 0), 1, true));
    range3 = new NodeRange$4(tr.doc.resolve(range3.$from.pos), tr.doc.resolve(endOfList), range3.depth);
  }
  dispatch2(tr.lift(range3, liftTarget(range3)).scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range3) {
  var tr = state.tr, list = range3.parent;
  for (var pos = range3.end, i = range3.endIndex - 1, e = range3.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range3.start), item = $start.nodeAfter;
  if (tr.mapping.map(range3.end) != range3.start + $start.nodeAfter.nodeSize) {
    return false;
  }
  var atStart4 = range3.startIndex == 0, atEnd4 = range3.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart4 ? 0 : 1), indexBefore + 1, item.content.append(atEnd4 ? Fragment$5.empty : Fragment$5.from(list)))) {
    return false;
  }
  var start8 = $start.pos, end7 = start8 + item.nodeSize;
  tr.step(new ReplaceAroundStep$4(start8 - (atStart4 ? 1 : 0), end7 + (atEnd4 ? 1 : 0), start8 + 1, end7 - 1, new Slice$5((atStart4 ? Fragment$5.empty : Fragment$5.from(list.copy(Fragment$5.empty))).append(atEnd4 ? Fragment$5.empty : Fragment$5.from(list.copy(Fragment$5.empty))), atStart4 ? 0 : 1, atEnd4 ? 0 : 1), atStart4 ? 0 : 1));
  dispatch2(tr.scrollIntoView());
  return true;
}
function sinkListItem$2(itemType) {
  return function(state, dispatch2) {
    var ref2 = state.selection;
    var $from = ref2.$from;
    var $to = ref2.$to;
    var range3 = $from.blockRange($to, function(node8) {
      return node8.childCount && node8.firstChild.type == itemType;
    });
    if (!range3) {
      return false;
    }
    var startIndex2 = range3.startIndex;
    if (startIndex2 == 0) {
      return false;
    }
    var parent = range3.parent, nodeBefore = parent.child(startIndex2 - 1);
    if (nodeBefore.type != itemType) {
      return false;
    }
    if (dispatch2) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = Fragment$5.from(nestedBefore ? itemType.create() : null);
      var slice11 = new Slice$5(Fragment$5.from(itemType.create(null, Fragment$5.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before6 = range3.start, after6 = range3.end;
      dispatch2(state.tr.step(new ReplaceAroundStep$4(before6 - (nestedBefore ? 3 : 1), after6, before6, after6, slice11, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var result = {};
if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge$1 = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10$1 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up$1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie$2 = result.ie = !!(ie_upto10$1 || ie_11up$1 || ie_edge$1);
  result.ie_version = ie_upto10$1 ? document.documentMode || 6 : ie_11up$1 ? +ie_11up$1[1] : ie_edge$1 ? +ie_edge$1[1] : null;
  result.gecko = !ie$2 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome$2 = !ie$2 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome$2;
  result.chrome_version = chrome$2 && +chrome$2[1];
  result.safari = !ie$2 && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.mac = result.ios || /Mac/.test(navigator.platform);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}
var domIndex$1 = function(node8) {
  for (var index6 = 0; ; index6++) {
    node8 = node8.previousSibling;
    if (!node8) {
      return index6;
    }
  }
};
var parentNode = function(node8) {
  var parent = node8.assignedSlot || node8.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node8, from8, to) {
  var range3 = reusedRange || (reusedRange = document.createRange());
  range3.setEnd(node8, to == null ? node8.nodeValue.length : to);
  range3.setStart(node8, from8 || 0);
  return range3;
};
var isEquivalentPosition$1 = function(node8, off2, targetNode, targetOff) {
  return targetNode && (scanFor$1(node8, off2, targetNode, targetOff, -1) || scanFor$1(node8, off2, targetNode, targetOff, 1));
};
var atomElements$1 = /^(img|br|input|textarea|hr)$/i;
function scanFor$1(node8, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node8 == targetNode && off2 == targetOff) {
      return true;
    }
    if (off2 == (dir < 0 ? 0 : nodeSize$1(node8))) {
      var parent = node8.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc$1(node8) || atomElements$1.test(node8.nodeName) || node8.contentEditable == "false") {
        return false;
      }
      off2 = domIndex$1(node8) + (dir < 0 ? 0 : 1);
      node8 = parent;
    } else if (node8.nodeType == 1) {
      node8 = node8.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node8.contentEditable == "false") {
        return false;
      }
      off2 = dir < 0 ? nodeSize$1(node8) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize$1(node8) {
  return node8.nodeType == 3 ? node8.nodeValue.length : node8.childNodes.length;
}
function isOnEdge$1(node8, offset6, parent) {
  for (var atStart4 = offset6 == 0, atEnd4 = offset6 == nodeSize$1(node8); atStart4 || atEnd4; ) {
    if (node8 == parent) {
      return true;
    }
    var index6 = domIndex$1(node8);
    node8 = node8.parentNode;
    if (!node8) {
      return false;
    }
    atStart4 = atStart4 && index6 == 0;
    atEnd4 = atEnd4 && index6 == nodeSize$1(node8);
  }
}
function hasBlockDesc$1(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed$1 = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function keyEvent$1(keyCode, key2) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node8) {
  var rect = node8.getBoundingClientRect();
  var scaleX = rect.width / node8.offsetWidth || 1;
  var scaleY = rect.height / node8.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node8.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node8.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc2) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref2) {
  var refDOM = ref2.refDOM;
  var refTop = ref2.refTop;
  var stack = ref2.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref2 = stack[i];
    var dom = ref2.dom;
    var top2 = ref2.top;
    var left2 = ref2.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left2) {
      dom.scrollLeft = left2;
    }
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node8, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset6 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child11 = node8.firstChild, childIndex = 0; child11; child11 = child11.nextSibling, childIndex++) {
    var rects = void 0;
    if (child11.nodeType == 1) {
      rects = child11.getClientRects();
    } else if (child11.nodeType == 3) {
      rects = textRange(child11).getClientRects();
    } else {
      continue;
    }
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child11;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child11.nodeType == 1 && dx) {
            offset6 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset6 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node8, offset: offset6 };
  }
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node8, coords) {
  var len = node8.nodeValue.length;
  var range3 = document.createRange();
  for (var i = 0; i < len; i++) {
    range3.setEnd(node8, i + 1);
    range3.setStart(node8, i);
    var rect = singleRect(range3, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect(coords, rect)) {
      return { node: node8, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node8, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref2 = findOffsetInNode(elt, coords);
  var node8 = ref2.node;
  var offset6 = ref2.offset;
  var bias = -1;
  if (node8.nodeType == 1 && !node8.firstChild) {
    var rect = node8.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node8, offset6, bias);
}
function posFromCaret(view, node8, offset6, coords) {
  var outside = -1;
  for (var cur = node8; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node8, offset6);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      var child11 = element.childNodes[i];
      if (child11.nodeType == 1) {
        var rects = child11.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) {
            return elementFromPoint(child11, coords, rect);
          }
        }
      }
      if ((i = (i + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign, assign$1;
  var doc2 = view.dom.ownerDocument, node8, offset6;
  if (doc2.caretPositionFromPoint) {
    try {
      var pos$1 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign = pos$1, node8 = assign.offsetNode, offset6 = assign.offset;
      }
    } catch (_) {
    }
  }
  if (!node8 && doc2.caretRangeFromPoint) {
    var range3 = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range3) {
      assign$1 = range3, node8 = assign$1.startContainer, offset6 = assign$1.startOffset;
    }
  }
  var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari) {
    for (var p = elt; node8 && p; p = parentNode(p)) {
      if (p.draggable) {
        node8 = offset6 = null;
      }
    }
  }
  elt = targetKludge(elt, coords);
  if (node8) {
    if (result.gecko && node8.nodeType == 1) {
      offset6 = Math.min(offset6, node8.childNodes.length);
      if (offset6 < node8.childNodes.length) {
        var next = node8.childNodes[offset6], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset6++;
        }
      }
    }
    if (node8 == view.dom && offset6 == node8.childNodes.length - 1 && node8.lastChild.nodeType == 1 && coords.top > node8.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset6 == 0 || node8.nodeType != 1 || node8.childNodes[offset6 - 1].nodeName != "BR") {
      pos = posFromCaret(view, node8, offset6, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object4, bias) {
  var rects = object4.getClientRects();
  return !rects.length ? object4.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  var ref2 = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node8 = ref2.node;
  var offset6 = ref2.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node8.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node8.nodeValue) || (side < 0 ? !offset6 : offset6 == node8.nodeValue.length))) {
      var rect = singleRect(textRange(node8, offset6, offset6), side);
      if (result.gecko && offset6 && /\s/.test(node8.nodeValue[offset6 - 1]) && offset6 < node8.nodeValue.length) {
        var rectBefore = singleRect(textRange(node8, offset6 - 1, offset6 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node8, offset6, offset6 + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from8 = offset6, to = offset6, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset6) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset6 == node8.nodeValue.length) {
        from8--;
        takeSide = 1;
      } else if (side < 0) {
        from8--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node8, from8, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset6 && (side < 0 || offset6 == nodeSize$1(node8))) {
      var before6 = node8.childNodes[offset6 - 1];
      if (before6.nodeType == 1) {
        return flattenH(before6.getBoundingClientRect(), false);
      }
    }
    if (offset6 < nodeSize$1(node8)) {
      var after6 = node8.childNodes[offset6];
      if (after6.nodeType == 1) {
        return flattenH(after6.getBoundingClientRect(), true);
      }
    }
    return flattenH(node8.getBoundingClientRect(), side >= 0);
  }
  if (offset6 && (side < 0 || offset6 == nodeSize$1(node8))) {
    var before$1 = node8.childNodes[offset6 - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize$1(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV(singleRect(target, 1), false);
    }
  }
  if (offset6 < nodeSize$1(node8)) {
    var after$1 = node8.childNodes[offset6];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) {
      after$1 = after$1.nextSibling;
    }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node8.nodeType == 3 ? textRange(node8) : node8, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0) {
    return rect;
  }
  var x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0) {
    return rect;
  }
  var y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref2.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child11 = dom.firstChild; child11; child11 = child11.nextSibling) {
      var boxes = void 0;
      if (child11.nodeType == 1) {
        boxes = child11.getClientRects();
      } else if (child11.nodeType == 3) {
        boxes = textRange(child11, 0, child11.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var ref2 = state.selection;
  var $head = ref2.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset6 = $head.parentOffset, atStart4 = !offset6, atEnd4 = offset6 == $head.parent.content.size;
  var sel = view.root.getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart4 : atEnd4;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
var ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};
var prototypeAccessors$f = { size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
ViewDesc.prototype.matchesWidget = function matchesWidget() {
  return false;
};
ViewDesc.prototype.matchesMark = function matchesMark() {
  return false;
};
ViewDesc.prototype.matchesNode = function matchesNode() {
  return false;
};
ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
  return false;
};
ViewDesc.prototype.parseRule = function parseRule() {
  return null;
};
ViewDesc.prototype.stopEvent = function stopEvent() {
  return false;
};
prototypeAccessors$f.size.get = function() {
  var size = 0;
  for (var i = 0; i < this.children.length; i++) {
    size += this.children[i].size;
  }
  return size;
};
prototypeAccessors$f.border.get = function() {
  return 0;
};
ViewDesc.prototype.destroy = function destroy() {
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i = 0; i < this.children.length; i++) {
    this.children[i].destroy();
  }
};
ViewDesc.prototype.posBeforeChild = function posBeforeChild(child11) {
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this.children[i];
    if (cur == child11) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors$f.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors$f.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors$f.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors$f.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset6, bias) {
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset6 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset6];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd4;
  if (dom == this.dom && this.contentDOM) {
    atEnd4 = offset6 > domIndex$1(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd4 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset6 == 0) {
      for (var search = dom; ; search = search.parentNode) {
        if (search == this.dom) {
          atEnd4 = false;
          break;
        }
        if (search.parentNode.firstChild != search) {
          break;
        }
      }
    }
    if (atEnd4 == null && offset6 == dom.childNodes.length) {
      for (var search$1 = dom; ; search$1 = search$1.parentNode) {
        if (search$1 == this.dom) {
          atEnd4 = true;
          break;
        }
        if (search$1.parentNode.lastChild != search$1) {
          break;
        }
      }
    }
  }
  return (atEnd4 == null ? bias > 0 : atEnd4) ? this.posAtEnd : this.posAtStart;
};
ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
  for (var first2 = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first2 && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
        first2 = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc.prototype.getDesc = function getDesc(dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this) {
      return desc;
    }
  }
};
ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset6, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset6, bias);
    }
  }
  return -1;
};
ViewDesc.prototype.descAt = function descAt(pos) {
  for (var i = 0, offset6 = 0; i < this.children.length; i++) {
    var child11 = this.children[i], end7 = offset6 + child11.size;
    if (offset6 == pos && end7 != offset6) {
      while (!child11.border && child11.children.length) {
        child11 = child11.children[0];
      }
      return child11;
    }
    if (pos < end7) {
      return child11.descAt(pos - offset6 - child11.border);
    }
    offset6 = end7;
  }
};
ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  var i = 0, offset6 = 0;
  for (var curPos = 0; i < this.children.length; i++) {
    var child11 = this.children[i], end7 = curPos + child11.size;
    if (end7 > pos || child11 instanceof TrailingHackViewDesc) {
      offset6 = pos - curPos;
      break;
    }
    curPos = end7;
  }
  if (offset6) {
    return this.children[i].domFromPos(offset6 - this.children[i].border, side);
  }
  for (var prev = void 0; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {
  }
  if (side <= 0) {
    var prev$1, enter7 = true;
    for (; ; i--, enter7 = false) {
      prev$1 = i ? this.children[i - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (prev$1 && side && enter7 && !prev$1.border && !prev$1.domAtom) {
      return prev$1.domFromPos(prev$1.size, side);
    }
    return { node: this.contentDOM, offset: prev$1 ? domIndex$1(prev$1.dom) + 1 : 0 };
  } else {
    var next, enter$12 = true;
    for (; ; i++, enter$12 = false) {
      next = i < this.children.length ? this.children[i] : null;
      if (!next || next.dom.parentNode == this.contentDOM) {
        break;
      }
    }
    if (next && enter$12 && !next.border && !next.domAtom) {
      return next.domFromPos(0, side);
    }
    return { node: this.contentDOM, offset: next ? domIndex$1(next.dom) : this.contentDOM.childNodes.length };
  }
};
ViewDesc.prototype.parseRange = function parseRange(from8, to, base2) {
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from8, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset6 = base2, i = 0; ; i++) {
    var child11 = this.children[i], end7 = offset6 + child11.size;
    if (fromOffset == -1 && from8 <= end7) {
      var childBase = offset6 + child11.border;
      if (from8 >= childBase && to <= end7 - child11.border && child11.node && child11.contentDOM && this.contentDOM.contains(child11.contentDOM)) {
        return child11.parseRange(from8, to, childBase);
      }
      from8 = offset6;
      for (var j = i; j > 0; j--) {
        var prev = this.children[j - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex$1(prev.dom) + 1;
          break;
        }
        from8 -= prev.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && (end7 > to || i == this.children.length - 1)) {
      to = end7;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex$1(next.dom);
          break;
        }
        to += next.size;
      }
      if (toOffset == -1) {
        toOffset = this.contentDOM.childNodes.length;
      }
      break;
    }
    offset6 = end7;
  }
  return { node: this.contentDOM, from: from8, to, fromOffset, toOffset };
};
ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child11 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child11.size == 0 || child11.emptyChildAt(side);
};
ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
  var ref2 = this.domFromPos(pos, 0);
  var node8 = ref2.node;
  var offset6 = ref2.offset;
  if (node8.nodeType != 1 || offset6 == node8.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node8.childNodes[offset6];
};
ViewDesc.prototype.setSelection = function setSelection(anchor, head, root2, force) {
  var from8 = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset6 = 0; i < this.children.length; i++) {
    var child11 = this.children[i], end7 = offset6 + child11.size;
    if (from8 > offset6 && to < end7) {
      return child11.setSelection(anchor - offset6 - child11.border, head - offset6 - child11.border, root2, force);
    }
    offset6 = end7;
  }
  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root2.getSelection();
  var brKludge = false;
  if ((result.gecko || result.safari) && anchor == head) {
    var node8 = anchorDOM.node;
    var offset$12 = anchorDOM.offset;
    if (node8.nodeType == 3) {
      brKludge = offset$12 && node8.nodeValue[offset$12 - 1] == "\n";
      if (brKludge && offset$12 == node8.nodeValue.length) {
        for (var scan = node8, after6 = void 0; scan; scan = scan.parentNode) {
          if (after6 = scan.nextSibling) {
            if (after6.nodeName == "BR") {
              anchorDOM = headDOM = { node: after6.parentNode, offset: domIndex$1(after6) + 1 };
            }
            break;
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) {
            break;
          }
        }
      }
    } else {
      var prev = node8.childNodes[offset$12 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") {
      force = true;
    }
  }
  if (!(force || brKludge && result.safari) && isEquivalentPosition$1(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition$1(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) {
        domSel.extend(headDOM.node, headDOM.offset);
      }
      domSelExtended = true;
    } catch (err6) {
      if (!(err6 instanceof DOMException)) {
        throw err6;
      }
    }
  }
  if (!domSelExtended) {
    if (anchor > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    var range3 = document.createRange();
    range3.setEnd(headDOM.node, headDOM.offset);
    range3.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range3);
  }
};
ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
  return !this.contentDOM && mutation.type != "selection";
};
prototypeAccessors$f.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc.prototype.markDirty = function markDirty(from8, to) {
  for (var offset6 = 0, i = 0; i < this.children.length; i++) {
    var child11 = this.children[i], end7 = offset6 + child11.size;
    if (offset6 == end7 ? from8 <= end7 && to >= offset6 : from8 < end7 && to > offset6) {
      var startInside = offset6 + child11.border, endInside = end7 - child11.border;
      if (from8 >= startInside && to <= endInside) {
        this.dirty = from8 == offset6 || to == end7 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from8 == startInside && to == endInside && (child11.contentLost || child11.dom.parentNode != this.contentDOM)) {
          child11.dirty = NODE_DIRTY;
        } else {
          child11.markDirty(from8 - startInside, to - startInside);
        }
        return;
      } else {
        child11.dirty = child11.dom == child11.contentDOM && child11.dom.parentNode == this.contentDOM && !child11.children.length ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset6 = end7;
  }
  this.dirty = CONTENT_DIRTY;
};
ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
  var level = 1;
  for (var node8 = this.parent; node8; node8 = node8.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node8.dirty < dirty) {
      node8.dirty = dirty;
    }
  }
};
prototypeAccessors$f.domAtom.get = function() {
  return false;
};
prototypeAccessors$f.ignoreForCoords.get = function() {
  return false;
};
Object.defineProperties(ViewDesc.prototype, prototypeAccessors$f);
var nothing = [];
var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function WidgetViewDesc2(parent, widget2, view, pos) {
    var self2, dom = widget2.type.toDOM;
    if (typeof dom == "function") {
      dom = dom(view, function() {
        if (!self2) {
          return pos;
        }
        if (self2.parent) {
          return self2.parent.posBeforeChild(self2);
        }
      });
    }
    if (!widget2.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.widget = widget2;
    self2 = this;
  }
  if (ViewDesc3)
    WidgetViewDesc2.__proto__ = ViewDesc3;
  WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { domAtom: { configurable: true } };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
    return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    var stop2 = this.widget.spec.stopEvent;
    return stop2 ? stop2(event) : false;
  };
  WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  WidgetViewDesc2.prototype.destroy = function destroy4() {
    this.widget.type.destroy(this.dom);
    ViewDesc3.prototype.destroy.call(this);
  };
  prototypeAccessors$12.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc);
var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function CompositionViewDesc2(parent, dom, textDOM, text3) {
    ViewDesc3.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  if (ViewDesc3)
    CompositionViewDesc2.__proto__ = ViewDesc3;
  CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
  var prototypeAccessors$22 = { size: { configurable: true } };
  prototypeAccessors$22.size.get = function() {
    return this.text.length;
  };
  CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset6) {
    if (dom != this.textDOM) {
      return this.posAtStart + (offset6 ? this.size : 0);
    }
    return this.posAtStart + offset6;
  };
  CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.textDOM, offset: pos };
  };
  CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
  return CompositionViewDesc2;
}(ViewDesc);
var MarkViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function MarkViewDesc2(parent, mark7, dom, contentDOM) {
    ViewDesc3.call(this, parent, [], dom, contentDOM);
    this.mark = mark7;
  }
  if (ViewDesc3)
    MarkViewDesc2.__proto__ = ViewDesc3;
  MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create15(parent, mark7, inline2, view) {
    var custom = view.nodeViews[mark7.type.name];
    var spec = custom && custom(mark7, view, inline2);
    if (!spec || !spec.dom) {
      spec = DOMSerializer$1.renderSpec(document, mark7.type.spec.toDOM(mark7, inline2));
    }
    return new MarkViewDesc2(parent, mark7, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule2() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) {
      return null;
    }
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark7) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark7);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty2(from8, to) {
    ViewDesc3.prototype.markDirty.call(this, from8, to);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY;
    }
  };
  MarkViewDesc2.prototype.slice = function slice11(from8, to, view) {
    var copy12 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) {
      nodes = replaceNodes(nodes, to, size, view);
    }
    if (from8 > 0) {
      nodes = replaceNodes(nodes, 0, from8, view);
    }
    for (var i = 0; i < nodes.length; i++) {
      nodes[i].parent = copy12;
    }
    copy12.children = nodes;
    return copy12;
  };
  return MarkViewDesc2;
}(ViewDesc);
var NodeViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function NodeViewDesc2(parent, node8, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
    ViewDesc3.call(this, parent, node8.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM2;
    this.node = node8;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view, pos);
    }
  }
  if (ViewDesc3)
    NodeViewDesc2.__proto__ = ViewDesc3;
  NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
  NodeViewDesc2.create = function create15(parent, node8, outerDeco, innerDeco, view, pos) {
    var assign;
    var custom = view.nodeViews[node8.type.name], descObj;
    var spec = custom && custom(node8, view, function() {
      if (!descObj) {
        return pos;
      }
      if (descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node8.isText) {
      if (!dom) {
        dom = document.createTextNode(node8.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      assign = DOMSerializer$1.renderSpec(document, node8.type.spec.toDOM(node8)), dom = assign.dom, contentDOM = assign.contentDOM;
    }
    if (!contentDOM && !node8.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable")) {
        dom.contentEditable = false;
      }
      if (node8.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM2 = dom;
    dom = applyOuterDeco(dom, outerDeco, node8);
    if (spec) {
      return descObj = new CustomNodeViewDesc(parent, node8, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos + 1);
    } else if (node8.isText) {
      return new TextViewDesc(parent, node8, outerDeco, innerDeco, dom, nodeDOM2, view);
    } else {
      return new NodeViewDesc2(parent, node8, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule2() {
    var this$1$1 = this;
    if (this.node.type.spec.reparseInView) {
      return null;
    }
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre") {
      rule.preserveWhitespace = "full";
    }
    if (this.contentDOM && !this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      rule.getContent = function() {
        return this$1$1.contentDOM ? Fragment$5.empty : this$1$1.node.content;
      };
    }
    return rule;
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode2(node8, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node8.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$32.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$32.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
    var this$1$1 = this;
    var inline2 = this.node.inlineContent, off2 = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function(widget2, i, insideNode) {
      if (widget2.spec.marks) {
        updater.syncToMarks(widget2.spec.marks, inline2, view);
      } else if (widget2.type.side >= 0 && !insideNode) {
        updater.syncToMarks(i == this$1$1.node.childCount ? Mark$5.none : this$1$1.node.child(i).marks, inline2, view);
      }
      updater.placeWidget(widget2, view, off2);
    }, function(child11, outerDeco, innerDeco, i) {
      updater.syncToMarks(child11.marks, inline2, view);
      var compIndex;
      if (updater.findNodeMatch(child11, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child11.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child11, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child11, outerDeco, innerDeco, view, i))
        ;
      else {
        updater.addNode(child11, outerDeco, innerDeco, view, off2);
      }
      off2 += child11.nodeSize;
    });
    updater.syncToMarks(nothing, inline2, view);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition) {
        this.protectLocalComposition(view, localComposition);
      }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) {
        iosHacks(this.dom);
      }
    }
  };
  NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
    var ref2 = view.state.selection;
    var from8 = ref2.from;
    var to = ref2.to;
    if (!(view.state.selection instanceof TextSelection$3) || from8 < pos || to > pos + this.node.content.size) {
      return;
    }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) {
      return;
    }
    if (this.node.inlineContent) {
      var text3 = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text3, from8 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1 };
    }
  };
  NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref2) {
    var node8 = ref2.node;
    var pos = ref2.pos;
    var text3 = ref2.text;
    if (this.getDesc(node8)) {
      return;
    }
    var topNode = node8;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) {
        break;
      }
      while (topNode.previousSibling) {
        topNode.parentNode.removeChild(topNode.previousSibling);
      }
      while (topNode.nextSibling) {
        topNode.parentNode.removeChild(topNode.nextSibling);
      }
      if (topNode.pmViewDesc) {
        topNode.pmViewDesc = null;
      }
    }
    var desc = new CompositionViewDesc(this, topNode, node8, text3);
    view.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
  };
  NodeViewDesc2.prototype.update = function update3(node8, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node8.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node8, outerDeco, innerDeco, view);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node8, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node8;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view, this.posAtStart);
    }
    this.dirty = NOT_DIRTY;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.draggable = true;
    }
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.removeAttribute("draggable");
    }
  };
  prototypeAccessors$32.domAtom.get = function() {
    return this.node.isAtom;
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
  return NodeViewDesc2;
}(ViewDesc);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function TextViewDesc2(parent, node8, outerDeco, innerDeco, dom, nodeDOM2, view) {
    NodeViewDesc2.call(this, parent, node8, outerDeco, innerDeco, dom, null, nodeDOM2, view);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  var prototypeAccessors$42 = { domAtom: { configurable: true } };
  TextViewDesc2.prototype.parseRule = function parseRule2() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) {
      skip = skip.parentNode;
    }
    return { skip: skip || true };
  };
  TextViewDesc2.prototype.update = function update3(node8, outerDeco, _, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node8.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node8.text != this.node.text) && node8.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node8.text;
      if (view.trackWrites == this.nodeDOM) {
        view.trackWrites = null;
      }
    }
    this.node = node8;
    this.dirty = NOT_DIRTY;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n = this.nodeDOM; n; n = n.parentNode) {
      if (n == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset6, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset6, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset6, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  TextViewDesc2.prototype.slice = function slice11(from8, to, view) {
    var node8 = this.node.cut(from8, to), dom = document.createTextNode(node8.text);
    return new TextViewDesc2(this.parent, node8, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  TextViewDesc2.prototype.markDirty = function markDirty2(from8, to) {
    NodeViewDesc2.prototype.markDirty.call(this, from8, to);
    if (this.dom != this.nodeDOM && (from8 == 0 || to == this.nodeDOM.nodeValue.length)) {
      this.dirty = NODE_DIRTY;
    }
  };
  prototypeAccessors$42.domAtom.get = function() {
    return false;
  };
  Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
  return TextViewDesc2;
}(NodeViewDesc);
var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc3) {
  function TrailingHackViewDesc2() {
    ViewDesc3.apply(this, arguments);
  }
  if (ViewDesc3)
    TrailingHackViewDesc2.__proto__ = ViewDesc3;
  TrailingHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
  TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
  var prototypeAccessors$52 = { domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
  TrailingHackViewDesc2.prototype.parseRule = function parseRule2() {
    return { ignore: true };
  };
  TrailingHackViewDesc2.prototype.matchesHack = function matchesHack2(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  };
  prototypeAccessors$52.domAtom.get = function() {
    return true;
  };
  prototypeAccessors$52.ignoreForCoords.get = function() {
    return this.dom.nodeName == "IMG";
  };
  Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
  return TrailingHackViewDesc2;
}(ViewDesc);
var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node8, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
    NodeViewDesc2.call(this, parent, node8, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update3(node8, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) {
      return false;
    }
    if (this.spec.update) {
      var result2 = this.spec.update(node8, outerDeco, innerDeco);
      if (result2) {
        this.updateInner(node8, outerDeco, innerDeco, view);
      }
      return result2;
    } else if (!this.contentDOM && !node8.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node8, outerDeco, innerDeco, view);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root2, force);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy4() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node8, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel(node8.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM2;
  }
  var curDOM = nodeDOM2;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) {
        dom.classList.remove(prevList[i]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
    if (dom.classList.length == 0) {
      dom.removeAttribute("class");
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node8) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node8, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = function ViewTreeUpdater2(top2, lockedNode) {
  this.top = top2;
  this.lock = lockedNode;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatch = preMatch(top2.node.content, top2);
};
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start8, end7) {
  if (start8 == end7) {
    return;
  }
  for (var i = start8; i < end7; i++) {
    this.top.children[i].destroy();
  }
  this.top.children.splice(start8, end7 - start8);
  this.changed = true;
};
ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks6, inline2, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks6.length);
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks6[keep]) && marks6[keep].type.spec.spanning !== false) {
    keep++;
  }
  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks6.length) {
    this.stack.push(this.top, this.index + 1);
    var found2 = -1;
    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
      if (this.top.children[i].matchesMark(marks6[depth])) {
        found2 = i;
        break;
      }
    }
    if (found2 > -1) {
      if (found2 > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found2);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks6[depth], inline2, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node8, outerDeco, innerDeco, index6) {
  var found2 = -1, targetDesc;
  if (index6 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index6 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node8, outerDeco, innerDeco)) {
    found2 = this.top.children.indexOf(targetDesc, this.index);
  } else {
    for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
      var child11 = this.top.children[i];
      if (child11.matchesNode(node8, outerDeco, innerDeco) && !this.preMatch.matched.has(child11)) {
        found2 = i;
        break;
      }
    }
  }
  if (found2 < 0) {
    return false;
  }
  this.destroyBetween(this.index, found2);
  this.index++;
  return true;
};
ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node8, outerDeco, innerDeco, index6, view) {
  var child11 = this.top.children[index6];
  if (!child11.update(node8, outerDeco, innerDeco, view)) {
    return false;
  }
  this.destroyBetween(this.index, index6);
  this.index = index6 + 1;
  return true;
};
ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
  for (; ; ) {
    var parent = domNode.parentNode;
    if (!parent) {
      return -1;
    }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) {
        for (var i = this.index; i < this.top.children.length; i++) {
          if (this.top.children[i] == desc) {
            return i;
          }
        }
      }
      return -1;
    }
    domNode = parent;
  }
};
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node8, outerDeco, innerDeco, view, index6) {
  for (var i = this.index; i < this.top.children.length; i++) {
    var next = this.top.children[i];
    if (next instanceof NodeViewDesc) {
      var preMatch2 = this.preMatch.matched.get(next);
      if (preMatch2 != null && preMatch2 != index6) {
        return false;
      }
      var nextDOM = next.dom;
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node8.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node8.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node8, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i);
        if (next.dom != nextDOM) {
          this.changed = true;
        }
        this.index++;
        return true;
      }
      break;
    }
  }
  return false;
};
ViewTreeUpdater.prototype.addNode = function addNode(node8, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node8, outerDeco, innerDeco, view, pos));
  this.changed = true;
};
ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget2) && (widget2 == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget2, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false") {
      this.addHackNode("IMG");
    }
    this.addHackNode("BR");
  }
};
ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") {
      dom.className = "ProseMirror-separator";
    }
    if (nodeName == "BR") {
      dom.className = "ProseMirror-trailingBreak";
    }
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc, descI = curDesc.children.length;
  var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      var desc = void 0;
      for (; ; ) {
        if (descI) {
          var next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      var node8 = desc.node;
      if (!node8) {
        continue;
      }
      if (node8 != frag.child(fI - 1)) {
        break;
      }
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals3 = deco.locals(parent), offset6 = 0;
  if (locals3.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child11 = parent.child(i);
      onNode(child11, locals3, deco.forChild(offset6, child11), i);
      offset6 += child11.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals3.length && locals3[decoIndex].to == offset6) {
      var widget2 = locals3[decoIndex++], widgets = void 0;
      while (decoIndex < locals3.length && locals3[decoIndex].to == offset6) {
        (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget2, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index6 = void 0;
    if (restNode) {
      index6 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index6 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset6) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals3.length && locals3[decoIndex].from <= offset6 && locals3[decoIndex].to > offset6) {
      active.push(locals3[decoIndex++]);
    }
    var end7 = offset6 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end7;
      if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
        cutAt = locals3[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end7) {
        restNode = child$1.cut(cutAt - offset6);
        child$1 = child$1.cut(0, cutAt - offset6);
        end7 = cutAt;
        index6 = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d) {
      return !d.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset6, child$1), index6);
    offset6 = end7;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node8, offset6) {
  for (; ; ) {
    if (node8.nodeType == 3) {
      return node8;
    }
    if (node8.nodeType == 1 && offset6 > 0) {
      if (node8.childNodes.length > offset6 && node8.childNodes[offset6].nodeType == 3) {
        return node8.childNodes[offset6];
      }
      node8 = node8.childNodes[offset6 - 1];
      offset6 = nodeSize$1(node8);
    } else if (node8.nodeType == 1 && offset6 < node8.childNodes.length) {
      node8 = node8.childNodes[offset6];
      offset6 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from8, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    var child11 = frag.child(i++), childStart = pos;
    pos += child11.nodeSize;
    if (!child11.isText) {
      continue;
    }
    var str = child11.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from8 && childStart < to) {
      var found2 = str.lastIndexOf(text3, to - childStart - 1);
      if (found2 >= 0 && found2 + text3.length + childStart >= from8) {
        return childStart + found2;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes, from8, to, view, replacement) {
  var result2 = [];
  for (var i = 0, off2 = 0; i < nodes.length; i++) {
    var child11 = nodes[i], start8 = off2, end7 = off2 += child11.size;
    if (start8 >= to || end7 <= from8) {
      result2.push(child11);
    } else {
      if (start8 < from8) {
        result2.push(child11.slice(0, from8 - start8, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end7 > to) {
        result2.push(child11.slice(to - start8, child11.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM$1(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed$1(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node) {
      nearestDesc2 = nearestDesc2.parent;
    }
    if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection$3.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge$1(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      var pos = nearestDesc2.posBefore;
      selection = new NodeSelection$3(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween$1(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection$1(view) {
  return view.editable ? view.hasFocus() : hasSelection$1(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM$1(view, force) {
  var sel = view.state.selection;
  syncNodeSelection$1(view, sel);
  if (!editorOwnsSelection$1(view)) {
    return;
  }
  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {
    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && isEquivalentPosition$1(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper$1(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable$1 && !(sel instanceof TextSelection$3)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear$1(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear$1(view, sel.to);
      }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable$1) {
      if (resetEditableFrom) {
        resetEditable$1(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable$1(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange$1(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable$1 = result.safari || result.chrome && result.chrome_version < 63;
function temporarilyEditableNear$1(view, pos) {
  var ref2 = view.docView.domFromPos(pos, 0);
  var node8 = ref2.node;
  var offset6 = ref2.offset;
  var after6 = offset6 < node8.childNodes.length ? node8.childNodes[offset6] : null;
  var before6 = offset6 ? node8.childNodes[offset6 - 1] : null;
  if (result.safari && after6 && after6.contentEditable == "false") {
    return setEditable$1(after6);
  }
  if ((!after6 || after6.contentEditable == "false") && (!before6 || before6.contentEditable == "false")) {
    if (after6) {
      return setEditable$1(after6);
    } else if (before6) {
      return setEditable$1(before6);
    }
  }
}
function setEditable$1(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable$1(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange$1(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node8 = domSel.anchorNode, offset6 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node8 || domSel.anchorOffset != offset6) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection$1(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper$1(view) {
  var domSel = view.root.getSelection(), range3 = document.createRange();
  var node8 = view.cursorWrapper.dom, img = node8.nodeName == "IMG";
  if (img) {
    range3.setEnd(node8.parentNode, domIndex$1(node8) + 1);
  } else {
    range3.setEnd(node8, 0);
  }
  range3.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range3);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node8.disabled = true;
    node8.disabled = false;
  }
}
function syncNodeSelection$1(view, sel) {
  if (sel instanceof NodeSelection$3) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection$1(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection$1(view);
  }
}
function clearNodeSelection$1(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween$1(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f) {
    return f(view, $anchor, $head);
  }) || TextSelection$3.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection$1(view);
}
function hasSelection$1(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition$1(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock$1(state, dir) {
  var ref2 = state.selection;
  var $anchor = ref2.$anchor;
  var $head = ref2.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection$3.findFrom($start, dir);
}
function apply$1(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally$1(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection$3) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock$1(view.state, dir);
      if (next && next instanceof NodeSelection$3) {
        return apply$1(view, next);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node8 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node8 || node8.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node8.nodeSize : $head.pos;
      if (!(node8.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection$3.isSelectable(node8)) {
        return apply$1(view, new NodeSelection$3(dir < 0 ? view.state.doc.resolve($head.pos - node8.nodeSize) : $head));
      } else if (result.webkit) {
        return apply$1(view, new TextSelection$3(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node8.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection$3 && sel.node.isInline) {
    return apply$1(view, new TextSelection$3(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock$1(view.state, dir);
    if (next$1) {
      return apply$1(view, next$1);
    }
    return false;
  }
}
function nodeLen$1(node8) {
  return node8.nodeType == 3 ? node8.nodeValue.length : node8.childNodes.length;
}
function isIgnorable$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft$1(view) {
  var sel = view.root.getSelection();
  var node8 = sel.focusNode, offset6 = sel.focusOffset;
  if (!node8) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node8.nodeType == 1 && offset6 < nodeLen$1(node8) && isIgnorable$1(node8.childNodes[offset6])) {
    force = true;
  }
  for (; ; ) {
    if (offset6 > 0) {
      if (node8.nodeType != 1) {
        break;
      } else {
        var before6 = node8.childNodes[offset6 - 1];
        if (isIgnorable$1(before6)) {
          moveNode = node8;
          moveOffset = --offset6;
        } else if (before6.nodeType == 3) {
          node8 = before6;
          offset6 = node8.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode$1(node8)) {
      break;
    } else {
      var prev = node8.previousSibling;
      while (prev && isIgnorable$1(prev)) {
        moveNode = node8.parentNode;
        moveOffset = domIndex$1(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node8 = node8.parentNode;
        if (node8 == view.dom) {
          break;
        }
        offset6 = 0;
      } else {
        node8 = prev;
        offset6 = nodeLen$1(node8);
      }
    }
  }
  if (force) {
    setSelFocus$1(view, sel, node8, offset6);
  } else if (moveNode) {
    setSelFocus$1(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight$1(view) {
  var sel = view.root.getSelection();
  var node8 = sel.focusNode, offset6 = sel.focusOffset;
  if (!node8) {
    return;
  }
  var len = nodeLen$1(node8);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset6 < len) {
      if (node8.nodeType != 1) {
        break;
      }
      var after6 = node8.childNodes[offset6];
      if (isIgnorable$1(after6)) {
        moveNode = node8;
        moveOffset = ++offset6;
      } else {
        break;
      }
    } else if (isBlockNode$1(node8)) {
      break;
    } else {
      var next = node8.nextSibling;
      while (next && isIgnorable$1(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex$1(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node8 = node8.parentNode;
        if (node8 == view.dom) {
          break;
        }
        offset6 = len = 0;
      } else {
        node8 = next;
        offset6 = 0;
        len = nodeLen$1(node8);
      }
    }
  }
  if (moveNode) {
    setSelFocus$1(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus$1(view, sel, node8, offset6) {
  if (selectionCollapsed$1(sel)) {
    var range3 = document.createRange();
    range3.setEnd(node8, offset6);
    range3.setStart(node8, offset6);
    sel.removeAllRanges();
    sel.addRange(range3);
  } else if (sel.extend) {
    sel.extend(node8, offset6);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM$1(view);
    }
  }, 50);
}
function selectVertically$1(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection$3 && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock$1(view.state, dir);
    if (next && next instanceof NodeSelection$3) {
      return apply$1(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection$3 ? Selection$3.near(side, dir) : Selection$3.findFrom(side, dir);
    return beyond ? apply$1(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete$1(view, dir) {
  if (!(view.state.selection instanceof TextSelection$3)) {
    return true;
  }
  var ref2 = view.state.selection;
  var $head = ref2.$head;
  var $anchor = ref2.$anchor;
  var empty2 = ref2.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable$1(view, node8, state) {
  view.domObserver.stop();
  node8.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug$1(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref2 = view.root.getSelection();
  var focusNode = ref2.focusNode;
  var focusOffset = ref2.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child11 = focusNode.firstChild;
    switchEditable$1(view, child11, true);
    setTimeout(function() {
      return switchEditable$1(view, child11, false);
    }, 20);
  }
}
function getMods$1(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown$1(view, event) {
  var code2 = event.keyCode, mods = getMods$1(event);
  if (code2 == 8 || result.mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete$1(view, -1) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 46 || result.mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete$1(view, 1) || skipIgnoredNodesRight$1(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37) {
    return selectHorizontally$1(view, -1, mods) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 39) {
    return selectHorizontally$1(view, 1, mods) || skipIgnoredNodesRight$1(view);
  } else if (code2 == 38) {
    return selectVertically$1(view, -1, mods) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 40) {
    return safariDownArrowBug$1(view) || selectVertically$1(view, 1, mods) || skipIgnoredNodesRight$1(view);
  } else if (mods == (result.mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref2 = view.docView.parseRange(from_, to_);
  var parent = ref2.node;
  var fromOffset = ref2.fromOffset;
  var toOffset = ref2.toOffset;
  var from8 = ref2.from;
  var to = ref2.to;
  var domSel = view.root.getSelection(), find3 = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find3 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed$1(domSel)) {
      find3.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off2 = toOffset; off2 > fromOffset; off2--) {
      var node8 = parent.childNodes[off2 - 1], desc = node8.pmViewDesc;
      if (node8.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from8);
  var sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    editableContent: true,
    findPositions: find3,
    ruleFromNode,
    context: $from
  });
  if (find3 && find3[0].pos != null) {
    var anchor$1 = find3[0].pos, head = find3[1] && find3[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from8, head: head + from8 };
  }
  return { doc: doc2, sel, from: from8, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from8, to, typeOver, addedNodes) {
  if (from8 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM$1(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from8);
  var shared = $before.sharedDepth(to);
  from8 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse8 = parseBetween(view, from8, to);
  if (result.chrome && view.cursorWrapper && parse8.sel && parse8.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse8.sel = { anchor: parse8.sel.anchor + size, head: parse8.sel.anchor + size };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse8.from, parse8.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse8.doc.content, parse8.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection$3 && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse8.sel && parse8.sel.anchor != parse8.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n) {
      return n.nodeName == "DIV" || n.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f) {
      return f(view, keyEvent$1(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse8.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse8.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection$3) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse8.from && parse8.doc.textBetween(change.start - parse8.from - 1, change.start - parse8.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse8.doc.resolveNoCache(change.start - parse8.from);
  var $to = parse8.doc.resolveNoCache(change.endB - parse8.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse8.doc.content.size && (nextSel = Selection$3.findFrom(parse8.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent$1(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent$1(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse8.sel && parse8.sel.anchor == parse8.sel.head && parse8.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse8.doc.resolveNoCache(change.endB - parse8.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent$1(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM$1(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f) {
        return f(view, chFrom, chTo, text$1);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse8.doc.slice(change.start - parse8.from, change.endB - parse8.from));
  }
  if (parse8.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse8.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween$1(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type4, mark7, update3;
  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark7 = added[0];
    type4 = "add";
    update3 = function(node8) {
      return node8.mark(mark7.addToSet(node8.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark7 = removed[0];
    type4 = "remove";
    update3 = function(node8) {
      return node8.mark(mark7.removeFromSet(node8.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update3(prev.child(i$2)));
  }
  if (Fragment$5.from(updated).eq(cur)) {
    return { mark: mark7, type: type4 };
  }
}
function looksLikeJoin(old, start8, end7, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end7 - start8 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start8);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end7 || skipClosingAndOpening($next, true, false) < end7) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end7 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end7++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end7++;
    }
  }
  return end7;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start8 = a.findDiffStart(b, pos);
  if (start8 == null) {
    return null;
  }
  var ref2 = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref2.a;
  var endB = ref2.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start8 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start8;
  }
  if (endA < start8 && a.size < b.size) {
    var move2 = preferredPos <= start8 && preferredPos >= endA ? start8 - preferredPos : 0;
    start8 -= move2;
    endB = start8 + (endB - endA);
    endA = start8;
  } else if (endB < start8) {
    var move$1 = preferredPos <= start8 && preferredPos >= endB ? start8 - preferredPos : 0;
    start8 -= move$1;
    endA = start8 + (endA - endB);
    endB = start8;
  }
  return { start: start8, endA, endB };
}
function serializeForClipboard$1(view, slice11) {
  var context = [];
  var content4 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  while (openStart > 1 && openEnd > 1 && content4.childCount == 1 && content4.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node8 = content4.firstChild;
    context.push(node8.type.name, node8.attrs != node8.type.defaultAttrs ? node8.attrs : null);
    content4 = node8.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer$1.fromSchema(view.state.schema);
  var doc2 = detachedDoc$1(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content4, { document: doc2 }));
  var firstChild = wrap2.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap$1[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild) {
        wrapper.appendChild(wrap2.firstChild);
      }
      wrap2.appendChild(wrapper);
      if (needsWrap[i] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f) {
    return f(slice11);
  }) || slice11.content.textBetween(0, slice11.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard$1(view, text3, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice11;
  if (!html && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function(f) {
      text3 = f(text3, inCode || plainText);
    });
    if (inCode) {
      return text3 ? new Slice$5(Fragment$5.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice$5.empty;
    }
    var parsed = view.someProp("clipboardTextParser", function(f) {
      return f(text3, $context, plainText);
    });
    if (parsed) {
      slice11 = parsed;
    } else {
      var marks6 = $context.marks();
      var ref2 = view.state;
      var schema = ref2.schema;
      var serializer = DOMSerializer$1.fromSchema(schema);
      dom = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach(function(block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) {
          p.appendChild(serializer.serializeNode(schema.text(block, marks6)));
        }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f) {
      html = f(html);
    });
    dom = readHTML$1(html);
    if (result.webkit) {
      restoreReplacedSpaces$1(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice11) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice11 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode2(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents$1.test(dom2.parentNode.nodeName)) {
          return { ignore: true };
        }
      }
    });
  }
  if (sliceData) {
    slice11 = addContext$1(closeSlice$1(slice11, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice11 = Slice$5.maxOpen(normalizeSiblings$1(slice11.content, $context), true);
    if (slice11.openStart || slice11.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node8 = slice11.content.firstChild; openStart < slice11.openStart && !node8.type.spec.isolating; openStart++, node8 = node8.firstChild) {
      }
      for (var node$1 = slice11.content.lastChild; openEnd < slice11.openEnd && !node$1.type.spec.isolating; openEnd++, node$1 = node$1.lastChild) {
      }
      slice11 = closeSlice$1(slice11, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", function(f) {
    slice11 = f(slice11);
  });
  return slice11;
}
var inlineParents$1 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings$1(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d2) {
    var parent = $context.node(d2);
    var match = parent.contentMatchAt($context.index(d2));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node8) {
      if (!result2) {
        return;
      }
      var wrap2 = match.findWrapping(node8.type), inLast;
      if (!wrap2) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling$1(wrap2, lastWrap, node8, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight$1(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers$1(node8, wrap2);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap2;
      }
    });
    if (result2) {
      return { v: Fragment$5.from(result2) };
    }
  };
  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop(d);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers$1(node8, wrap2, from8) {
  if (from8 === void 0)
    from8 = 0;
  for (var i = wrap2.length - 1; i >= from8; i--) {
    node8 = wrap2[i].create(null, Fragment$5.from(node8));
  }
  return node8;
}
function addToSibling$1(wrap2, lastWrap, node8, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    var inner = addToSibling$1(wrap2, lastWrap, node8, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node8.type : wrap2[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment$5.from(withWrappers$1(node8, wrap2, depth + 1))));
    }
  }
}
function closeRight$1(node8, depth) {
  if (depth == 0) {
    return node8;
  }
  var fragment = node8.content.replaceChild(node8.childCount - 1, closeRight$1(node8.lastChild, depth - 1));
  var fill = node8.contentMatchAt(node8.childCount).fillBefore(Fragment$5.empty, true);
  return node8.copy(fragment.append(fill));
}
function closeRange$1(fragment, side, from8, to, depth, openEnd) {
  var node8 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node8.content;
  if (depth < to - 1) {
    inner = closeRange$1(inner, side, from8, to, depth + 1, openEnd);
  }
  if (depth >= from8) {
    inner = side < 0 ? node8.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node8.contentMatchAt(node8.childCount).fillBefore(Fragment$5.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node8.copy(inner));
}
function closeSlice$1(slice11, openStart, openEnd) {
  if (openStart < slice11.openStart) {
    slice11 = new Slice$5(closeRange$1(slice11.content, -1, openStart, slice11.openStart, 0, slice11.openEnd), openStart, slice11.openEnd);
  }
  if (openEnd < slice11.openEnd) {
    slice11 = new Slice$5(closeRange$1(slice11.content, 1, openEnd, slice11.openEnd, 0, 0), slice11.openStart, openEnd);
  }
  return slice11;
}
var wrapMap$1 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc$1 = null;
function detachedDoc$1() {
  return _detachedDoc$1 || (_detachedDoc$1 = document.implementation.createHTMLDocument("title"));
}
function readHTML$1(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) {
    html = html.slice(metas[0].length);
  }
  var elt = detachedDoc$1().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap$1[firstTag[1].toLowerCase()]) {
    html = wrap2.map(function(n) {
      return "<" + n + ">";
    }).join("") + html + wrap2.map(function(n) {
      return "</" + n + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html;
  if (wrap2) {
    for (var i = 0; i < wrap2.length; i++) {
      elt = elt.querySelector(wrap2[i]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces$1(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node8 = nodes[i];
    if (node8.childNodes.length == 1 && node8.textContent == "\xA0" && node8.parentNode) {
      node8.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node8);
    }
  }
}
function addContext$1(slice11, context) {
  if (!slice11.size) {
    return slice11;
  }
  var schema = slice11.content.firstChild.type.schema, array4;
  try {
    array4 = JSON.parse(context);
  } catch (e) {
    return slice11;
  }
  var content4 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  for (var i = array4.length - 2; i >= 0; i -= 2) {
    var type4 = schema.nodes[array4[i]];
    if (!type4 || type4.hasRequiredAttrs()) {
      break;
    }
    content4 = Fragment$5.from(type4.create(array4[i + 1], content4));
    openStart++;
    openEnd++;
  }
  return new Slice$5(content4, openStart, openEnd);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = result.ie && result.ie_version <= 11;
var SelectionState = function SelectionState2() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};
SelectionState.prototype.set = function set(sel) {
  this.anchorNode = sel.anchorNode;
  this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode;
  this.focusOffset = sel.focusOffset;
};
SelectionState.prototype.eq = function eq5(sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
};
var DOMObserver = function DOMObserver2(view, handleDOMChange) {
  var this$1$1 = this;
  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    for (var i = 0; i < mutations.length; i++) {
      this$1$1.queue.push(mutations[i]);
    }
    if (result.ie && result.ie_version <= 11 && mutations.some(function(m) {
      return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
    })) {
      this$1$1.flushSoon();
    } else {
      this$1$1.flush();
    }
  });
  this.currentSelection = new SelectionState();
  if (useCharData) {
    this.onCharData = function(e) {
      this$1$1.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
      this$1$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};
DOMObserver.prototype.flushSoon = function flushSoon() {
  var this$1$1 = this;
  if (this.flushingSoon < 0) {
    this.flushingSoon = window.setTimeout(function() {
      this$1$1.flushingSoon = -1;
      this$1$1.flush();
    }, 20);
  }
};
DOMObserver.prototype.forceFlush = function forceFlush() {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};
DOMObserver.prototype.start = function start2() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions);
  }
  if (useCharData) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.connectSelection();
};
DOMObserver.prototype.stop = function stop() {
  var this$1$1 = this;
  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i = 0; i < take.length; i++) {
        this.queue.push(take[i]);
      }
      window.setTimeout(function() {
        return this$1$1.flush();
      }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.disconnectSelection();
};
DOMObserver.prototype.connectSelection = function connectSelection() {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
  var this$1$1 = this;
  this.suppressingSelectionUpdates = true;
  setTimeout(function() {
    return this$1$1.suppressingSelectionUpdates = false;
  }, 50);
};
DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
  if (!hasFocusAndSelection(this.view)) {
    return;
  }
  if (this.suppressingSelectionUpdates) {
    return selectionToDOM$1(this.view);
  }
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    if (sel.focusNode && isEquivalentPosition$1(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
      return this.flushSoon();
    }
  }
  this.flush();
};
DOMObserver.prototype.setCurSelection = function setCurSelection() {
  this.currentSelection.set(this.view.root.getSelection());
};
DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
  if (sel.rangeCount == 0) {
    return true;
  }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
    this.setCurSelection();
    return true;
  }
};
DOMObserver.prototype.flush = function flush() {
  if (!this.view.docView || this.flushingSoon > -1) {
    return;
  }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }
  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection$1(this.view) && !this.ignoreSelectionChange(sel);
  var from8 = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i = 0; i < mutations.length; i++) {
      var result$1 = this.registerMutation(mutations[i], added);
      if (result$1) {
        from8 = from8 < 0 ? result$1.from : Math.min(result$1.from, from8);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) {
          typeOver = true;
        }
      }
    }
  }
  if (result.gecko && added.length > 1) {
    var brs = added.filter(function(n) {
      return n.nodeName == "BR";
    });
    if (brs.length == 2) {
      var a = brs[0];
      var b = brs[1];
      if (a.parentNode && a.parentNode.parentNode == b.parentNode) {
        b.remove();
      } else {
        a.remove();
      }
    }
  }
  if (from8 > -1 || newSel) {
    if (from8 > -1) {
      this.view.docView.markDirty(from8, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from8, to, typeOver, added);
    if (this.view.docView.dirty) {
      this.view.updateState(this.view.state);
    } else if (!this.currentSelection.eq(sel)) {
      selectionToDOM$1(this.view);
    }
    this.currentSelection.set(sel);
  }
};
DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
  if (added.indexOf(mut.target) > -1) {
    return null;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
    return null;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return null;
  }
  if (mut.type == "childList") {
    for (var i = 0; i < mut.addedNodes.length; i++) {
      added.push(mut.addedNodes[i]);
    }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
      return { from: desc.posBefore, to: desc.posAfter };
    }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref2 = mut.addedNodes[i$1];
        var previousSibling = ref2.previousSibling;
        var nextSibling = ref2.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
          prev = previousSibling;
        }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
          next = nextSibling;
        }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target ? domIndex$1(prev) + 1 : 0;
    var from8 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target ? domIndex$1(next) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return { from: from8, to };
  } else if (mut.type == "attributes") {
    return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
  } else {
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      typeOver: mut.target.nodeValue == mut.oldValue
    };
  }
};
var cssChecked = false;
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
var handlers$1 = {}, editHandlers$1 = {};
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver(view, function(from8, to, typeOver, added) {
    return readDOMChange(view, from8, to, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers$1[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers$1))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers$1)
    loop(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin$1(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type4 in view.eventHandlers) {
    view.dom.removeEventListener(type4, view.eventHandlers[type4]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type4 in currentHandlers) {
      if (!view.eventHandlers[type4]) {
        view.dom.addEventListener(type4, view.eventHandlers[type4] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node8 = event.target; node8 != view.dom; node8 = node8.parentNode) {
    if (!node8 || node8.nodeType == 11 || node8.pmViewDesc && node8.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers$1[event.type] && (view.editable || !(event.type in editHandlers$1))) {
    handlers$1[event.type](view, event);
  }
}
editHandlers$1.keydown = function(view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition$1(view, event)) {
    return;
  }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (result.android && result.chrome && event.keyCode == 13) {
    return;
  }
  if (event.keyCode != 229) {
    view.domObserver.forceFlush();
  }
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent$1(13, "Enter"));
        });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f) {
    return f(view, event);
  }) || captureKeyDown$1(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin$1(view, "key");
  }
};
editHandlers$1.keyup = function(view, e) {
  if (e.keyCode == 16) {
    view.shiftKey = false;
  }
};
editHandlers$1.keypress = function(view, event) {
  if (inOrNearComposition$1(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
    return;
  }
  if (view.someProp("handleKeyPress", function(f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection$3) || !sel.$from.sameParent(sel.$to)) {
    var text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function(f) {
      return f(view, sel.$from.pos, sel.$to.pos, text3);
    })) {
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords$1(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear$1(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext$1(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop = function(i2) {
    if (view.someProp(propName, function(f) {
      return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop(i);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection$1(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf$1(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node8 = $pos.nodeAfter;
  if (node8 && node8.isAtom && NodeSelection$3.isSelectable(node8)) {
    updateSelection$1(view, new NodeSelection$3($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode$1(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection$3) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node8 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection$3.isSelectable(node8)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection$1(view, NodeSelection$3.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick$1(view, pos, inside, event, selectNode) {
  return runHandlerOnContext$1(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode$1(view, inside) : selectClickedLeaf$1(view, inside));
}
function handleDoubleClick$1(view, pos, inside, event) {
  return runHandlerOnContext$1(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
    return f(view, pos, event);
  });
}
function handleTripleClick$2(view, pos, inside, event) {
  return runHandlerOnContext$1(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
    return f(view, pos, event);
  }) || defaultTripleClick$1(view, inside, event);
}
function defaultTripleClick$1(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection$1(view, TextSelection$3.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node8 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node8.inlineContent) {
      updateSelection$1(view, TextSelection$3.create(doc2, nodePos + 1, nodePos + 1 + node8.content.size), "pointer");
    } else if (NodeSelection$3.isSelectable(node8)) {
      updateSelection$1(view, NodeSelection$3.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush$1(view) {
  return endComposition$1(view);
}
var selectNodeModifier$1 = result.mac ? "metaKey" : "ctrlKey";
handlers$1.mousedown = function(view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush$1(view);
  var now = Date.now(), type4 = "singleClick";
  if (now - view.lastClick.time < 500 && isNear$1(event, view.lastClick) && !event[selectNodeModifier$1]) {
    if (view.lastClick.type == "singleClick") {
      type4 = "doubleClick";
    } else if (view.lastClick.type == "doubleClick") {
      type4 = "tripleClick";
    }
  }
  view.lastClick = { time: now, x: event.clientX, y: event.clientY, type: type4 };
  var pos = view.posAtCoords(eventCoords$1(event));
  if (!pos) {
    return;
  }
  if (type4 == "singleClick") {
    if (view.mouseDown) {
      view.mouseDown.done();
    }
    view.mouseDown = new MouseDown$1(view, pos, event, flushed);
  } else if ((type4 == "doubleClick" ? handleDoubleClick$1 : handleTripleClick$2)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin$1(view, "pointer");
  }
};
var MouseDown$1 = function MouseDown(view, pos, event, flushed) {
  var this$1$1 = this;
  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier$1];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;
  var ref2 = view.state;
  var selection = ref2.selection;
  if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection$3 && selection.from <= targetPos && selection.to > targetPos) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        if (this$1$1.view.mouseDown == this$1$1) {
          this$1$1.target.setAttribute("contentEditable", "false");
        }
      }, 20);
    }
    this.view.domObserver.start();
  }
  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin$1(view, "pointer");
};
MouseDown$1.prototype.done = function done() {
  var this$1$1 = this;
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.removeAttribute("draggable");
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) {
    setTimeout(function() {
      return selectionToDOM$1(this$1$1.view);
    });
  }
  this.view.mouseDown = null;
};
MouseDown$1.prototype.up = function up(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) {
    pos = this.view.posAtCoords(eventCoords$1(event));
  }
  if (this.allowDefault || !pos) {
    setSelectionOrigin$1(this.view, "pointer");
  } else if (handleSingleClick$1(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection$3) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
    updateSelection$1(this.view, Selection$3.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin$1(this.view, "pointer");
  }
};
MouseDown$1.prototype.move = function move(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  setSelectionOrigin$1(this.view, "pointer");
  if (event.buttons == 0) {
    this.done();
  }
};
handlers$1.touchdown = function(view) {
  forceDOMFlush$1(view);
  setSelectionOrigin$1(view, "pointer");
};
handlers$1.contextmenu = function(view) {
  return forceDOMFlush$1(view);
};
function inOrNearComposition$1(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition$1 = result.android ? 5e3 : -1;
editHandlers$1.compositionstart = editHandlers$1.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
      return m.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition$1(view, true);
      view.markCursor = null;
    } else {
      endComposition$1(view);
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node8 = sel.focusNode, offset6 = sel.focusOffset; node8 && node8.nodeType == 1 && offset6 != 0; ) {
          var before6 = offset6 < 0 ? node8.lastChild : node8.childNodes[offset6 - 1];
          if (!before6) {
            break;
          }
          if (before6.nodeType == 3) {
            sel.collapse(before6, before6.nodeValue.length);
            break;
          } else {
            node8 = before6;
            offset6 = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd$1(view, timeoutComposition$1);
};
editHandlers$1.compositionend = function(view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd$1(view, 20);
  }
};
function scheduleComposeEnd$1(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition$1(view);
    }, delay);
  }
}
function clearComposition$1(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent$1();
  }
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function timestampFromCustomEvent$1() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition$1(view, forceUpdate) {
  if (result.android && view.domObserver.flushingSoon >= 0) {
    return;
  }
  view.domObserver.forceFlush();
  clearComposition$1(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM$1(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy$1(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range3 = document.createRange();
  range3.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range3);
  setTimeout(function() {
    if (wrap2.parentNode) {
      wrap2.parentNode.removeChild(wrap2);
    }
    view.focus();
  }, 50);
}
var brokenClipboardAPI$1 = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
handlers$1.copy = editHandlers$1.cut = function(view, e) {
  var sel = view.state.selection, cut11 = e.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI$1 ? null : e.clipboardData;
  var slice11 = sel.content();
  var ref2 = serializeForClipboard$1(view, slice11);
  var dom = ref2.dom;
  var text3 = ref2.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy$1(view, dom);
  }
  if (cut11) {
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode$1(slice11) {
  return slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1 ? slice11.content.firstChild : null;
}
function capturePaste$1(view, e) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste$1(view, target.value, null, e);
    } else {
      doPaste$1(view, target.textContent, target.innerHTML, e);
    }
  }, 50);
}
function doPaste$1(view, text3, html, e) {
  var slice11 = parseFromClipboard$1(view, text3, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f) {
    return f(view, e, slice11 || Slice$5.empty);
  })) {
    return true;
  }
  if (!slice11) {
    return false;
  }
  var singleNode = sliceSingleNode$1(slice11);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice11);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers$1.paste = function(view, e) {
  if (view.composing && !result.android) {
    return;
  }
  var data = brokenClipboardAPI$1 ? null : e.clipboardData;
  if (data && doPaste$1(view, data.getData("text/plain"), data.getData("text/html"), e)) {
    e.preventDefault();
  } else {
    capturePaste$1(view, e);
  }
};
var Dragging$1 = function Dragging(slice11, move2) {
  this.slice = slice11;
  this.move = move2;
};
var dragCopyModifier$1 = result.mac ? "altKey" : "ctrlKey";
handlers$1.dragstart = function(view, e) {
  var mouseDown = view.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e.dataTransfer) {
    return;
  }
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords$1(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection$3 ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection$3.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) {
      view.dispatch(view.state.tr.setSelection(NodeSelection$3.create(view.state.doc, desc.posBefore)));
    }
  }
  var slice11 = view.state.selection.content();
  var ref2 = serializeForClipboard$1(view, slice11);
  var dom = ref2.dom;
  var text3 = ref2.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI$1 ? "Text" : "text/html", dom.innerHTML);
  e.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI$1) {
    e.dataTransfer.setData("text/plain", text3);
  }
  view.dragging = new Dragging$1(slice11, !e[dragCopyModifier$1]);
};
handlers$1.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging) {
      view.dragging = null;
    }
  }, 50);
};
editHandlers$1.dragover = editHandlers$1.dragenter = function(_, e) {
  return e.preventDefault();
};
editHandlers$1.drop = function(view, e) {
  var dragging = view.dragging;
  view.dragging = null;
  if (!e.dataTransfer) {
    return;
  }
  var eventPos = view.posAtCoords(eventCoords$1(e));
  if (!eventPos) {
    return;
  }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice11 = dragging && dragging.slice;
  if (slice11) {
    view.someProp("transformPasted", function(f) {
      slice11 = f(slice11);
    });
  } else {
    slice11 = parseFromClipboard$1(view, e.dataTransfer.getData(brokenClipboardAPI$1 ? "Text" : "text/plain"), brokenClipboardAPI$1 ? null : e.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move2 = dragging && !e[dragCopyModifier$1];
  if (view.someProp("handleDrop", function(f) {
    return f(view, e, slice11 || Slice$5.empty, move2);
  })) {
    e.preventDefault();
    return;
  }
  if (!slice11) {
    return;
  }
  e.preventDefault();
  var insertPos = slice11 ? dropPoint$1(view.state.doc, $mouse.pos, slice11) : $mouse.pos;
  if (insertPos == null) {
    insertPos = $mouse.pos;
  }
  var tr = view.state.tr;
  if (move2) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode = slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) {
    tr.replaceRangeWith(pos, pos, slice11.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice11);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection$3.isSelectable(slice11.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice11.content.firstChild)) {
    tr.setSelection(new NodeSelection$3($pos));
  } else {
    var end7 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return end7 = newTo;
    });
    tr.setSelection(selectionBetween$1(view, $pos, tr.doc.resolve(end7)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers$1.focus = function(view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
        selectionToDOM$1(view);
      }
    }, 20);
  }
};
handlers$1.blur = function(view, e) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e.relatedTarget && view.dom.contains(e.relatedTarget)) {
      view.domObserver.currentSelection.set({});
    }
    view.focused = false;
  }
};
handlers$1.beforeinput = function(view, event) {
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.domChangeCount;
    setTimeout(function() {
      if (view.domChangeCount != domChangeCount) {
        return;
      }
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent$1(8, "Backspace"));
      })) {
        return;
      }
      var ref2 = view.state.selection;
      var $cursor = ref2.$cursor;
      if ($cursor && $cursor.pos > 0) {
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }
    }, 50);
  }
};
for (var prop in editHandlers$1) {
  handlers$1[prop] = editHandlers$1[prop];
}
function compareObjs$1(a, b) {
  if (a == b) {
    return true;
  }
  for (var p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (var p$1 in b) {
    if (!(p$1 in a)) {
      return false;
    }
  }
  return true;
}
var WidgetType$1 = function WidgetType(toDOM, spec) {
  this.spec = spec || noSpec$1;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};
WidgetType$1.prototype.map = function map7(mapping, span, offset6, oldOffset) {
  var ref2 = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref2.pos;
  var deleted = ref2.deleted;
  return deleted ? null : new Decoration$1(pos - offset6, pos - offset6, this);
};
WidgetType$1.prototype.valid = function valid() {
  return true;
};
WidgetType$1.prototype.eq = function eq6(other) {
  return this == other || other instanceof WidgetType$1 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs$1(this.spec, other.spec));
};
WidgetType$1.prototype.destroy = function destroy2(node8) {
  if (this.spec.destroy) {
    this.spec.destroy(node8);
  }
};
var InlineType$1 = function InlineType(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
InlineType$1.prototype.map = function map8(mapping, span, offset6, oldOffset) {
  var from8 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset6;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset6;
  return from8 >= to ? null : new Decoration$1(from8, to, this);
};
InlineType$1.prototype.valid = function valid2(_, span) {
  return span.from < span.to;
};
InlineType$1.prototype.eq = function eq7(other) {
  return this == other || other instanceof InlineType$1 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
InlineType$1.is = function is(span) {
  return span.type instanceof InlineType$1;
};
var NodeType$5 = function NodeType2(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
NodeType$5.prototype.map = function map9(mapping, span, offset6, oldOffset) {
  var from8 = mapping.mapResult(span.from + oldOffset, 1);
  if (from8.deleted) {
    return null;
  }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from8.pos) {
    return null;
  }
  return new Decoration$1(from8.pos - offset6, to.pos - offset6, this);
};
NodeType$5.prototype.valid = function valid3(node8, span) {
  var ref2 = node8.content.findIndex(span.from);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11;
  return offset6 == span.from && !(child11 = node8.child(index6)).isText && offset6 + child11.nodeSize == span.to;
};
NodeType$5.prototype.eq = function eq8(other) {
  return this == other || other instanceof NodeType$5 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
var Decoration$1 = function Decoration(from8, to, type4) {
  this.from = from8;
  this.to = to;
  this.type = type4;
};
var prototypeAccessors$1$c = { spec: { configurable: true }, inline: { configurable: true } };
Decoration$1.prototype.copy = function copy3(from8, to) {
  return new Decoration$1(from8, to, this.type);
};
Decoration$1.prototype.eq = function eq9(other, offset6) {
  if (offset6 === void 0)
    offset6 = 0;
  return this.type.eq(other.type) && this.from + offset6 == other.from && this.to + offset6 == other.to;
};
Decoration$1.prototype.map = function map10(mapping, offset6, oldOffset) {
  return this.type.map(mapping, this, offset6, oldOffset);
};
Decoration$1.widget = function widget(pos, toDOM, spec) {
  return new Decoration$1(pos, pos, new WidgetType$1(toDOM, spec));
};
Decoration$1.inline = function inline(from8, to, attrs, spec) {
  return new Decoration$1(from8, to, new InlineType$1(attrs, spec));
};
Decoration$1.node = function node3(from8, to, attrs, spec) {
  return new Decoration$1(from8, to, new NodeType$5(attrs, spec));
};
prototypeAccessors$1$c.spec.get = function() {
  return this.type.spec;
};
prototypeAccessors$1$c.inline.get = function() {
  return this.type instanceof InlineType$1;
};
Object.defineProperties(Decoration$1.prototype, prototypeAccessors$1$c);
var none$1 = [], noSpec$1 = {};
var DecorationSet$1 = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none$1;
  this.children = children && children.length ? children : none$1;
};
DecorationSet$1.create = function create4(doc2, decorations) {
  return decorations.length ? buildTree$1(decorations, doc2, 0, noSpec$1) : empty$1;
};
DecorationSet$1.prototype.find = function find(start8, end7, predicate) {
  var result2 = [];
  this.findInner(start8 == null ? 0 : start8, end7 == null ? 1e9 : end7, result2, 0, predicate);
  return result2;
};
DecorationSet$1.prototype.findInner = function findInner(start8, end7, result2, offset6, predicate) {
  for (var i = 0; i < this.local.length; i++) {
    var span = this.local[i];
    if (span.from <= end7 && span.to >= start8 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset6, span.to + offset6));
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end7 && this.children[i$1 + 1] > start8) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start8 - childOff, end7 - childOff, result2, offset6 + childOff, predicate);
    }
  }
};
DecorationSet$1.prototype.map = function map11(mapping, doc2, options) {
  if (this == empty$1 || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec$1);
};
DecorationSet$1.prototype.mapInner = function mapInner(mapping, node8, offset6, oldOffset, options) {
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this.local[i].map(mapping, offset6, oldOffset);
    if (mapped && mapped.type.valid(node8, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this.local[i].spec);
    }
  }
  if (this.children.length) {
    return mapChildren$1(this.children, newLocal, mapping, node8, offset6, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet$1(newLocal.sort(byPos$1)) : empty$1;
  }
};
DecorationSet$1.prototype.add = function add(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty$1) {
    return DecorationSet$1.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet$1.prototype.addInner = function addInner(doc2, decorations, offset6) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset6, found2;
    if (!(found2 = takeSpansForNode$1(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree$1(found2, childNode, baseOffset + 1, noSpec$1));
    }
    childIndex += 3;
  });
  var local = moveSpans$1(childIndex ? withoutNulls$1(decorations) : decorations, -offset6);
  for (var i = 0; i < local.length; i++) {
    if (!local[i].type.valid(doc2, local[i])) {
      local.splice(i--, 1);
    }
  }
  return new DecorationSet$1(local.length ? this.local.concat(local).sort(byPos$1) : this.local, children || this.children);
};
DecorationSet$1.prototype.remove = function remove(decorations) {
  if (decorations.length == 0 || this == empty$1) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet$1.prototype.removeInner = function removeInner(decorations, offset6) {
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found2 = void 0, from8 = children[i] + offset6, to = children[i + 1] + offset6;
    for (var j = 0, span = void 0; j < decorations.length; j++) {
      if (span = decorations[j]) {
        if (span.from > from8 && span.to < to) {
          decorations[j] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this.children) {
      children = this.children.slice();
    }
    var removed = children[i + 2].removeInner(found2, from8 + 1);
    if (removed != empty$1) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) {
    for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
      if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].eq(span$1, offset6)) {
            if (local == this.local) {
              local = this.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet$1(local, children) : empty$1;
};
DecorationSet$1.prototype.forChild = function forChild(offset6, node8) {
  if (this == empty$1) {
    return this;
  }
  if (node8.isLeaf) {
    return DecorationSet$1.empty;
  }
  var child11, local;
  for (var i = 0; i < this.children.length; i += 3) {
    if (this.children[i] >= offset6) {
      if (this.children[i] == offset6) {
        child11 = this.children[i + 2];
      }
      break;
    }
  }
  var start8 = offset6 + 1, end7 = start8 + node8.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end7 && dec.to > start8 && dec.type instanceof InlineType$1) {
      var from8 = Math.max(start8, dec.from) - start8, to = Math.min(end7, dec.to) - start8;
      if (from8 < to) {
        (local || (local = [])).push(dec.copy(from8, to));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet$1(local.sort(byPos$1));
    return child11 ? new DecorationGroup$1([localSet, child11]) : localSet;
  }
  return child11 || empty$1;
};
DecorationSet$1.prototype.eq = function eq10(other) {
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet$1) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i = 0; i < this.local.length; i++) {
    if (!this.local[i].eq(other.local[i])) {
      return false;
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
      return false;
    }
  }
  return true;
};
DecorationSet$1.prototype.locals = function locals(node8) {
  return removeOverlap$1(this.localsInner(node8));
};
DecorationSet$1.prototype.localsInner = function localsInner(node8) {
  if (this == empty$1) {
    return none$1;
  }
  if (node8.inlineContent || !this.local.some(InlineType$1.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this.local[i].type instanceof InlineType$1)) {
      result2.push(this.local[i]);
    }
  }
  return result2;
};
var empty$1 = new DecorationSet$1();
DecorationSet$1.empty = empty$1;
DecorationSet$1.removeOverlap = removeOverlap$1;
var DecorationGroup$1 = function DecorationGroup(members) {
  this.members = members;
};
DecorationGroup$1.prototype.map = function map12(mapping, doc2) {
  var mappedDecos = this.members.map(function(member) {
    return member.map(mapping, doc2, noSpec$1);
  });
  return DecorationGroup$1.from(mappedDecos);
};
DecorationGroup$1.prototype.forChild = function forChild2(offset6, child11) {
  if (child11.isLeaf) {
    return DecorationSet$1.empty;
  }
  var found2 = [];
  for (var i = 0; i < this.members.length; i++) {
    var result2 = this.members[i].forChild(offset6, child11);
    if (result2 == empty$1) {
      continue;
    }
    if (result2 instanceof DecorationGroup$1) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup$1.from(found2);
};
DecorationGroup$1.prototype.eq = function eq11(other) {
  if (!(other instanceof DecorationGroup$1) || other.members.length != this.members.length) {
    return false;
  }
  for (var i = 0; i < this.members.length; i++) {
    if (!this.members[i].eq(other.members[i])) {
      return false;
    }
  }
  return true;
};
DecorationGroup$1.prototype.locals = function locals2(node8) {
  var result2, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals3 = this.members[i].localsInner(node8);
    if (!locals3.length) {
      continue;
    }
    if (!result2) {
      result2 = locals3;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j = 0; j < locals3.length; j++) {
        result2.push(locals3[j]);
      }
    }
  }
  return result2 ? removeOverlap$1(sorted ? result2 : result2.sort(byPos$1)) : none$1;
};
DecorationGroup$1.from = function from2(members) {
  switch (members.length) {
    case 0:
      return empty$1;
    case 1:
      return members[0];
    default:
      return new DecorationGroup$1(members);
  }
};
function mapChildren$1(oldChildren, newLocal, mapping, node8, offset6, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i2 = 0; i2 < children.length; i2 += 3) {
      var end7 = children[i2 + 1], dSize = void 0;
      if (end7 == -1 || oldStart > end7 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i2] + oldOffset) {
        children[i2 + 1] = -1;
      } else if (newStart >= offset6 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i2] += dSize;
        children[i2 + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from8 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from8 - offset6;
      if (fromLocal < 0 || fromLocal >= node8.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset6;
      var ref2 = node8.content.findIndex(fromLocal);
      var index6 = ref2.index;
      var childOffset = ref2.offset;
      var childNode = node8.maybeChild(index6);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from8 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty$1) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations$1(children, oldChildren, newLocal || [], mapping, offset6, oldOffset, options);
    var built = buildTree$1(decorations, node8, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet$1(newLocal && newLocal.sort(byPos$1), children);
}
function moveSpans$1(spans, offset6) {
  if (!offset6 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result2.push(new Decoration$1(span.from + offset6, span.to + offset6, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations$1(children, oldChildren, decorations, mapping, offset6, oldOffset, options) {
  function gather(set3, oldOffset2) {
    for (var i2 = 0; i2 < set3.local.length; i2++) {
      var mapped = set3.local[i2].map(mapping, offset6, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set3.local[i2].spec);
      }
    }
    for (var i$1 = 0; i$1 < set3.children.length; i$1 += 3) {
      gather(set3.children[i$1 + 2], set3.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) {
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode$1(spans, node8, offset6) {
  if (node8.isLeaf) {
    return null;
  }
  var end7 = offset6 + node8.nodeSize, found2 = null;
  for (var i = 0, span = void 0; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset6 && span.to < end7) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls$1(array4) {
  var result2 = [];
  for (var i = 0; i < array4.length; i++) {
    if (array4[i] != null) {
      result2.push(array4[i]);
    }
  }
  return result2;
}
function buildTree$1(spans, node8, offset6, options) {
  var children = [], hasNulls = false;
  node8.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode$1(spans, childNode, localStart + offset6);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree$1(found2, childNode, offset6 + localStart + 1, options);
      if (subtree != empty$1) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals3 = moveSpans$1(hasNulls ? withoutNulls$1(spans) : spans, -offset6).sort(byPos$1);
  for (var i = 0; i < locals3.length; i++) {
    if (!locals3[i].type.valid(node8, locals3[i])) {
      if (options.onRemove) {
        options.onRemove(locals3[i].spec);
      }
      locals3.splice(i--, 1);
    }
  }
  return locals3.length || children.length ? new DecorationSet$1(locals3, children) : empty$1;
}
function byPos$1(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap$1(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) {
      for (var j = i + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next.copy(next.from, span.to);
            insertAhead$1(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i] = span.copy(span.from, next.from);
            insertAhead$1(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead$1(array4, i, deco) {
  while (i < array4.length && byPos$1(deco, array4[i]) > 0) {
    i++;
  }
  array4.splice(i, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f) {
    var result2 = f(view.state);
    if (result2 && result2 != empty$1) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet$1.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup$1.from(found2);
}
var EditorView = function EditorView2(place, props) {
  this._props = props;
  this.state = props.state;
  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.trackWrites = null;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput(this);
  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$2$4 = { props: { configurable: true }, root: { configurable: true }, isDestroyed: { configurable: true } };
prototypeAccessors$2$4.props.get = function() {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) {
      this._props[name] = prev[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView.prototype.update = function update(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners(this);
  }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};
EditorView.prototype.setProps = function setProps(props) {
  var updated = {};
  for (var name in this._props) {
    updated[name] = this._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView.prototype.updateState = function updateState(state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};
EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
  var this$1$1 = this;
  var prev = this.state, redraw = false, updateSel = false;
  if (state.storedMarks && this.composing) {
    clearComposition$1(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }
  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
  var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) {
    updateSel = true;
  }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
  if (updateSel) {
    this.domObserver.stop();
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) {
        forceSelUpdate = true;
      }
    }
    if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM$1(this, forceSelUpdate);
    } else {
      syncNodeSelection$1(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }
  this.updatePluginViews(prev);
  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function(f) {
      return f(this$1$1);
    }))
      ;
    else if (state.selection instanceof NodeSelection$3) {
      scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
    }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};
EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
  var view;
  while (view = this.pluginViews.pop()) {
    if (view.destroy) {
      view.destroy();
    }
  }
};
EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i = 0; i < this.directPlugins.length; i++) {
      var plugin = this.directPlugins[i];
      if (plugin.spec.view) {
        this.pluginViews.push(plugin.spec.view(this));
      }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) {
        this.pluginViews.push(plugin$1.spec.view(this));
      }
    }
  } else {
    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
      var pluginView = this.pluginViews[i$2];
      if (pluginView.update) {
        pluginView.update(this, prevState);
      }
    }
  }
};
EditorView.prototype.someProp = function someProp(propName, f) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f ? f(prop) : prop)) {
    return value;
  }
  for (var i = 0; i < this.directPlugins.length; i++) {
    var prop$1 = this.directPlugins[i].props[propName];
    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
      return value;
    }
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i$1 = 0; i$1 < plugins.length; i$1++) {
      var prop$2 = plugins[i$1].props[propName];
      if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) {
        return value;
      }
    }
  }
};
EditorView.prototype.hasFocus = function hasFocus() {
  return this.root.activeElement == this.dom;
};
EditorView.prototype.focus = function focus() {
  this.domObserver.stop();
  if (this.editable) {
    focusPreventScroll(this.dom);
  }
  selectionToDOM$1(this);
  this.domObserver.start();
};
prototypeAccessors$2$4.root.get = function() {
  var cached = this._root;
  if (cached == null) {
    for (var search = this.dom.parentNode; search; search = search.parentNode) {
      if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
        if (!search.getSelection) {
          Object.getPrototypeOf(search).getSelection = function() {
            return document.getSelection();
          };
        }
        return this._root = search;
      }
    }
  }
  return cached || document;
};
EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
  return posAtCoords(this, coords);
};
EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
  if (side === void 0)
    side = 1;
  return coordsAtPos(this, pos, side);
};
EditorView.prototype.domAtPos = function domAtPos(pos, side) {
  if (side === void 0)
    side = 0;
  return this.docView.domFromPos(pos, side);
};
EditorView.prototype.nodeDOM = function nodeDOM(pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null;
};
EditorView.prototype.posAtDOM = function posAtDOM(node8, offset6, bias) {
  if (bias === void 0)
    bias = -1;
  var pos = this.docView.posFromDOM(node8, offset6, bias);
  if (pos == null) {
    throw new RangeError("DOM position not inside the editor");
  }
  return pos;
};
EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
  return endOfTextblock(this, state || this.state, dir);
};
EditorView.prototype.destroy = function destroy3() {
  if (!this.docView) {
    return;
  }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
prototypeAccessors$2$4.isDestroyed.get = function() {
  return this.docView == null;
};
EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
  return dispatchEvent(this, event);
};
EditorView.prototype.dispatch = function dispatch(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction.call(this, tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView.prototype, prototypeAccessors$2$4);
function computeDocDeco(view) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        }
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration$1.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration$1.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop in a) {
    if (a[prop] != b[prop]) {
      return true;
    }
    nA++;
  }
  for (var _ in b) {
    nB++;
  }
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) {
    throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
}
var base$1 = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari$1 = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko$1 = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$3 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome$1 && (mac$3 || +chrome$1[1] < 57) || gecko$1 && mac$3;
for (var i = 0; i < 10; i++)
  base$1[48 + i] = base$1[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base$1[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base$1[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code$2 in base$1)
  if (!shift.hasOwnProperty(code$2))
    shift[code$2] = base$1[code$2];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari$1 || ie$1) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base$1)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var mac$2 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$2(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac$2) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize$1(map30) {
  var copy12 = /* @__PURE__ */ Object.create(null);
  for (var prop in map30) {
    copy12[normalizeKeyName$2(prop)] = map30[prop];
  }
  return copy12;
}
function modifiers$1(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap(bindings) {
  return new Plugin$1({ props: { handleKeyDown: keydownHandler$1(bindings) } });
}
function keydownHandler$1(bindings) {
  var map30 = normalize$1(bindings);
  return function(view, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map30[modifiers$1(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base$1[event.keyCode]) && baseName != name) {
      var fromCode = map30[modifiers$1(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) {
        return true;
      }
    } else if (isChar && event.shiftKey) {
      var withShift = map30[modifiers$1(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) {
        return true;
      }
    }
    return false;
  };
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key2) => {
      if (isPlainObject(source[key2])) {
        if (!(key2 in target)) {
          Object.assign(output, { [key2]: source[key2] });
        } else {
          output[key2] = mergeDeep(target[key2], source[key2]);
        }
      } else {
        Object.assign(output, { [key2]: source[key2] });
      }
    });
  }
  return output;
}
function isFunction$2(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction$2(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range3, options) {
  const { from: from8, to } = range3;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text3 = "";
  let separated = true;
  startNode.nodesBetween(from8, to, (node8, pos, parent, index6) => {
    var _a2;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node8.type.name];
    if (textSerializer) {
      if (node8.isBlock && !separated) {
        text3 += blockSeparator;
        separated = true;
      }
      text3 += textSerializer({
        node: node8,
        pos,
        parent,
        index: index6
      });
    } else if (node8.isText) {
      text3 += (_a2 = node8 === null || node8 === void 0 ? void 0 : node8.text) === null || _a2 === void 0 ? void 0 : _a2.slice(Math.max(from8, pos) - pos, to - pos);
      separated = false;
    } else if (node8.isBlock && !separated) {
      text3 += blockSeparator;
      separated = true;
    }
  });
  return text3;
}
function getTextSeralizersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node8]) => node8.spec.toText).map(([name, node8]) => [name, node8.spec.toText]));
}
const ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from8 = Math.min(...ranges.map((range4) => range4.$from.pos));
            const to = Math.max(...ranges.map((range4) => range4.$to.pos));
            const textSerializers = getTextSeralizersFromSchema(schema);
            const range3 = { from: from8, to };
            return getTextBetween(doc2, range3, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a2 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
var blur$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur
});
const clearContent = (emitUpdate = false) => ({ commands }) => {
  return commands.setContent("", emitUpdate);
};
var clearContent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clearContent
});
const clearNodes = () => ({ state, tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node8, pos) => {
      if (node8.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node8.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node8.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var clearNodes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clearNodes
});
const command = (fn3) => (props) => {
  return fn3(props);
};
var command$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  command
});
const createParagraphNear = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$2(state, dispatch2);
};
var createParagraphNear$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createParagraphNear
});
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
const deleteNode = (typeOrName) => ({ tr, state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node8 = $pos.node(depth);
    if (node8.type === type4) {
      if (dispatch2) {
        const from8 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from8, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteNode
});
const deleteRange$1 = (range3) => ({ tr, dispatch: dispatch2 }) => {
  const { from: from8, to } = range3;
  if (dispatch2) {
    tr.delete(from8, to);
  }
  return true;
};
var deleteRange$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteRange: deleteRange$1
});
const deleteSelection = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$2(state, dispatch2);
};
var deleteSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  deleteSelection
});
const enter2 = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var enter$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  enter: enter2
});
const exitCode = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$2(state, dispatch2);
};
var exitCode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  exitCode
});
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object22, options = { strict: true }) {
  const keys2 = Object.keys(object22);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key2) => {
    if (options.strict) {
      return object22[key2] === object1[key2];
    }
    if (isRegExp(object22[key2])) {
      return object22[key2].test(object1[key2]);
    }
    return object22[key2] === object1[key2];
  });
}
function findMarkInSet(marks6, type4, attributes = {}) {
  return marks6.find((item) => {
    return item.type === type4 && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks6, type4, attributes = {}) {
  return !!findMarkInSet(marks6, type4, attributes);
}
function getMarkRange($pos, type4, attributes = {}) {
  if (!$pos || !type4) {
    return;
  }
  const start8 = $pos.parent.childAfter($pos.parentOffset);
  if (!start8.node) {
    return;
  }
  const mark7 = findMarkInSet(start8.node.marks, type4, attributes);
  if (!mark7) {
    return;
  }
  let startIndex2 = $pos.index();
  let startPos = $pos.start() + start8.offset;
  let endIndex2 = startIndex2 + 1;
  let endPos = startPos + start8.node.nodeSize;
  findMarkInSet(start8.node.marks, type4, attributes);
  while (startIndex2 > 0 && mark7.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex2).marks, type4, attributes)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  const type4 = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr;
  const { $from, from: from8, to } = selection;
  if (dispatch2) {
    const range3 = getMarkRange($from, type4, attributes);
    if (range3 && range3.from <= from8 && range3.to >= to) {
      const newSelection = TextSelection$3.create(doc2, range3.from, range3.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var extendMarkRange$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  extendMarkRange
});
const first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
var first$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  first
});
function isClass(value) {
  var _a2;
  if (((_a2 = value.constructor) === null || _a2 === void 0 ? void 0 : _a2.toString().substring(0, 5)) !== "class") {
    return false;
  }
  return true;
}
function isObject$2(value) {
  return value && typeof value === "object" && !Array.isArray(value) && !isClass(value);
}
function isTextSelection(value) {
  return isObject$2(value) && value instanceof TextSelection$3;
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function minMax(value = 0, min7 = 0, max7 = 0) {
  return Math.min(Math.max(value, min7), max7);
}
function resolveFocusPosition(doc2, position = null) {
  if (!position) {
    return null;
  }
  if (position === "start" || position === true) {
    return Selection$3.atStart(doc2);
  }
  if (position === "end") {
    return Selection$3.atEnd(doc2);
  }
  if (position === "all") {
    return TextSelection$3.create(doc2, 0, doc2.content.size);
  }
  const minPos = Selection$3.atStart(doc2).from;
  const maxPos = Selection$3.atEnd(doc2).to;
  const resolvedFrom = minMax(position, minPos, maxPos);
  const resolvedEnd = minMax(position, minPos, maxPos);
  return TextSelection$3.create(doc2, resolvedFrom, resolvedEnd);
}
const focus2 = (position = null, options) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(editor.state.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var focus$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  focus: focus2
});
const forEach4 = (items, fn3) => (props) => {
  return items.every((item, index6) => fn3(item, { ...props, index: index6 }));
};
var forEach$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  forEach: forEach4
});
const insertContent = (value, options) => ({ tr, commands }) => {
  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
var insertContent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  insertContent
});
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content4, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  if (typeof content4 === "object" && content4 !== null) {
    try {
      if (Array.isArray(content4)) {
        return Fragment$5.fromArray(content4.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content4);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content4, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content4 === "string") {
    const parser = DOMParser$1.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content4), options.parseOptions).content : parser.parse(elementFromString(content4), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd$3(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step5 = tr.steps[last];
  if (!(step5 instanceof ReplaceStep$4 || step5 instanceof ReplaceAroundStep$4)) {
    return;
  }
  const map30 = tr.mapping.maps[last];
  let end7 = 0;
  map30.forEach((_from, _to, _newFrom, newTo) => {
    if (end7 === 0) {
      end7 = newTo;
    }
  });
  tr.setSelection(Selection$3.near(tr.doc.resolve(end7), bias));
}
const isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
const insertContentAt = (position, value, options) => ({ tr, dispatch: dispatch2, editor }) => {
  if (dispatch2) {
    options = {
      parseOptions: {},
      updateSelection: true,
      ...options
    };
    const content4 = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content4.toString() === "<>") {
      return true;
    }
    let { from: from8, to } = typeof position === "number" ? { from: position, to: position } : position;
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content4) ? content4 : [content4];
    nodes.forEach((node8) => {
      node8.check();
      isOnlyTextContent = isOnlyTextContent ? node8.isText && node8.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node8.isBlock : false;
    });
    if (from8 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from8);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from8 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      tr.insertText(value, from8, to);
    } else {
      tr.replaceWith(from8, to, content4);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd$3(tr, tr.steps.length - 1, -1);
    }
  }
  return true;
};
var insertContentAt$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  insertContentAt
});
const joinBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$2(state, dispatch2);
};
var joinBackward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  joinBackward
});
const joinForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$2(state, dispatch2);
};
var joinForward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  joinForward
});
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName$1(name) {
  const parts = name.split(/-(?!$)/);
  let result2 = parts[parts.length - 1];
  if (result2 === "Space") {
    result2 = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result2 = `Alt-${result2}`;
  }
  if (ctrl) {
    result2 = `Ctrl-${result2}`;
  }
  if (meta) {
    result2 = `Meta-${result2}`;
  }
  if (shift2) {
    result2 = `Shift-${result2}`;
  }
  return result2;
}
const keyboardShortcut = (name) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName$1(name).split(/-(?!$)/);
  const key2 = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key2 === "Space" ? " " : key2,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step5) => {
    const newStep = step5.map(tr.mapping);
    if (newStep && dispatch2) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
var keyboardShortcut$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  keyboardShortcut
});
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from8, to, empty: empty2 } = state.selection;
  const type4 = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from8, to, (node8, pos) => {
    if (node8.isText) {
      return;
    }
    const relativeFrom = Math.max(from8, pos);
    const relativeTo = Math.min(to, pos + node8.nodeSize);
    nodeRanges.push({
      node: node8,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from8;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type4) {
      return true;
    }
    return type4.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range3 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range3 >= selectionRange;
}
const lift$1 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type4, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$2(state, dispatch2);
};
var lift$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  lift: lift$1
});
const liftEmptyBlock = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$2(state, dispatch2);
};
var liftEmptyBlock$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  liftEmptyBlock
});
const liftListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  return liftListItem$2(type4)(state, dispatch2);
};
var liftListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  liftListItem
});
const newlineInCode = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$2(state, dispatch2);
};
var newlineInCode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  newlineInCode
});
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch: dispatch2 }) => {
  let nodeType2 = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType2 = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range3) => {
      state.doc.nodesBetween(range3.$from.pos, range3.$to.pos, (node8, pos) => {
        if (nodeType2 && nodeType2 === node8.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node8.attrs, attributes));
        }
        if (markType && node8.marks.length) {
          node8.marks.forEach((mark7) => {
            if (markType === mark7.type) {
              tr.addMark(pos, pos + node8.nodeSize, markType.create(deleteProps(mark7.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var resetAttributes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  resetAttributes
});
const scrollIntoView = () => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr.scrollIntoView();
  }
  return true;
};
var scrollIntoView$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  scrollIntoView
});
const selectAll$2 = () => ({ tr, commands }) => {
  return commands.setTextSelection({
    from: 0,
    to: tr.doc.content.size
  });
};
var selectAll$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectAll: selectAll$2
});
const selectNodeBackward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$2(state, dispatch2);
};
var selectNodeBackward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectNodeBackward
});
const selectNodeForward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$2(state, dispatch2);
};
var selectNodeForward$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectNodeForward
});
const selectParentNode = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$2(state, dispatch2);
};
var selectParentNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectParentNode
});
const selectTextblockEnd = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$2(state, dispatch2);
};
var selectTextblockEnd$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectTextblockEnd
});
const selectTextblockStart = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$2(state, dispatch2);
};
var selectTextblockStart$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  selectTextblockStart
});
function createDocument(content4, schema, parseOptions = {}) {
  return createNodeFromContent(content4, schema, { slice: false, parseOptions });
}
const setContent$1 = (content4, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch: dispatch2 }) => {
  const { doc: doc2 } = tr;
  const document2 = createDocument(content4, editor.schema, parseOptions);
  const selection = TextSelection$3.create(doc2, 0, doc2.content.size);
  if (dispatch2) {
    tr.setSelection(selection).replaceSelectionWith(document2, false).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
var setContent$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setContent: setContent$1
});
function getMarkAttributes(state, typeOrName) {
  const type4 = getMarkType(typeOrName, state.schema);
  const { from: from8, to, empty: empty2 } = state.selection;
  const marks6 = [];
  if (empty2) {
    if (state.storedMarks) {
      marks6.push(...state.storedMarks);
    }
    marks6.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from8, to, (node8) => {
      marks6.push(...node8.marks);
    });
  }
  const mark7 = marks6.find((markItem) => markItem.type.name === type4.name);
  if (!mark7) {
    return {};
  }
  return { ...mark7.attrs };
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type4 = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type4);
      tr.addStoredMark(type4.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range3) => {
        const from8 = range3.$from.pos;
        const to = range3.$to.pos;
        state.doc.nodesBetween(from8, to, (node8, pos) => {
          const trimmedFrom = Math.max(pos, from8);
          const trimmedTo = Math.min(pos + node8.nodeSize, to);
          const someHasMark = node8.marks.find((mark7) => mark7.type === type4);
          if (someHasMark) {
            node8.marks.forEach((mark7) => {
              if (type4 === mark7.type) {
                tr.addMark(trimmedFrom, trimmedTo, type4.create({
                  ...mark7.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type4.create(attributes));
          }
        });
      });
    }
  }
  return true;
};
var setMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setMark
});
const setMeta = (key2, value) => ({ tr }) => {
  tr.setMeta(key2, value);
  return true;
};
var setMeta$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setMeta
});
const setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  if (!type4.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands }) => {
    const canSetBlock = setBlockType$1(type4, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType$1(type4, attributes)(updatedState, dispatch2);
  }).run();
};
var setNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setNode
});
const setNodeSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const minPos = Selection$3.atStart(doc2).from;
    const maxPos = Selection$3.atEnd(doc2).to;
    const resolvedPos = minMax(position, minPos, maxPos);
    const selection = NodeSelection$3.create(doc2, resolvedPos);
    tr.setSelection(selection);
  }
  return true;
};
var setNodeSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setNodeSelection
});
const setTextSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const { from: from8, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = 0;
    const maxPos = tr.doc.content.size;
    const resolvedFrom = minMax(from8, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection$3.create(doc2, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setTextSelection
});
const sinkListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  return sinkListItem$2(type4)(state, dispatch2);
};
var sinkListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sinkListItem
});
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type: type4 } = match.edge(i);
    if (type4.isTextblock && !type4.hasRequiredAttrs()) {
      return type4;
    }
  }
  return null;
}
function ensureMarks(state, splittableMarks) {
  const marks6 = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks6) {
    const filteredMarks = marks6.filter((mark7) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark7.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection$3 && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    const atEnd4 = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection$3) {
      tr.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types2 = atEnd4 && deflt ? [{
      type: deflt,
      attrs: newAttributes
    }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types2);
    if (!types2 && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types2 = deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types2);
      if (deflt && !atEnd4 && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return true;
};
var splitBlock$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  splitBlock
});
const splitListItem = (typeOrName) => ({ tr, state, dispatch: dispatch2, editor }) => {
  var _a2;
  const type4 = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node8 = state.selection.node;
  if (node8 && node8.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type4) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type4 || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment$5.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment$5.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a2 = type4.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment$5.from(type4.createAndFill(null, nextType2) || void 0));
      const start8 = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start8, $from.after(-depthAfter), new Slice$5(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start8, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection$3.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr.delete($from.pos, $to.pos);
  const types2 = nextType ? [{ type: type4, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type: type4, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    tr.split($from.pos, 2, types2).scrollIntoView();
  }
  return true;
};
var splitListItem$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  splitListItem
});
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node8 = $pos.node(i);
    if (predicate(node8)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node: node8
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
const joinListBackwards = (tr, listType) => {
  const list = findParentNode((node8) => node8.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before6 = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before6 === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before6);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
const joinListForwards = (tr, listType) => {
  const list = findParentNode((node8) => node8.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after6 = tr.doc.resolve(list.start).after(list.depth);
  if (after6 === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after6);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after6);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after6);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch: dispatch2, chain, commands, can }) => {
  const { extensions: extensions2 } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection } = state;
  const { $from, $to } = selection;
  const range3 = $from.blockRange($to);
  if (!range3) {
    return false;
  }
  const parentList = findParentNode((node8) => isList(node8.type.name, extensions2))(selection);
  if (range3.depth >= 1 && parentList && range3.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleList$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleList
});
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type4 = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark7) => {
      if (!type4) {
        return true;
      }
      return type4.name === mark7.type.name;
    }).find((mark7) => objectIncludes(mark7.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from8 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from8, to, (node8, pos) => {
      if (!node8.isText && !node8.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from8, pos);
      const relativeTo = Math.min(to, pos + node8.nodeSize);
      const range4 = relativeTo - relativeFrom;
      selectionRange += range4;
      markRanges.push(...node8.marks.map((mark7) => ({
        mark: mark7,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type4) {
      return true;
    }
    return type4.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type4) {
      return true;
    }
    return markRange.mark.type !== type4 && markRange.mark.type.excludes(type4);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range3 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range3 >= selectionRange;
}
const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type4 = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type4, attributes);
  if (isActive2) {
    return commands.unsetMark(type4, { extendEmptyMarkRange });
  }
  return commands.setMark(type4, attributes);
};
var toggleMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleMark
});
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type4, attributes);
  if (isActive2) {
    return commands.setNode(toggleType);
  }
  return commands.setNode(type4, attributes);
};
var toggleNode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleNode
});
const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type4, attributes);
  if (isActive2) {
    return commands.lift(type4);
  }
  return commands.wrapIn(type4, attributes);
};
var toggleWrap$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toggleWrap
});
const undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks6 = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks6));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var undoInputRule$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  undoInputRule
});
const unsetAllMarks = () => ({ tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range3) => {
      tr.removeMark(range3.$from.pos, range3.$to.pos);
    });
  }
  return true;
};
var unsetAllMarks$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unsetAllMarks
});
const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type4 = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from8, to } = selection;
    const attrs = (_a2 = $from.marks().find((mark7) => mark7.type === type4)) === null || _a2 === void 0 ? void 0 : _a2.attrs;
    const range3 = getMarkRange($from, type4, attrs);
    if (range3) {
      from8 = range3.from;
      to = range3.to;
    }
    tr.removeMark(from8, to, type4);
  } else {
    ranges.forEach((range3) => {
      tr.removeMark(range3.$from.pos, range3.$to.pos, type4);
    });
  }
  tr.removeStoredMark(type4);
  return true;
};
var unsetMark$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unsetMark
});
const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
  let nodeType2 = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType2 = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range3) => {
      const from8 = range3.$from.pos;
      const to = range3.$to.pos;
      state.doc.nodesBetween(from8, to, (node8, pos) => {
        if (nodeType2 && nodeType2 === node8.type) {
          tr.setNodeMarkup(pos, void 0, {
            ...node8.attrs,
            ...attributes
          });
        }
        if (markType && node8.marks.length) {
          node8.marks.forEach((mark7) => {
            if (markType === mark7.type) {
              const trimmedFrom = Math.max(pos, from8);
              const trimmedTo = Math.min(pos + node8.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark7.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
var updateAttributes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  updateAttributes
});
const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  return wrapIn$2(type4, attributes)(state, dispatch2);
};
var wrapIn$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  wrapIn
});
const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type4 = getNodeType(typeOrName, state.schema);
  return wrapInList$2(type4, attributes)(state, dispatch2);
};
var wrapInList$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  wrapInList
});
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...blur$1,
      ...clearContent$1,
      ...clearNodes$1,
      ...command$1,
      ...createParagraphNear$1,
      ...deleteNode$1,
      ...deleteRange$1$1,
      ...deleteSelection$1,
      ...enter$1,
      ...exitCode$1,
      ...extendMarkRange$1,
      ...first$1,
      ...focus$1,
      ...forEach$1,
      ...insertContent$1,
      ...insertContentAt$1,
      ...joinBackward$1,
      ...joinForward$1,
      ...keyboardShortcut$1,
      ...lift$1$1,
      ...liftEmptyBlock$1,
      ...liftListItem$1,
      ...newlineInCode$1,
      ...resetAttributes$1,
      ...scrollIntoView$1,
      ...selectAll$1$1,
      ...selectNodeBackward$1,
      ...selectNodeForward$1,
      ...selectParentNode$1,
      ...selectTextblockEnd$1,
      ...selectTextblockStart$1,
      ...setContent$1$1,
      ...setMark$1,
      ...setMeta$1,
      ...setNode$1,
      ...setNodeSelection$1,
      ...setTextSelection$1,
      ...sinkListItem$1,
      ...splitBlock$1,
      ...splitListItem$1,
      ...toggleList$1,
      ...toggleMark$1,
      ...toggleNode$1,
      ...toggleWrap$1,
      ...undoInputRule$1,
      ...unsetAllMarks$1,
      ...unsetMark$1,
      ...updateAttributes$1,
      ...wrapIn$1,
      ...wrapInList$1
    };
  }
});
const Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin$1({
        key: new PluginKey$1("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    schema: state.schema,
    plugins: state.plugins,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method4 = (...args) => {
        const callback = command2(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method4];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = void 0;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch2);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: dispatch2 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch2)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    if (state.storedMarks) {
      tr.setStoredMarks(state.storedMarks);
    }
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
}
const Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      () => commands.command(({ tr }) => {
        const { selection, doc: doc2 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const isAtStart = Selection$3.atStart(doc2).from === pos;
        if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap,
      Home: () => this.editor.commands.selectTextblockStart(),
      End: () => this.editor.commands.selectTextblockEnd()
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty2, from: from8, to } = oldState.selection;
          const allFrom = Selection$3.atStart(oldState.doc).from;
          const allEnd = Selection$3.atEnd(oldState.doc).to;
          const allWasSelected = from8 === allFrom && to === allEnd;
          const isEmpty2 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (empty2 || !allWasSelected || !isEmpty2) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
const Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("tabindex"),
        props: {
          attributes: {
            tabindex: "0"
          }
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
function getNodeAttributes(state, typeOrName) {
  const type4 = getNodeType(typeOrName, state.schema);
  const { from: from8, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from8, to, (node9) => {
    nodes.push(node9);
  });
  const node8 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type4.name);
  if (!node8) {
    return {};
  }
  return { ...node8.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer$1.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText(node8, options) {
  const range3 = {
    from: 0,
    to: node8.content.size
  };
  return getTextBetween(node8, range3, options);
}
function isNodeEmpty(node8) {
  var _a2;
  const defaultContent = (_a2 = node8.type.createAndFill()) === null || _a2 === void 0 ? void 0 : _a2.toJSON();
  const content4 = node8.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content4);
}
function createStyleTag(style2) {
  const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
  if (tipTapStyleTag !== null) {
    return tipTapStyleTag;
  }
  const styleNode = document.createElement("style");
  styleNode.setAttribute("data-tiptap-style", "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text3, find3) => {
  if (isRegExp(find3)) {
    return find3.exec(text3);
  }
  const inputRuleMatch = find3(text3);
  if (!inputRuleMatch) {
    return null;
  }
  const result2 = [];
  result2.push(inputRuleMatch.text);
  result2.index = inputRuleMatch.index;
  result2.input = text3;
  result2.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result2.push(inputRuleMatch.replaceWith);
  }
  return result2;
};
function run$1$1(config) {
  var _a2;
  const { editor, from: from8, to, text: text3, rules: rules2, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from8);
  if ($from.parent.type.spec.code || !!((_a2 = $from.nodeBefore || $from.nodeAfter) === null || _a2 === void 0 ? void 0 : _a2.marks.find((mark7) => mark7.type.spec.code))) {
    return false;
  }
  let matched = false;
  const maxMatch = 500;
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, void 0, " ") + text3;
  rules2.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range3 = {
      from: from8 - (match[0].length - text3.length),
      to
    };
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range: range3,
      match,
      commands,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from: from8,
      to,
      text: text3
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules: rules2 } = props;
  const plugin = new Plugin$1({
    state: {
      init() {
        return null;
      },
      apply(tr, prev) {
        const stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from8, to, text3) {
        return run$1$1({
          editor,
          from: from8,
          to,
          text: text3,
          rules: rules2,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules: rules2,
                plugin
              });
            }
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules: rules2,
            plugin
          });
        }
        return false;
      }
    },
    isInputRules: true
  });
  return plugin;
}
function isNumber$1(value) {
  return typeof value === "number";
}
class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const pasteRuleMatcherHandler = (text3, find3) => {
  if (isRegExp(find3)) {
    return [...text3.matchAll(find3)];
  }
  const matches2 = find3(text3);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result2 = [];
    result2.push(pasteRuleMatch.text);
    result2.index = pasteRuleMatch.index;
    result2.input = text3;
    result2.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result2.push(pasteRuleMatch.replaceWith);
    }
    return result2;
  });
};
function run$2(config) {
  const { editor, state, from: from8, to, rule } = config;
  const { commands, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from8, to, (node8, pos) => {
    if (!node8.isTextblock || node8.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from8, pos);
    const resolvedTo = Math.min(to, pos + node8.content.size);
    const textToMatch = node8.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start8 = resolvedFrom + match.index + 1;
      const end7 = start8 + match[0].length;
      const range3 = {
        from: state.tr.mapping.map(start8),
        to: state.tr.mapping.map(end7)
      };
      const handler = rule.handler({
        state,
        range: range3,
        match,
        commands,
        chain,
        can
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props) {
  const { editor, rules: rules2 } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  const plugins = rules2.map((rule) => {
    return new Plugin$1({
      view(view) {
        const handleDragstart = (event) => {
          var _a2;
          dragSourceElement = ((_a2 = view.dom.parentElement) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            return false;
          },
          paste: (view, event) => {
            var _a2;
            const html = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/html");
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from8 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber$1(from8) || !to || from8 === to.b) {
          return;
        }
        const tr = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr
        });
        const handler = run$2({
          editor,
          state: chainableState,
          from: Math.max(from8 - 1, 0),
          to: to.b,
          rule
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        return tr;
      }
    });
  });
  return plugins;
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type4) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type: type4,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: {
          ...defaultAttribute,
          ...attribute
        }
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key2, value]) => {
      const exists = mergedAttributes[key2];
      if (!exists) {
        mergedAttributes[key2] = value;
        return;
      }
      if (key2 === "class") {
        mergedAttributes[key2] = [mergedAttributes[key2], value].join(" ");
      } else if (key2 === "style") {
        mergedAttributes[key2] = [mergedAttributes[key2], value].join("; ");
      } else {
        mergedAttributes[key2] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule2, extensionAttributes) {
  if (parseRule2.style) {
    return parseRule2;
  }
  return {
    ...parseRule2,
    getAttrs: (node8) => {
      const oldAttributes = parseRule2.getAttrs ? parseRule2.getAttrs(node8) : parseRule2.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node8) : fromString(node8.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(Object.entries(data).filter(([key2, value]) => {
    if (key2 === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  }));
}
function getSchemaByResolvedExtensions(extensions2) {
  var _a2;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a2 === void 0 ? void 0 : _a2.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraNodeFields = extensions2.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a3;
        return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node8) => renderHTML({
        node: node8,
        HTMLAttributes: getRenderedAttributes(node8, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks6 = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraMarkFields = extensions2.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a3;
        return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark7) => renderHTML({
        mark: mark7,
        HTMLAttributes: getRenderedAttributes(mark7, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema$1({
    topNode,
    nodes,
    marks: marks6
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index6) => items.indexOf(el) !== index6);
  return [...new Set(filtered)];
}
class ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions);
    this.extensions.forEach((extension) => {
      var _a2;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a2 !== void 0 ? _a2 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [
          extension,
          ...this.flatten(addExtensions())
        ];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method4]) => {
          return [shortcut, () => method4({ editor })];
        }));
        const keyMapPlugin = keymap(bindings);
        plugins.push(keyMapPlugin);
      }
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node8, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node8, extensionAttributes);
        return addNodeView()({
          editor,
          node: node8,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
}
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn3) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn3);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn3) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn3) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn3);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
class Editor$1 extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style);
    }
  }
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  setEditable(editable) {
    this.setOptions({ editable });
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction$2(handlePlugins) ? handlePlugins(plugin, this.state.plugins) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState$2.create({
        doc: doc2,
        selection
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    const dom = this.view.dom;
    dom.editor = this;
  }
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(fn3) {
    this.isCapturingTransaction = true;
    fn3();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  dispatchTransaction(transaction) {
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step5) => {
        var _a2;
        return (_a2 = this.capturedTransaction) === null || _a2 === void 0 ? void 0 : _a2.step(step5);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus3 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus3) {
      this.emit("focus", {
        editor: this,
        event: focus3.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...textSerializers,
        ...getTextSeralizersFromSchema(this.schema)
      }
    });
  }
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var _a2;
    return !((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.docView);
  }
}
class Node$4 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node$4(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node$4(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
class Mark$4 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark$4(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark$4(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
class NodeView {
  constructor(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...options
    };
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return null;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a2, _b, _c;
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? (_a2 = target.parentElement) === null || _a2 === void 0 ? void 0 : _a2.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      x = handleBox.x - domBox.x + event.offsetX;
      y = handleBox.y - domBox.y + event.offsetY;
    }
    (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y);
    const selection = NodeSelection$3.create(view.state.doc, this.getPos());
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a2;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target = event.target;
    const isInElement = this.dom.contains(target) && !((_a2 = this.contentDOM) === null || _a2 === void 0 ? void 0 : _a2.contains(target));
    if (!isInElement) {
      return false;
    }
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable2 = NodeSelection$3.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    const isDragEvent = event.type.startsWith("drag");
    if (!isDraggable && isSelectable2 && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", () => {
          this.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable2) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && isiOS() && this.editor.isFocused) {
      const changedNodes = [
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
      if (changedNodes.every((node8) => node8.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      const pos = this.getPos();
      tr.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
  deleteNode() {
    const from8 = this.getPos();
    const to = from8 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from8, to });
  }
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range3, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr } = state;
      const start8 = range3.from;
      let end7 = range3.to;
      if (match[1]) {
        const offset6 = match[0].lastIndexOf(match[1]);
        let matchStart = start8 + offset6;
        if (matchStart > end7) {
          matchStart = end7;
        } else {
          end7 = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr.insertText(lastChar, start8 + match[0].length - 1);
        tr.replaceWith(matchStart, end7, config.type.create(attributes));
      } else if (match[0]) {
        tr.replaceWith(start8, end7, config.type.create(attributes));
      }
    }
  });
}
function getMarksBetween(from8, to, doc2) {
  const marks6 = [];
  if (from8 === to) {
    doc2.resolve(from8).marks().forEach((mark7) => {
      const $pos = doc2.resolve(from8 - 1);
      const range3 = getMarkRange($pos, mark7.type);
      if (!range3) {
        return;
      }
      marks6.push({
        mark: mark7,
        ...range3
      });
    });
  } else {
    doc2.nodesBetween(from8, to, (node8, pos) => {
      marks6.push(...node8.marks.map((mark7) => ({
        from: pos,
        to: pos + node8.nodeSize,
        mark: mark7
      })));
    });
  }
  return marks6;
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range3, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range3.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range3.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range3.from, range3.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type4) => type4 === config.type && type4 !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range3.to) {
          tr.delete(textEnd, range3.to);
        }
        if (textStart > range3.from) {
          tr.delete(range3.from + startSpaces, textStart);
        }
        markEnd = range3.from + startSpaces + captureGroup.length;
        tr.addMark(range3.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range3, match }) => {
      const $start = state.doc.resolve(range3.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range3.from, range3.to).setBlockType(range3.from, range3.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range3, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr = state.tr.delete(range3.from, range3.to);
      const $start = tr.doc.resolve(range3.from);
      const blockRange6 = $start.blockRange();
      const wrapping = blockRange6 && findWrapping3(blockRange6, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange6, wrapping);
      const before6 = tr.doc.resolve(range3.from - 1).nodeBefore;
      if (before6 && before6.type === config.type && canJoin(tr.doc, range3.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before6))) {
        tr.join(range3.from - 1);
      }
    }
  });
}
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range: range3, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range3.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range3.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range3.from, range3.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type4) => type4 === config.type && type4 !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range3.to) {
          tr.delete(textEnd, range3.to);
        }
        if (textStart > range3.from) {
          tr.delete(range3.from + startSpaces, textStart);
        }
        markEnd = range3.from + startSpaces + captureGroup.length;
        tr.addMark(range3.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform$4(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step5) => {
      transform.step(step5);
    });
  });
  return transform;
}
function findChildrenInRange(node8, range3, predicate) {
  const nodesWithPos = [];
  node8.nodesBetween(range3.from, range3.to, (child11, pos) => {
    if (predicate(child11)) {
      nodesWithPos.push({
        node: child11,
        pos
      });
    }
  });
  return nodesWithPos;
}
function removeDuplicates(array4, by = JSON.stringify) {
  const seen = {};
  return array4.filter((item) => {
    const key2 = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index6) => {
    const rest = uniqueChanges.filter((_, i) => i !== index6);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index6) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from8, to } = steps[index6];
      if (from8 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from8, to });
    } else {
      stepMap.forEach((from8, to) => {
        ranges.push({ from: from8, to });
      });
    }
    ranges.forEach(({ from: from8, to }) => {
      const newStart = mapping.slice(index6).map(from8, -1);
      const newEnd = mapping.slice(index6).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function isNodeSelection(value) {
  return isObject$2(value) && value instanceof NodeSelection$3;
}
function posToDOMRect(view, from8, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from8, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start8 = view.coordsAtPos(resolvedFrom);
  const end7 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start8.top, end7.top);
  const bottom2 = Math.max(start8.bottom, end7.bottom);
  const left2 = Math.min(start8.left, end7.left);
  const right2 = Math.max(start8.right, end7.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start3 = "start";
var end2 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start3, placement + "-" + end2]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start3, placement + "-" + end2]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node8) {
  if (node8 == null) {
    return window;
  }
  if (node8.toString() !== "[object Window]") {
    var ownerDocument = node8.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node8;
}
function isElement$2(node8) {
  var OwnElement = getWindow(node8).Element;
  return node8 instanceof OwnElement || node8 instanceof Element;
}
function isHTMLElement(node8) {
  var OwnElement = getWindow(node8).HTMLElement;
  return node8 instanceof OwnElement || node8 instanceof HTMLElement;
}
function isShadowRoot(node8) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node8).ShadowRoot;
  return node8 instanceof OwnElement || node8 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child11) {
  var rootNode = child11.getRootNode && child11.getRootNode();
  if (parent.contains(child11)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child11;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$2(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max2(min$1, min2(value, max$1));
}
function withinMaxClamp(min7, value, max7) {
  var v = within(min7, value, max7);
  return v > max7 ? max7 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min7 = paddingObject[minProp];
  var max7 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset6 = within(min7, center, max7);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset6, _state$modifiersData$.centerOffset = offset6 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$2 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end2) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end2) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node8) {
  var win = getWindow(node8);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node8) {
  if (["html", "body", "#document"].indexOf(getNodeName(node8)) >= 0) {
    return node8.ownerDocument.body;
  }
  if (isHTMLElement(node8) && isScrollParent(node8)) {
    return node8;
  }
  return getScrollParent(getParentNode(node8));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$2(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start3:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end2:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset6 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset6[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start3;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check6) {
      return check6;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check6) {
            return check6;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset6) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset6 === "function" ? offset6(Object.assign({}, rects, {
    placement
  })) : offset6, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset2(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset6 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset6);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset2
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset6 = popperOffsets2[mainAxis];
    var min$1 = offset6 + overflow[mainSide];
    var max$1 = offset6 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start3 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start3 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset6 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset6 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min$1, tetherMin) : min$1, offset6, tether ? max2(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset6;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node8) {
  if (node8 === getWindow(node8) || !isHTMLElement(node8)) {
    return getWindowScroll(node8);
  } else {
    return getHTMLElementScroll(node8);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map30 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result2 = [];
  modifiers2.forEach(function(modifier) {
    map30.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map30.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result2.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result2;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve21) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve21(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index6 = 0; index6 < state.orderedModifiers.length; index6++) {
          if (state.reset === true) {
            state.reset = false;
            index6 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index6], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$1(function() {
        return new Promise(function(resolve21) {
          instance.forceUpdate();
          resolve21(state);
        });
      }),
      destroy: function destroy4() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$2, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index6, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index6];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index6] : defaultValue : v;
  }
  return value;
}
function isType(value, type4) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type4 + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn3, ms) {
  if (ms === 0) {
    return fn3;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn3(arg);
    }, ms);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index6) {
    return arr.indexOf(item) === index6;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key2) {
    if (obj[key2] !== void 0) {
      acc[key2] = obj[key2];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement$1(value) {
  return ["Element", "Fragment"].some(function(type4) {
    return isType(value, type4);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method4 = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method4](event, listener);
  });
}
function actualContains(parent, child11) {
  var target = child11;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? !!window.msCrypto : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key2) {
    defaultProps[key2] = partialProps[key2];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key2) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key2) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key2 === "content") {
      acc[key2] = valueAsString;
    } else {
      try {
        acc[key2] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key2] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement$1(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content4, props) {
  if (isElement$1(props.content)) {
    dangerouslySetInnerHTML(content4, "");
    content4.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content4, props.content);
    } else {
      content4.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node8) {
      return node8.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node8) {
      return node8.classList.contains(ARROW_CLASS) || node8.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node8) {
      return node8.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render$G(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content4 = div();
  content4.className = CONTENT_CLASS;
  content4.setAttribute("data-state", "hidden");
  setContent(content4, instance.props);
  popper2.appendChild(box);
  box.appendChild(content4);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content5 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content5, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render$G.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    clearDelayTimeouts,
    setProps: setProps2,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy: destroy4
  };
  if (!props.render) {
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node8) {
      var currentValue = node8.getAttribute(attr);
      if (instance.state.isVisible) {
        node8.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node8.setAttribute(attr, nextValue);
        } else {
          node8.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node8) {
      if (instance.props.interactive) {
        node8.setAttribute("aria-expanded", instance.state.isVisible && node8 === getCurrentTarget() ? "true" : "false");
      } else {
        node8.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on2(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node8) {
      node8.addEventListener(eventType, handler, options);
      listeners.push({
        node: node8,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node8 = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node8.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset6 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset6
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node8 = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node8.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node8]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps2(partialProps) {
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node8) {
        node8.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content4) {
    instance.setProps({
      content: content4
    });
  }
  function show() {
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content4 = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content4], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content4 = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content4], duration);
        setVisibilityState([box, content4], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy4() {
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render: render$G
});
class BubbleMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from8, to }) => {
      const { doc: doc2, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc2.textBetween(from8, to).length && isTextSelection(state.selection);
      if (!view2.hasFocus() || empty2 || isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a2;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a2 = this.element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a2, _b;
    const { state, composing } = view;
    const { doc: doc2, selection } = state;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (composing || isSame) {
      return;
    }
    this.createTooltip();
    const { ranges } = selection;
    const from8 = Math.min(...ranges.map((range3) => range3.$from.pos));
    const to = Math.max(...ranges.map((range3) => range3.$to.pos));
    const shouldShow = (_a2 = this.shouldShow) === null || _a2 === void 0 ? void 0 : _a2.call(this, {
      editor: this.editor,
      view,
      state,
      oldState,
      from: from8,
      to
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: () => {
        if (isNodeSelection(state.selection)) {
          const node8 = view.nodeDOM(from8);
          if (node8) {
            return node8.getBoundingClientRect();
          }
        }
        return posToDOMRect(view, from8, to);
      }
    });
    this.show();
  }
  show() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.show();
  }
  hide() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.hide();
  }
  destroy() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const BubbleMenuPlugin = (options) => {
  return new Plugin$1({
    key: typeof options.pluginKey === "string" ? new PluginKey$1(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
class FloatingMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty: empty2 } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty2 || !isRootDepth || !isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a2;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a2 = this.element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a2, _b;
    const { state } = view;
    const { doc: doc2, selection } = state;
    const { from: from8, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a2 = this.shouldShow) === null || _a2 === void 0 ? void 0 : _a2.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: () => posToDOMRect(view, from8, to)
    });
    this.show();
  }
  show() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.show();
  }
  hide() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.hide();
  }
  destroy() {
    var _a2;
    (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const FloatingMenuPlugin = (options) => {
  return new Plugin$1({
    key: typeof options.pluginKey === "string" ? new PluginKey$1(options.pluginKey) : options.pluginKey,
    view: (view) => new FloatingMenuView({ view, ...options })
  });
};
Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
const BubbleMenu = defineComponent({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: null,
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(props, { slots }) {
    const root2 = ref(null);
    onMounted(() => {
      const { pluginKey, editor, tippyOptions, shouldShow } = props;
      editor.registerPlugin(BubbleMenuPlugin({
        pluginKey,
        editor,
        element: root2.value,
        tippyOptions,
        shouldShow
      }));
    });
    onBeforeUnmount(() => {
      const { pluginKey, editor } = props;
      editor.unregisterPlugin(pluginKey);
    });
    return () => {
      var _a2;
      return h("div", { ref: root2 }, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
    };
  }
});
function useDebouncedRef(value) {
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            trigger();
          });
        });
      }
    };
  });
}
class Editor extends Editor$1 {
  constructor(options = {}) {
    super(options);
    this.vueRenderers = reactive(/* @__PURE__ */ new Map());
    this.contentComponent = null;
    this.reactiveState = useDebouncedRef(this.view.state);
    this.reactiveExtensionStorage = useDebouncedRef(this.extensionStorage);
    this.on("transaction", () => {
      this.reactiveState.value = this.view.state;
      this.reactiveExtensionStorage.value = this.extensionStorage;
    });
    return markRaw(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  registerPlugin(plugin, handlePlugins) {
    super.registerPlugin(plugin, handlePlugins);
    this.reactiveState.value = this.view.state;
  }
  unregisterPlugin(nameOrPluginKey) {
    super.unregisterPlugin(nameOrPluginKey);
    this.reactiveState.value = this.view.state;
  }
}
const EditorContent = defineComponent({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(props) {
    const rootEl = ref();
    const instance = getCurrentInstance();
    watchEffect(() => {
      const editor = props.editor;
      if (editor && editor.options.element && rootEl.value) {
        nextTick(() => {
          if (!rootEl.value || !editor.options.element.firstChild) {
            return;
          }
          const element = unref(rootEl.value);
          rootEl.value.append(...editor.options.element.childNodes);
          editor.contentComponent = instance.ctx._;
          editor.setOptions({
            element
          });
          editor.createNodeViews();
        });
      }
    });
    onBeforeUnmount(() => {
      const editor = props.editor;
      if (!editor) {
        return;
      }
      if (!editor.isDestroyed) {
        editor.view.setProps({
          nodeViews: {}
        });
      }
      editor.contentComponent = null;
      if (!editor.options.element.firstChild) {
        return;
      }
      const newElement = document.createElement("div");
      newElement.append(...editor.options.element.childNodes);
      editor.setOptions({
        element: newElement
      });
    });
    return { rootEl };
  },
  render() {
    const vueRenderers = [];
    if (this.editor) {
      this.editor.vueRenderers.forEach((vueRenderer) => {
        const node8 = h(Teleport, {
          to: vueRenderer.teleportElement,
          key: vueRenderer.id
        }, h(vueRenderer.component, {
          ref: vueRenderer.id,
          ...vueRenderer.props
        }));
        vueRenderers.push(node8);
      });
    }
    return h("div", {
      ref: (el) => {
        this.rootEl = el;
      }
    }, ...vueRenderers);
  }
});
defineComponent({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(props, { slots }) {
    const root2 = ref(null);
    onMounted(() => {
      const { pluginKey, editor, tippyOptions, shouldShow } = props;
      editor.registerPlugin(FloatingMenuPlugin({
        pluginKey,
        editor,
        element: root2.value,
        tippyOptions,
        shouldShow
      }));
    });
    onBeforeUnmount(() => {
      const { pluginKey, editor } = props;
      editor.unregisterPlugin(pluginKey);
    });
    return () => {
      var _a2;
      return h("div", { ref: root2 }, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
    };
  }
});
const useEditor = (options = {}) => {
  const editor = shallowRef();
  onMounted(() => {
    editor.value = new Editor(options);
  });
  onBeforeUnmount(() => {
    var _a2;
    (_a2 = editor.value) === null || _a2 === void 0 ? void 0 : _a2.destroy();
  });
  return editor;
};
class VueRenderer {
  constructor(component, { props = {}, editor }) {
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.editor = editor;
    this.component = markRaw(component);
    this.teleportElement = document.createElement("div");
    this.element = this.teleportElement;
    this.props = reactive(props);
    this.editor.vueRenderers.set(this.id, this);
    if (this.editor.contentComponent) {
      this.editor.contentComponent.update();
      if (this.teleportElement.children.length !== 1) {
        throw Error("VueRenderer doesn\u2019t support multiple child elements.");
      }
      this.element = this.teleportElement.firstElementChild;
    }
  }
  get ref() {
    var _a2;
    return (_a2 = this.editor.contentComponent) === null || _a2 === void 0 ? void 0 : _a2.refs[this.id];
  }
  updateProps(props = {}) {
    Object.entries(props).forEach(([key2, value]) => {
      this.props[key2] = value;
    });
  }
  destroy() {
    this.editor.vueRenderers.delete(this.id);
  }
}
const nodeViewProps = {
  editor: {
    type: Object,
    required: true
  },
  node: {
    type: Object,
    required: true
  },
  decorations: {
    type: Object,
    required: true
  },
  selected: {
    type: Boolean,
    required: true
  },
  extension: {
    type: Object,
    required: true
  },
  getPos: {
    type: Function,
    required: true
  },
  updateAttributes: {
    type: Function,
    required: true
  },
  deleteNode: {
    type: Function,
    required: true
  }
};
class VueNodeView extends NodeView {
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    const onDragStart = this.onDragStart.bind(this);
    this.decorationClasses = ref(this.getDecorationClasses());
    const extendedComponent = defineComponent({
      extends: { ...this.component },
      props: Object.keys(props),
      template: this.component.template,
      setup: (reactiveProps) => {
        var _a2, _b;
        provide("onDragStart", onDragStart);
        provide("decorationClasses", this.decorationClasses);
        return (_b = (_a2 = this.component).setup) === null || _b === void 0 ? void 0 : _b.call(_a2, reactiveProps, {
          expose: () => void 0
        });
      },
      __scopeId: this.component.__scopeId
    });
    this.renderer = new VueRenderer(extendedComponent, {
      editor: this.editor,
      props
    });
  }
  get dom() {
    if (!this.renderer.element.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    const contentElement = this.dom.querySelector("[data-node-view-content]");
    return contentElement || this.dom;
  }
  update(node8, decorations) {
    const updateProps = (props) => {
      this.decorationClasses.value = this.getDecorationClasses();
      this.renderer.updateProps(props);
    };
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node8;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node8,
        newDecorations: decorations,
        updateProps: () => updateProps({ node: node8, decorations })
      });
    }
    if (node8.type !== this.node.type) {
      return false;
    }
    if (node8 === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node8;
    this.decorations = decorations;
    updateProps({ node: node8, decorations });
    return true;
  }
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
  }
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
  }
  getDecorationClasses() {
    return this.decorations.map((item) => item.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy();
  }
}
function VueNodeViewRenderer(component, options) {
  return (props) => {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new VueNodeView(component, props, options);
  };
}
const NodeViewWrapper = defineComponent({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var _a2, _b;
    return h(this.as, {
      class: this.decorationClasses.value,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      onDragstart: this.onDragStart
    }, (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2));
  }
});
const NodeViewContent = defineComponent({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return h(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
const Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something \u2026",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return;
            }
            doc2.descendants((node8, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node8.nodeSize;
              const isEmpty2 = !node8.isLeaf && !node8.childCount;
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                const classes = [this.options.emptyNodeClass];
                if (this.editor.isEmpty) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration$1.node(pos, pos + node8.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: node8,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet$1.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
const CharacterCount = Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize"
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options) => {
      const node8 = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
      const mode = (options === null || options === void 0 ? void 0 : options.mode) || this.options.mode;
      if (mode === "textSize") {
        const text3 = node8.textBetween(0, node8.content.size, void 0, " ");
        return text3.length;
      }
      return node8.nodeSize;
    };
    this.storage.words = (options) => {
      const node8 = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
      const text3 = node8.textBetween(0, node8.content.size, " ", " ");
      const words = text3.split(" ").filter((word) => word !== "");
      return words.length;
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("characterCount"),
        filterTransaction: (transaction, state) => {
          const limit = this.options.limit;
          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction.selection.$head.pos;
          const over = newSize - limit;
          const from8 = pos - over;
          const to = pos;
          transaction.deleteRange(from8, to);
          const updatedSize = this.storage.characters({ node: transaction.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var en$1 = {
  editor: {
    extensions: {
      Bold: {
        tooltip: "Bold"
      },
      Underline: {
        tooltip: "Underline"
      },
      Italic: {
        tooltip: "Italic"
      },
      Strike: {
        tooltip: "Strike through"
      },
      Heading: {
        tooltip: "Heading",
        buttons: {
          paragraph: "Paragraph",
          heading: "Heading"
        }
      },
      Blockquote: {
        tooltip: "Block quote"
      },
      CodeBlock: {
        tooltip: "Code block"
      },
      Link: {
        add: {
          tooltip: "Apply link",
          control: {
            title: "Apply Link",
            href: "Href",
            open_in_new_tab: "Open in new tab",
            confirm: "Apply",
            cancel: "Cancel"
          }
        },
        edit: {
          tooltip: "Edit link",
          control: {
            title: "Edit Link",
            href: "Href",
            open_in_new_tab: "Open in new tab",
            confirm: "Update",
            cancel: "Cancel"
          }
        },
        unlink: {
          tooltip: "Unlink"
        },
        open: {
          tooltip: "Open link"
        }
      },
      Image: {
        buttons: {
          insert_image: {
            tooltip: "Insert image",
            external: "Insert Image By Url",
            upload: "Upload Image"
          },
          remove_image: {
            tooltip: "Remove"
          },
          image_options: {
            tooltip: "Image options"
          },
          display: {
            tooltip: "Display",
            inline: "Inline",
            block: "Break Text",
            left: "Float Left",
            right: "Float Right"
          }
        },
        control: {
          insert_by_url: {
            title: "Insert image",
            placeholder: "Url of image",
            confirm: "Insert",
            cancel: "Cancel",
            invalid_url: "Please enter the correct url"
          },
          upload_image: {
            title: "Upload image",
            button: "Choose an image file or drag it here"
          },
          edit_image: {
            title: "Edit image",
            confirm: "Update",
            cancel: "Cancel",
            form: {
              src: "Image Url",
              alt: "Alternative Text",
              width: "Width",
              height: "Height"
            }
          }
        }
      },
      Iframe: {
        tooltip: "Insert video",
        control: {
          title: "Insert video",
          placeholder: "Href",
          confirm: "Insert",
          cancel: "Cancel"
        }
      },
      BulletList: {
        tooltip: "Bullet list"
      },
      OrderedList: {
        tooltip: "Ordered list"
      },
      TodoList: {
        tooltip: "Todo list"
      },
      TextAlign: {
        buttons: {
          align_left: {
            tooltip: "Align left"
          },
          align_center: {
            tooltip: "Align center"
          },
          align_right: {
            tooltip: "Align right"
          },
          align_justify: {
            tooltip: "Align justify"
          }
        }
      },
      FontType: {
        tooltip: "Font family"
      },
      FontSize: {
        tooltip: "Font size",
        default: "default"
      },
      TextColor: {
        tooltip: "Text color"
      },
      TextHighlight: {
        tooltip: "Text highlight"
      },
      LineHeight: {
        tooltip: "Line height"
      },
      Table: {
        tooltip: "Table",
        buttons: {
          insert_table: "Insert Table",
          add_column_before: "Add Column Before",
          add_column_after: "Add Column After",
          delete_column: "Delete Column",
          add_row_before: "Add Row Before",
          add_row_after: "Add Row After",
          delete_row: "Delete Row",
          merge_cells: "Merge Cells",
          split_cell: "Split Cell",
          delete_table: "Delete Table"
        }
      },
      Indent: {
        buttons: {
          indent: {
            tooltip: "Indent"
          },
          outdent: {
            tooltip: "Outdent"
          }
        }
      },
      FormatClear: {
        tooltip: "Clear format"
      },
      HorizontalRule: {
        tooltip: "Horizontal rule"
      },
      History: {
        tooltip: {
          undo: "Undo",
          redo: "Redo"
        }
      },
      Fullscreen: {
        tooltip: {
          fullscreen: "Full screen",
          exit_fullscreen: "Exit full screen"
        }
      },
      Print: {
        tooltip: "Print"
      },
      Preview: {
        tooltip: "Preview",
        dialog: {
          title: "Preview"
        }
      },
      SelectAll: {
        tooltip: "Select all"
      },
      CodeView: {
        tooltip: "Code view"
      }
    },
    characters: "Characters"
  }
};
const Trans = {
  buildI18nHandler(locale = en$1) {
    return function t(path) {
      const target = path.split(".").reduce((prev, curr) => {
        return prev[curr];
      }, locale);
      return target;
    };
  }
};
function useCharacterCount(editor) {
  const characters = computed(() => {
    var _a2;
    return (_a2 = editor.value) == null ? void 0 : _a2.storage.characterCount.characters();
  });
  return {
    characters
  };
}
function useCodeView(editor) {
  let cmEditor;
  const cmTextAreaRef = ref();
  const isCodeViewMode = ref(false);
  const toggleIsCodeViewMode = (val) => {
    isCodeViewMode.value = val;
  };
  const formatCode = (cm) => {
    cm.execCommand("selectAll");
    const selectedRange = {
      from: cm.getCursor(true),
      to: cm.getCursor(false)
    };
    cm.autoFormatRange(selectedRange.from, selectedRange.to);
    cm.setCursor(0);
  };
  const initCodemirror = () => {
    const codeViewExtension = unref(editor).extensionManager.extensions.find((e) => e.name === "codeView");
    if (codeViewExtension) {
      const { codemirror, codemirrorOptions } = codeViewExtension.options;
      if (codemirror) {
        const cmOptions = {
          ...codemirrorOptions,
          readOnly: false,
          spellcheck: false
        };
        cmEditor = codemirror.fromTextArea(cmTextAreaRef.value, cmOptions);
        cmEditor.setValue(unref(editor).getHTML());
        formatCode(cmEditor);
      }
    }
  };
  const destroyCodemirror = () => {
    const element = cmEditor.doc.cm.getWrapperElement();
    element && element.remove && element.remove();
    cmEditor = null;
  };
  watch(isCodeViewMode, (val) => {
    if (val) {
      nextTick(() => {
        if (!cmEditor) {
          initCodemirror();
        }
      });
    } else {
      if (cmEditor) {
        const content4 = cmEditor.getValue();
        unref(editor).commands.setContent(content4, true);
        destroyCodemirror();
      }
    }
  });
  provide("isCodeViewMode", isCodeViewMode);
  provide("toggleIsCodeViewMode", toggleIsCodeViewMode);
  return {
    cmTextAreaRef,
    isCodeViewMode
  };
}
const DEFAULT_EDITOR_SIZE_UNIT = "px";
function useEditorStyle({
  width,
  height
}) {
  const editorSizeStyle = {
    width: isNaN(Number(width)) ? width : `${width}${DEFAULT_EDITOR_SIZE_UNIT}`,
    height: isNaN(Number(height)) ? height : `${height}${DEFAULT_EDITOR_SIZE_UNIT}`
  };
  return [editorSizeStyle];
}
var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const _sfc_main$_ = defineComponent({
  name: "Menubar",
  components: {},
  props: {
    editor: {
      type: Editor$1,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  methods: {
    generateCommandButtonComponentSpecs() {
      const extensionManager = this.editor.extensionManager;
      return extensionManager.extensions.reduce((acc, extension) => {
        const { button } = extension.options;
        if (!button || typeof button !== "function")
          return acc;
        const menuBtnComponentSpec = button({
          editor: this.editor,
          t: this.t,
          extension
        });
        if (Array.isArray(menuBtnComponentSpec)) {
          return [...acc, ...menuBtnComponentSpec];
        }
        return [...acc, menuBtnComponentSpec];
      }, []);
    }
  }
});
const _hoisted_1$17 = { class: "el-tiptap-editor__menu-bar" };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$17, [
    (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.generateCommandButtonComponentSpecs(), (spec, i) => {
      return openBlock(), createBlock(resolveDynamicComponent(spec.component), mergeProps({
        key: "command-button" + i,
        "enable-tooltip": _ctx.enableTooltip
      }, spec.componentProps, { readonly: _ctx.isCodeViewMode }, toHandlers(spec.componentEvents || {})), null, 16, ["enable-tooltip", "readonly"]);
    }), 128))
  ]);
}
var MenuBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["render", _sfc_render$C]]);
function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case "../../icons/align-center.svg":
      return Promise.resolve().then(function() {
        return alignCenter$1;
      });
    case "../../icons/align-justify.svg":
      return Promise.resolve().then(function() {
        return alignJustify$1;
      });
    case "../../icons/align-left.svg":
      return Promise.resolve().then(function() {
        return alignLeft$1;
      });
    case "../../icons/align-right.svg":
      return Promise.resolve().then(function() {
        return alignRight$1;
      });
    case "../../icons/arrow-left.svg":
      return Promise.resolve().then(function() {
        return arrowLeft$1;
      });
    case "../../icons/bold.svg":
      return Promise.resolve().then(function() {
        return bold$1;
      });
    case "../../icons/btn.svg":
      return Promise.resolve().then(function() {
        return btn$1;
      });
    case "../../icons/clear-format.svg":
      return Promise.resolve().then(function() {
        return clearFormat$1;
      });
    case "../../icons/code.svg":
      return Promise.resolve().then(function() {
        return code$1;
      });
    case "../../icons/compress.svg":
      return Promise.resolve().then(function() {
        return compress$1;
      });
    case "../../icons/edit.svg":
      return Promise.resolve().then(function() {
        return edit$1;
      });
    case "../../icons/ellipsis-h.svg":
      return Promise.resolve().then(function() {
        return ellipsisH$1;
      });
    case "../../icons/expand.svg":
      return Promise.resolve().then(function() {
        return expand$1;
      });
    case "../../icons/external-link.svg":
      return Promise.resolve().then(function() {
        return externalLink$1;
      });
    case "../../icons/file-code.svg":
      return Promise.resolve().then(function() {
        return fileCode$1;
      });
    case "../../icons/font-color.svg":
      return Promise.resolve().then(function() {
        return fontColor$1;
      });
    case "../../icons/font-family.svg":
      return Promise.resolve().then(function() {
        return fontFamily$1;
      });
    case "../../icons/font-size.svg":
      return Promise.resolve().then(function() {
        return fontSize$1;
      });
    case "../../icons/heading.svg":
      return Promise.resolve().then(function() {
        return heading$1;
      });
    case "../../icons/highlight.svg":
      return Promise.resolve().then(function() {
        return highlight$1;
      });
    case "../../icons/horizontal-rule.svg":
      return Promise.resolve().then(function() {
        return horizontalRule$1;
      });
    case "../../icons/image-align.svg":
      return Promise.resolve().then(function() {
        return imageAlign$1;
      });
    case "../../icons/image.svg":
      return Promise.resolve().then(function() {
        return image$1;
      });
    case "../../icons/indent.svg":
      return Promise.resolve().then(function() {
        return indent$1;
      });
    case "../../icons/italic.svg":
      return Promise.resolve().then(function() {
        return italic$1;
      });
    case "../../icons/link.svg":
      return Promise.resolve().then(function() {
        return link$1;
      });
    case "../../icons/list-ol.svg":
      return Promise.resolve().then(function() {
        return listOl$1;
      });
    case "../../icons/list-ul.svg":
      return Promise.resolve().then(function() {
        return listUl$1;
      });
    case "../../icons/outdent.svg":
      return Promise.resolve().then(function() {
        return outdent$1;
      });
    case "../../icons/print.svg":
      return Promise.resolve().then(function() {
        return print$1;
      });
    case "../../icons/quote-right.svg":
      return Promise.resolve().then(function() {
        return quoteRight$1;
      });
    case "../../icons/redo.svg":
      return Promise.resolve().then(function() {
        return redo$1;
      });
    case "../../icons/select-all.svg":
      return Promise.resolve().then(function() {
        return selectAll$1;
      });
    case "../../icons/strikethrough.svg":
      return Promise.resolve().then(function() {
        return strikethrough$1;
      });
    case "../../icons/table.svg":
      return Promise.resolve().then(function() {
        return table$1;
      });
    case "../../icons/tasks.svg":
      return Promise.resolve().then(function() {
        return tasks$1;
      });
    case "../../icons/text-height.svg":
      return Promise.resolve().then(function() {
        return textHeight$1;
      });
    case "../../icons/trash-alt.svg":
      return Promise.resolve().then(function() {
        return trashAlt$1;
      });
    case "../../icons/underline.svg":
      return Promise.resolve().then(function() {
        return underline$1;
      });
    case "../../icons/undo.svg":
      return Promise.resolve().then(function() {
        return undo$1;
      });
    case "../../icons/unlink.svg":
      return Promise.resolve().then(function() {
        return unlink$1;
      });
    case "../../icons/video.svg":
      return Promise.resolve().then(function() {
        return video$1;
      });
    default:
      return new Promise(function(resolve21, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
      });
  }
}
const _sfc_main$Z = defineComponent({
  name: "icon",
  props: {
    name: String
  },
  computed: {
    icon() {
      return defineAsyncComponent(() => __variableDynamicImportRuntime0__(`../../icons/${this.name}.svg`));
    }
  }
});
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), mergeProps({
    width: "16",
    height: "16"
  }, _ctx.$attrs), null, 16);
}
var VIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["render", _sfc_render$B]]);
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result2;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}
function arrayMap(array4, iteratee) {
  var index6 = -1, length = array4 == null ? 0 : array4.length, result2 = Array(length);
  while (++index6 < length) {
    result2[index6] = iteratee(array4[index6], index6, array4);
  }
  return result2;
}
var isArray$1 = Array.isArray;
var isArray$2 = isArray$1;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY$1 ? "-0" : result2;
}
function isObject$1(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource(value));
}
function getValue$1(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
function getNative(object4, key2) {
  var value = getValue$1(object4, key2);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root$1, "WeakMap");
var WeakMap$2 = WeakMap$1;
var objectCreate = Object.create;
var baseCreate = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result2 = new object4();
    object4.prototype = void 0;
    return result2;
  };
}();
var baseCreate$1 = baseCreate;
function copyArray(source, array4) {
  var index6 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index6 < length) {
    array4[index6] = source[index6];
  }
  return array4;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function arrayEach(array4, iteratee) {
  var index6 = -1, length = array4 == null ? 0 : array4.length;
  while (++index6 < length) {
    if (iteratee(array4[index6], index6, array4) === false) {
      break;
    }
  }
  return array4;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object4, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key2] = value;
  }
}
function eq12(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function assignValue(object4, key2, value) {
  var objValue = object4[key2];
  if (!(hasOwnProperty$a.call(object4, key2) && eq12(objValue, value)) || value === void 0 && !(key2 in object4)) {
    baseAssignValue(object4, key2, value);
  }
}
function copyObject(source, props, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index6 = -1, length = props.length;
  while (++index6 < length) {
    var key2 = props[index6];
    var newValue = customizer ? customizer(object4[key2], source[key2], key2, object4, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object4, key2, newValue);
    } else {
      assignValue(object4, key2, newValue);
    }
  }
  return object4;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
var objectProto$a = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index6 = -1, result2 = Array(n);
  while (++index6 < n) {
    result2[index6] = iteratee(index6);
  }
  return result2;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$8.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType2 && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result2.push(key2);
    }
  }
  return result2;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function baseKeys(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys$1(object4);
  }
  var result2 = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$7.call(object4, key2) && key2 != "constructor") {
      result2.push(key2);
    }
  }
  return result2;
}
function keys$1(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
function nativeKeysIn(object4) {
  var result2 = [];
  if (object4 != null) {
    for (var key2 in Object(object4)) {
      result2.push(key2);
    }
  }
  return result2;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function baseKeysIn(object4) {
  if (!isObject$1(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype(object4), result2 = [];
  for (var key2 in object4) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$6.call(object4, key2)))) {
      result2.push(key2);
    }
  }
  return result2;
}
function keysIn(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object4) {
  if (isArray$2(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result2 = this.has(key2) && delete this.__data__[key2];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result2 = data[key2];
    return result2 === HASH_UNDEFINED$2 ? void 0 : result2;
  }
  return hasOwnProperty$5.call(data, key2) ? data[key2] : void 0;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$4.call(data, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index6 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index6 < length) {
    var entry = entries[index6];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array4, key2) {
  var length = array4.length;
  while (length--) {
    if (eq12(array4[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index6 = assocIndexOf(data, key2);
  if (index6 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index6 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index6, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index6 = assocIndexOf(data, key2);
  return index6 < 0 ? void 0 : data[index6][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index6 = assocIndexOf(data, key2);
  if (index6 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index6][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index6 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index6 < length) {
    var entry = entries[index6];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map30, key2) {
  var data = map30.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result2 = getMapData(this, key2)["delete"](key2);
  this.size -= result2 ? 1 : 0;
  return result2;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size = data.size;
  data.set(key2, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index6 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index6 < length) {
    var entry = entries[index6];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache.set(key2, result2) || cache;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result2.cache;
  return result2;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string3) {
  var result2 = [];
  if (string3.charCodeAt(0) === 46) {
    result2.push("");
  }
  string3.replace(rePropName, function(match, number4, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result2;
});
var stringToPath$1 = stringToPath;
function toString7(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object4) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey(value, object4) ? [value] : stringToPath$1(toString7(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
function baseGet(object4, path) {
  path = castPath(path, object4);
  var index6 = 0, length = path.length;
  while (object4 != null && index6 < length) {
    object4 = object4[toKey(path[index6++])];
  }
  return index6 && index6 == length ? object4 : void 0;
}
function get2(object4, path, defaultValue) {
  var result2 = object4 == null ? void 0 : baseGet(object4, path);
  return result2 === void 0 ? defaultValue : result2;
}
function arrayPush(array4, values) {
  var index6 = -1, length = values.length, offset6 = array4.length;
  while (++index6 < length) {
    array4[offset6 + index6] = values[index6];
  }
  return array4;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray$2(value) ? value : [value];
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result2 = data["delete"](key2);
  this.size = data.size;
  return result2;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object4, source) {
  return object4 && copyObject(source, keys$1(source), object4);
}
function baseAssignIn(object4, source) {
  return object4 && copyObject(source, keysIn(source), object4);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
function arrayFilter(array4, predicate) {
  var index6 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index6 < length) {
    var value = array4[index6];
    if (predicate(value, index6, array4)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable.call(object4, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object4) {
  return copyObject(source, getSymbols$1(source), object4);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
  var result2 = [];
  while (object4) {
    arrayPush(result2, getSymbols$1(object4));
    object4 = getPrototype$1(object4);
  }
  return result2;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object4) {
  return copyObject(source, getSymbolsIn$1(source), object4);
}
function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object4);
  return isArray$2(object4) ? result2 : arrayPush(result2, symbolsFunc(object4));
}
function getAllKeys(object4) {
  return baseGetAllKeys(object4, keys$1, getSymbols$1);
}
function getAllKeysIn(object4) {
  return baseGetAllKeys(object4, keysIn, getSymbolsIn$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result2 = baseGetTag(value), Ctor = result2 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result2;
  };
}
var getTag$1 = getTag;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function initCloneArray(array4) {
  var length = array4.length, result2 = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty$3.call(array4, "index")) {
    result2.index = array4.index;
    result2.input = array4.input;
  }
  return result2;
}
var Uint8Array = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
  return result2;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp4) {
  var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result2.lastIndex = regexp4.lastIndex;
  return result2;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object4, tag, isDeep) {
  var Ctor = object4.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object4);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object4);
    case dataViewTag$2:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object4);
    case regexpTag$2:
      return cloneRegExp(object4);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object4);
  }
}
function initCloneObject(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate$1(getPrototype$1(object4)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$2;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$2 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$2;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key2, object4, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result2 = object4 ? customizer(value, key2, object4, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result2 = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result2);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object4) {
      result2 = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object4 ? value : {};
      }
      result2 = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key3) {
      result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
  });
  return result2;
}
var CLONE_SYMBOLS_FLAG = 4;
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index6 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index6 < length) {
    this.add(values[index6]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array4, predicate) {
  var index6 = -1, length = array4 == null ? 0 : array4.length;
  while (++index6 < length) {
    if (predicate(array4[index6], index6, array4)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key2) {
  return cache.has(key2);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index6 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index6 < arrLength) {
    var arrValue = array4[index6], othValue = other[index6];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index6, other, array4, stack) : customizer(arrValue, othValue, index6, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result2;
}
function mapToArray(map30) {
  var index6 = -1, result2 = Array(map30.size);
  map30.forEach(function(value, key2) {
    result2[++index6] = [key2, value];
  });
  return result2;
}
function setToArray(set3) {
  var index6 = -1, result2 = Array(set3.size);
  set3.forEach(function(value) {
    result2[++index6] = value;
  });
  return result2;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq12(+object4, +other);
    case errorTag:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag:
    case stringTag:
      return object4 == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other);
      var result2 = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result2;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index6 = objLength;
  while (index6--) {
    var key2 = objProps[index6];
    if (!(isPartial ? key2 in other : hasOwnProperty$2.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result2 = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index6 < objLength) {
    key2 = objProps[index6];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack) : customizer(objValue, othValue, key2, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result2;
}
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object4), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag$1(object4), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object4)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function fromPairs(pairs) {
  var index6 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index6 < length) {
    var pair = pairs[index6];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isNil(value) {
  return value == null;
}
function baseSet(object4, path, value, customizer) {
  if (!isObject$1(object4)) {
    return object4;
  }
  path = castPath(path, object4);
  var index6 = -1, length = path.length, lastIndex = length - 1, nested = object4;
  while (nested != null && ++index6 < length) {
    var key2 = toKey(path[index6]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object4;
    }
    if (index6 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index6 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object4;
}
function set2(object4, path, value) {
  return object4 == null ? object4 : baseSet(object4, path, value);
}
const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
const isVisible = (element) => {
  const computed2 = getComputedStyle(element);
  return computed2.position === "fixed" ? false : element.offsetParent !== null;
};
const obtainAllFocusableElements$1 = (element) => {
  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
};
const isFocusable = (element) => {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A": {
      return !!element.href && element.rel !== "ignore";
    }
    case "INPUT": {
      return !(element.type === "hidden" || element.type === "file");
    }
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA": {
      return true;
    }
    default: {
      return false;
    }
  }
};
const on$1 = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};
const off = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};
const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
  const handleEvent = (event) => {
    const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
    if (checkForDefaultPrevented === false || !shouldPrevent) {
      return oursHandler == null ? void 0 : oursHandler(event);
    }
  };
  return handleEvent;
};
const whenMouse = (handler) => {
  return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
};
function tryOnScopeDispose(fn3) {
  if (getCurrentScope()) {
    onScopeDispose(fn3);
    return true;
  }
  return false;
}
var _a;
const isClient = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const isBoolean = (val) => typeof val === "boolean";
const isNumber = (val) => typeof val === "number";
const isString$1 = (val) => typeof val === "string";
const noop$2 = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function createFilterWrapper(filter, fn3) {
  function wrapper(...args) {
    filter(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn3);
}
function refDebounced(value, ms = 200, options = {}) {
  if (ms <= 0)
    return value;
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear();
  }
  function start8(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start8();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start: start8,
    stop: stop2
  };
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString$1(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop$2;
  let cleanup = noop$2;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop$2;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function onClickOutside2(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore, capture = true } = options;
  if (!window2)
    return;
  const shouldListen = ref(true);
  let fallback;
  const listener = (event) => {
    window2.clearTimeout(fallback);
    const el = unrefElement(target);
    const composedPath = event.composedPath();
    if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value)
      return;
    if (ignore && ignore.length > 0) {
      if (ignore.some((target2) => {
        const el2 = unrefElement(target2);
        return el2 && (event.target === el2 || composedPath.includes(el2));
      }))
        return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen.value = !!el && !e.composedPath().includes(el);
    }, { passive: true }),
    useEventListener(window2, "pointerup", (e) => {
      if (e.button === 0) {
        const path = e.composedPath();
        e.composedPath = () => path;
        fallback = window2.setTimeout(() => listener(e), 50);
      }
    }, { passive: true })
  ];
  const stop2 = () => cleanup.forEach((fn3) => fn3());
  return stop2;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
function useVModel(props, key2, emit, options = {}) {
  var _a2;
  const {
    passive: passive2 = false,
    eventName,
    deep = false,
    defaultValue
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm));
  let event = eventName;
  if (!key2) {
    {
      key2 = "modelValue";
    }
  }
  event = eventName || event || `update:${key2.toString()}`;
  const getValue2 = () => isDef(props[key2]) ? props[key2] : defaultValue;
  if (passive2) {
    const proxy = ref(getValue2());
    watch(() => props[key2], (v) => proxy.value = v);
    watch(proxy, (v) => {
      if (v !== props[key2] || deep)
        _emit(event, v);
    }, {
      deep
    });
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        _emit(event, value);
      }
    });
  }
}
const NOOP = () => {
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const cacheStringFunction = (fn3) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn3(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const isUndefined = (val) => val === void 0;
const isElement = (e) => {
  if (typeof Element === "undefined")
    return false;
  return e instanceof Element;
};
const entriesOf = (arr) => Object.entries(arr);
const getProp = (obj, path, defaultValue) => {
  return {
    get value() {
      return get2(obj, path, defaultValue);
    },
    set value(val) {
      set2(obj, path, val);
    }
  };
};
class ElementPlusError extends Error {
  constructor(m) {
    super(m);
    this.name = "ElementPlusError";
  }
}
function throwError(scope, m) {
  throw new ElementPlusError(`[${scope}] ${m}`);
}
function debugWarn(scope, message) {
}
const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
const hasClass = (el, cls) => {
  if (!el || !cls)
    return false;
  if (cls.includes(" "))
    throw new Error("className should not contain space.");
  return el.classList.contains(cls);
};
const addClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.add(...classNameToArray(cls));
};
const removeClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.remove(...classNameToArray(cls));
};
const getStyle = (element, styleName) => {
  var _a2;
  if (!isClient || !element || !styleName)
    return "";
  let key2 = camelize(styleName);
  if (key2 === "float")
    key2 = "cssFloat";
  try {
    const style2 = element.style[key2];
    if (style2)
      return style2;
    const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
    return computed2 ? computed2[key2] : "";
  } catch (e) {
    return element.style[key2];
  }
};
function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isString(value)) {
    return value;
  } else if (isNumber(value)) {
    return `${value}${defaultUnit}`;
  }
}
let scrollBarWidth;
const getScrollBarWidth = () => {
  var _a2;
  if (!isClient)
    return 0;
  if (scrollBarWidth !== void 0)
    return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = "el-scrollbar__wrap";
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
};
/*! Element Plus Icons Vue v2.0.6 */
var export_helper_default = (sfc, props) => {
  let target = sfc.__vccOpts || sfc;
  for (let [key2, val] of props)
    target[key2] = val;
  return target;
};
var _sfc_main6 = {
  name: "ArrowDown"
}, _hoisted_16 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_26 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1), _hoisted_36 = [
  _hoisted_26
];
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_16, _hoisted_36);
}
var arrow_down_default = /* @__PURE__ */ export_helper_default(_sfc_main6, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
var _sfc_main43 = {
  name: "Check"
}, _hoisted_143 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_243 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
}, null, -1), _hoisted_342 = [
  _hoisted_243
];
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
}
var check_default = /* @__PURE__ */ export_helper_default(_sfc_main43, [["render", _sfc_render43], ["__file", "check.vue"]]);
var _sfc_main48 = {
  name: "CircleCheck"
}, _hoisted_148 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_248 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1), _hoisted_347 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
}, null, -1), _hoisted_414 = [
  _hoisted_248,
  _hoisted_347
];
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_148, _hoisted_414);
}
var circle_check_default = /* @__PURE__ */ export_helper_default(_sfc_main48, [["render", _sfc_render48], ["__file", "circle-check.vue"]]);
var _sfc_main49 = {
  name: "CircleCloseFilled"
}, _hoisted_149 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_249 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1), _hoisted_348 = [
  _hoisted_249
];
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_348);
}
var circle_close_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main49, [["render", _sfc_render49], ["__file", "circle-close-filled.vue"]]);
var _sfc_main50 = {
  name: "CircleClose"
}, _hoisted_150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_250 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
}, null, -1), _hoisted_349 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1), _hoisted_415 = [
  _hoisted_250,
  _hoisted_349
];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_415);
}
var circle_close_default = /* @__PURE__ */ export_helper_default(_sfc_main50, [["render", _sfc_render50], ["__file", "circle-close.vue"]]);
var _sfc_main55 = {
  name: "Close"
}, _hoisted_155 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_255 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1), _hoisted_354 = [
  _hoisted_255
];
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_155, _hoisted_354);
}
var close_default = /* @__PURE__ */ export_helper_default(_sfc_main55, [["render", _sfc_render55], ["__file", "close.vue"]]);
var _sfc_main79 = {
  name: "Delete"
}, _hoisted_179 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_279 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
}, null, -1), _hoisted_378 = [
  _hoisted_279
];
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_179, _hoisted_378);
}
var delete_default = /* @__PURE__ */ export_helper_default(_sfc_main79, [["render", _sfc_render79], ["__file", "delete.vue"]]);
var _sfc_main89 = {
  name: "Document"
}, _hoisted_189 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_289 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1), _hoisted_388 = [
  _hoisted_289
];
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_189, _hoisted_388);
}
var document_default = /* @__PURE__ */ export_helper_default(_sfc_main89, [["render", _sfc_render89], ["__file", "document.vue"]]);
var _sfc_main130 = {
  name: "Hide"
}, _hoisted_1130 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2130 = /* @__PURE__ */ createElementVNode("path", {
  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
  fill: "currentColor"
}, null, -1), _hoisted_3129 = /* @__PURE__ */ createElementVNode("path", {
  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
  fill: "currentColor"
}, null, -1), _hoisted_436 = [
  _hoisted_2130,
  _hoisted_3129
];
function _sfc_render130(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1130, _hoisted_436);
}
var hide_default = /* @__PURE__ */ export_helper_default(_sfc_main130, [["render", _sfc_render130], ["__file", "hide.vue"]]);
var _sfc_main140 = {
  name: "InfoFilled"
}, _hoisted_1140 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2140 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1), _hoisted_3139 = [
  _hoisted_2140
];
function _sfc_render140(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1140, _hoisted_3139);
}
var info_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main140, [["render", _sfc_render140], ["__file", "info-filled.vue"]]);
var _sfc_main147 = {
  name: "Loading"
}, _hoisted_1147 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2147 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1), _hoisted_3146 = [
  _hoisted_2147
];
function _sfc_render147(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1147, _hoisted_3146);
}
var loading_default = /* @__PURE__ */ export_helper_default(_sfc_main147, [["render", _sfc_render147], ["__file", "loading.vue"]]);
var _sfc_main243 = {
  name: "SuccessFilled"
}, _hoisted_1243 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2243 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1), _hoisted_3242 = [
  _hoisted_2243
];
function _sfc_render243(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1243, _hoisted_3242);
}
var success_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main243, [["render", _sfc_render243], ["__file", "success-filled.vue"]]);
var _sfc_main274 = {
  name: "View"
}, _hoisted_1274 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2274 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1), _hoisted_3273 = [
  _hoisted_2274
];
function _sfc_render274(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1274, _hoisted_3273);
}
var view_default = /* @__PURE__ */ export_helper_default(_sfc_main274, [["render", _sfc_render274], ["__file", "view.vue"]]);
var _sfc_main277 = {
  name: "WarningFilled"
}, _hoisted_1277 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2277 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1), _hoisted_3276 = [
  _hoisted_2277
];
function _sfc_render277(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1277, _hoisted_3276);
}
var warning_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main277, [["render", _sfc_render277], ["__file", "warning-filled.vue"]]);
var _sfc_main282 = {
  name: "ZoomIn"
}, _hoisted_1282 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2282 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
}, null, -1), _hoisted_3281 = [
  _hoisted_2282
];
function _sfc_render282(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1282, _hoisted_3281);
}
var zoom_in_default = /* @__PURE__ */ export_helper_default(_sfc_main282, [["render", _sfc_render282], ["__file", "zoom-in.vue"]]);
const epPropKey = "__epPropKey";
const definePropType = (val) => val;
const isEpProp = (val) => isObject(val) && !!val[epPropKey];
const buildProp = (prop, key2) => {
  if (!isObject(prop) || isEpProp(prop))
    return prop;
  const { values, required: required4, default: defaultValue, type: type4, validator } = prop;
  const _validator = values || validator ? (val) => {
    let valid4 = false;
    let allowedValues = [];
    if (values) {
      allowedValues = Array.from(values);
      if (hasOwn(prop, "default")) {
        allowedValues.push(defaultValue);
      }
      valid4 || (valid4 = allowedValues.includes(val));
    }
    if (validator)
      valid4 || (valid4 = validator(val));
    if (!valid4 && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      warn(`Invalid prop: validation failed${key2 ? ` for prop "${key2}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid4;
  } : void 0;
  const epProp = {
    type: type4,
    required: !!required4,
    validator: _validator,
    [epPropKey]: true
  };
  if (hasOwn(prop, "default"))
    epProp.default = defaultValue;
  return epProp;
};
const buildProps = (props) => fromPairs(Object.entries(props).map(([key2, option]) => [
  key2,
  buildProp(option, key2)
]));
const iconPropType = definePropType([
  String,
  Object,
  Function
]);
const CloseComponents = {
  Close: close_default
};
const TypeComponents = {
  Close: close_default,
  SuccessFilled: success_filled_default,
  InfoFilled: info_filled_default,
  WarningFilled: warning_filled_default,
  CircleCloseFilled: circle_close_filled_default
};
const TypeComponentsMap = {
  success: success_filled_default,
  warning: warning_filled_default,
  error: circle_close_filled_default,
  info: info_filled_default
};
const ValidateComponentsMap = {
  validating: loading_default,
  success: circle_check_default,
  error: circle_close_default
};
const withInstall = (main2, extra) => {
  main2.install = (app) => {
    for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key2, comp] of Object.entries(extra)) {
      main2[key2] = comp;
    }
  }
  return main2;
};
const withInstallDirective = (directive, name) => {
  directive.install = (app) => {
    app.directive(name, directive);
  };
  return directive;
};
const withNoopInstall = (component) => {
  component.install = NOOP;
  return component;
};
const composeRefs = (...refs) => {
  return (el) => {
    refs.forEach((ref2) => {
      if (isFunction(ref2)) {
        ref2(el);
      } else {
        ref2.value = el;
      }
    });
  };
};
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};
const UPDATE_MODEL_EVENT = "update:modelValue";
const componentSizes = ["", "default", "small", "large"];
const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  return PatchFlags2;
})(PatchFlags || {});
const isKorean = (text3) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text3);
const generateId = () => Math.floor(Math.random() * 1e4);
const mutable = (val) => val;
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
const useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys } = params;
  const allExcludeKeys = computed(() => {
    return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
  });
  const instance = getCurrentInstance();
  if (!instance) {
    return computed(() => ({}));
  }
  return computed(() => {
    var _a2;
    return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key2]) => !allExcludeKeys.value.includes(key2) && !(excludeListeners && LISTENER_PREFIX.test(key2))));
  });
};
const buttonGroupContextKey = Symbol("buttonGroupContextKey");
const configProviderContextKey = Symbol();
const dialogInjectionKey = Symbol("dialogInjectionKey");
const formContextKey = Symbol("formContextKey");
const formItemContextKey = Symbol("formItemContextKey");
const scrollbarContextKey = Symbol("scrollbarContextKey");
const uploadContextKey = Symbol("uploadContextKey");
const POPPER_INJECTION_KEY = Symbol("popper");
const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
const useProp = (name) => {
  const vm = getCurrentInstance();
  return computed(() => {
    var _a2, _b;
    return (_b = ((_a2 = vm.proxy) == null ? void 0 : _a2.$props)[name]) != null ? _b : void 0;
  });
};
const globalConfig = ref();
function useGlobalConfig(key2, defaultValue = void 0) {
  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
  if (key2) {
    return computed(() => {
      var _a2, _b;
      return (_b = (_a2 = config.value) == null ? void 0 : _a2[key2]) != null ? _b : defaultValue;
    });
  } else {
    return config;
  }
}
const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
const useSize = (fallback, ignore = {}) => {
  const emptyRef = ref(void 0);
  const size = ignore.prop ? emptyRef : useProp("size");
  const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
  const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
  const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
  return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
};
const useDisabled$1 = (fallback) => {
  const disabled = useProp("disabled");
  const form = inject(formContextKey, void 0);
  return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
};
const useDeprecated = ({ from: from8, replacement, scope, version, ref: ref2, type: type4 = "API" }, condition) => {
  watch(() => unref(condition), (val) => {
  }, {
    immediate: true
  });
};
const useDraggable = (targetRef, dragRef, draggable) => {
  let transform = {
    offsetX: 0,
    offsetY: 0
  };
  const onMousedown = (e) => {
    const downX = e.clientX;
    const downY = e.clientY;
    const { offsetX, offsetY } = transform;
    const targetRect = targetRef.value.getBoundingClientRect();
    const targetLeft = targetRect.left;
    const targetTop = targetRect.top;
    const targetWidth = targetRect.width;
    const targetHeight = targetRect.height;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const minLeft = -targetLeft + offsetX;
    const minTop = -targetTop + offsetY;
    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
    const maxTop = clientHeight - targetTop - targetHeight + offsetY;
    const onMousemove = (e2) => {
      const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
      const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
      transform = {
        offsetX: moveX,
        offsetY: moveY
      };
      targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
    };
    const onMouseup = () => {
      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onMouseup);
    };
    document.addEventListener("mousemove", onMousemove);
    document.addEventListener("mouseup", onMouseup);
  };
  const onDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.addEventListener("mousedown", onMousedown);
    }
  };
  const offDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.removeEventListener("mousedown", onMousedown);
    }
  };
  onMounted(() => {
    watchEffect(() => {
      if (draggable.value) {
        onDraggable();
      } else {
        offDraggable();
      }
    });
  });
  onBeforeUnmount(() => {
    offDraggable();
  });
};
const defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");
const useId = (deterministicId) => {
  const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection);
  const idRef = computed(() => unref(deterministicId) || `el-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};
const useFormItem = () => {
  const form = inject(formContextKey, void 0);
  const formItem = inject(formItemContextKey, void 0);
  return {
    form,
    formItem
  };
};
const useFormItemInputId = (props, {
  formItemContext,
  disableIdGeneration,
  disableIdManagement
}) => {
  if (!disableIdGeneration) {
    disableIdGeneration = ref(false);
  }
  if (!disableIdManagement) {
    disableIdManagement = ref(false);
  }
  const inputId = ref();
  let idUnwatch = void 0;
  const isLabeledByFormItem = computed(() => {
    var _a2;
    return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
  });
  onMounted(() => {
    idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
      const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
      if (newId !== inputId.value) {
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
          if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
            formItemContext.addInputId(newId);
          }
        }
        inputId.value = newId;
      }
    }, { immediate: true });
  });
  onUnmounted(() => {
    idUnwatch && idUnwatch();
    if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
      inputId.value && formItemContext.removeInputId(inputId.value);
    }
  });
  return {
    isLabeledByFormItem,
    inputId
  };
};
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
const translate = (path, option, locale) => get2(locale, path, path).replace(/\{(\w+)\}/g, (_, key2) => {
  var _a2;
  return `${(_a2 = option == null ? void 0 : option[key2]) != null ? _a2 : `{${key2}}`}`;
});
const buildLocaleContext = (locale) => {
  const lang = computed(() => unref(locale).name);
  const localeRef = isRef(locale) ? locale : ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};
const useLocale = () => {
  const locale = useGlobalConfig("locale");
  return buildLocaleContext(computed(() => locale.value || English));
};
const useLockscreen = (trigger) => {
  if (!isRef(trigger)) {
    throwError("[useLockscreen]", "You need to pass a ref param to this function");
  }
  if (!isClient || hasClass(document.body, "el-popup-parent--hidden")) {
    return;
  }
  let scrollBarWidth2 = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;
  const cleanup = () => {
    removeClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };
  watch(trigger, (val) => {
    if (!val) {
      cleanup();
      return;
    }
    withoutHiddenClass = !hasClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      bodyPaddingRight = document.body.style.paddingRight;
      computedBodyPaddingRight = Number.parseInt(getStyle(document.body, "paddingRight"), 10);
    }
    scrollBarWidth2 = getScrollBarWidth();
    const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
    const bodyOverflowY = getStyle(document.body, "overflowY");
    if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth2}px`;
    }
    addClass(document.body, "el-popup-parent--hidden");
  });
  onScopeDispose(() => cleanup());
};
const _prop = buildProp({
  type: definePropType(Boolean),
  default: null
});
const _event = buildProp({
  type: definePropType(Function)
});
const createModelToggleComposable = (name) => {
  const updateEventKey = `update:${name}`;
  const updateEventKeyRaw = `onUpdate:${name}`;
  const useModelToggleEmits2 = [updateEventKey];
  const useModelToggleProps2 = {
    [name]: _prop,
    [updateEventKeyRaw]: _event
  };
  const useModelToggle2 = ({
    indicator,
    toggleReason,
    shouldHideWhenRouteChanges,
    shouldProceed,
    onShow: onShow2,
    onHide: onHide2
  }) => {
    const instance = getCurrentInstance();
    const { emit } = instance;
    const props = instance.props;
    const hasUpdateHandler = computed(() => isFunction(props[updateEventKeyRaw]));
    const isModelBindingAbsent = computed(() => props[name] === null);
    const doShow = (event) => {
      if (indicator.value === true) {
        return;
      }
      indicator.value = true;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if (isFunction(onShow2)) {
        onShow2(event);
      }
    };
    const doHide = (event) => {
      if (indicator.value === false) {
        return;
      }
      indicator.value = false;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if (isFunction(onHide2)) {
        onHide2(event);
      }
    };
    const show = (event) => {
      if (props.disabled === true || isFunction(shouldProceed) && !shouldProceed())
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, true);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doShow(event);
      }
    };
    const hide2 = (event) => {
      if (props.disabled === true || !isClient)
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, false);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doHide(event);
      }
    };
    const onChange = (val) => {
      if (!isBoolean(val))
        return;
      if (props.disabled && val) {
        if (hasUpdateHandler.value) {
          emit(updateEventKey, false);
        }
      } else if (indicator.value !== val) {
        if (val) {
          doShow();
        } else {
          doHide();
        }
      }
    };
    const toggle = () => {
      if (indicator.value) {
        hide2();
      } else {
        show();
      }
    };
    watch(() => props[name], onChange);
    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
      watch(() => ({
        ...instance.proxy.$route
      }), () => {
        if (shouldHideWhenRouteChanges.value && indicator.value) {
          hide2();
        }
      });
    }
    onMounted(() => {
      onChange(props[name]);
    });
    return {
      hide: hide2,
      show,
      toggle
    };
  };
  return {
    useModelToggle: useModelToggle2,
    useModelToggleProps: useModelToggleProps2,
    useModelToggleEmits: useModelToggleEmits2
  };
};
const useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  watch(() => toggle.value, (val) => {
    var _a2, _b;
    if (val) {
      previousActive = document.activeElement;
      if (isRef(initialFocus)) {
        (_b = (_a2 = initialFocus.value).focus) == null ? void 0 : _b.call(_a2);
      }
    } else {
      {
        previousActive.focus();
      }
    }
  });
};
const useSameTarget = (handleClick) => {
  if (!handleClick) {
    return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
  }
  let mousedownTarget = false;
  let mouseupTarget = false;
  const onClick = (e) => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e);
    }
    mousedownTarget = mouseupTarget = false;
  };
  const onMousedown = (e) => {
    mousedownTarget = e.target === e.currentTarget;
  };
  const onMouseup = (e) => {
    mouseupTarget = e.target === e.currentTarget;
  };
  return { onClick, onMousedown, onMouseup };
};
function useTimeout() {
  let timeoutHandle;
  const registerTimeout = (fn3, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn3, delay);
  };
  const cancelTimeout = () => window.clearTimeout(timeoutHandle);
  tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}
let registeredEscapeHandlers = [];
const useEscapeKeydown = (handler) => {
  const cachedHandler = (e) => {
    const event = e;
    if (event.key === EVENT_CODE.esc) {
      registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
    }
  };
  onMounted(() => {
    if (registeredEscapeHandlers.length === 0) {
      document.addEventListener("keydown", cachedHandler);
    }
    if (isClient)
      registeredEscapeHandlers.push(handler);
  });
  onBeforeUnmount(() => {
    registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
    if (registeredEscapeHandlers.length === 0) {
      if (isClient)
        document.removeEventListener("keydown", cachedHandler);
    }
  });
};
let cachedContainer;
const POPPER_CONTAINER_ID = `el-popper-container-${generateId()}`;
const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
const createContainer = () => {
  const container = document.createElement("div");
  container.id = POPPER_CONTAINER_ID;
  document.body.appendChild(container);
  return container;
};
const usePopperContainer = () => {
  onBeforeMount(() => {
    if (!isClient)
      return;
    if (!cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
      cachedContainer = createContainer();
    }
  });
};
const useDelayedToggleProps = buildProps({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  }
});
const useDelayedToggle = ({
  showAfter,
  hideAfter,
  open,
  close: close6
}) => {
  const { registerTimeout } = useTimeout();
  const onOpen = (event) => {
    registerTimeout(() => {
      open(event);
    }, unref(showAfter));
  };
  const onClose = (event) => {
    registerTimeout(() => {
      close6(event);
    }, unref(hideAfter));
  };
  return {
    onOpen,
    onClose
  };
};
const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
const useForwardRef = (forwardRef) => {
  const setForwardRef = (el) => {
    forwardRef.value = el;
  };
  provide(FORWARD_REF_INJECTION_KEY, {
    setForwardRef
  });
};
const useForwardRefDirective = (setForwardRef) => {
  return {
    mounted(el) {
      setForwardRef(el);
    },
    updated(el) {
      setForwardRef(el);
    },
    unmounted() {
      setForwardRef(null);
    }
  };
};
const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
const useNamespace = (block) => {
  const globalConfig2 = useGlobalConfig("namespace");
  const namespace = computed(() => globalConfig2.value || defaultNamespace);
  const b = (blockSuffix = "") => _bem(unref(namespace), block, blockSuffix, "", "");
  const e = (element) => element ? _bem(unref(namespace), block, "", element, "") : "";
  const m = (modifier) => modifier ? _bem(unref(namespace), block, "", "", modifier) : "";
  const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(unref(namespace), block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(unref(namespace), block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(unref(namespace), block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(unref(namespace), block, blockSuffix, element, modifier) : "";
  const is2 = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };
  const cssVar = (object4) => {
    const styles = {};
    for (const key2 in object4) {
      styles[`--${namespace.value}-${key2}`] = object4[key2];
    }
    return styles;
  };
  const cssVarBlock = (object4) => {
    const styles = {};
    for (const key2 in object4) {
      styles[`--${namespace.value}-${block}-${key2}`] = object4[key2];
    }
    return styles;
  };
  const cssVarName = (name) => `--${namespace.value}-${name}`;
  const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
  return {
    namespace,
    b,
    e,
    m,
    be: be2,
    em,
    bm,
    bem,
    is: is2,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};
const zIndex = ref(0);
const useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
  const nextZIndex = () => {
    zIndex.value++;
    return currentZIndex.value;
  };
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};
function useCursor(input) {
  const selectionRef = ref();
  function recordCursor() {
    if (input.value == void 0)
      return;
    const { selectionStart, selectionEnd, value } = input.value;
    if (selectionStart == null || selectionEnd == null)
      return;
    const beforeTxt = value.slice(0, Math.max(0, selectionStart));
    const afterTxt = value.slice(Math.max(0, selectionEnd));
    selectionRef.value = {
      selectionStart,
      selectionEnd,
      value,
      beforeTxt,
      afterTxt
    };
  }
  function setCursor() {
    if (input.value == void 0 || selectionRef.value == void 0)
      return;
    const { value } = input.value;
    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
    if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
      return;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else {
      const beforeLastChar = beforeTxt[selectionStart - 1];
      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    input.value.setSelectionRange(startPos, startPos);
  }
  return [recordCursor, setCursor];
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});
const __default__$l = {
  name: "ElIcon",
  inheritAttrs: false
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  ...__default__$l,
  props: iconProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("icon");
    const style2 = computed(() => {
      if (!props.size && !props.color)
        return {};
      return {
        fontSize: isUndefined(props.size) ? void 0 : addUnit(props.size),
        "--color": props.color
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", mergeProps({
        class: unref(ns2).b(),
        style: unref(style2)
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default")
      ], 16);
    };
  }
});
var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const ElIcon = withInstall(Icon);
let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style2 = window.getComputedStyle(targetElement);
  const boxSizing = style2.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style2.getPropertyValue("padding-bottom")) + Number.parseFloat(style2.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style2.getPropertyValue("border-bottom-width")) + Number.parseFloat(style2.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style2.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a2;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result2 = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result2.minHeight = `${minHeight}px`;
  }
  if (isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result2.height = `${height}px`;
  (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result2;
}
const inputProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: definePropType([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String,
    default: ""
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: iconPropType,
    default: ""
  },
  prefixIcon: {
    type: iconPropType,
    default: ""
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: definePropType([Object, Array, String]),
    default: () => mutable({})
  }
});
const inputEmits = {
  [UPDATE_MODEL_EVENT]: (value) => isString(value),
  input: (value) => isString(value),
  change: (value) => isString(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: (evt) => evt instanceof MouseEvent,
  mouseenter: (evt) => evt instanceof MouseEvent,
  keydown: (evt) => evt instanceof Event,
  compositionstart: (evt) => evt instanceof CompositionEvent,
  compositionupdate: (evt) => evt instanceof CompositionEvent,
  compositionend: (evt) => evt instanceof CompositionEvent
};
const _hoisted_1$16 = ["role"];
const _hoisted_2$Z = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_3$P = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const __default__$k = {
  name: "ElInput",
  inheritAttrs: false
};
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  ...__default__$k,
  props: inputProps,
  emits: inputEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const PENDANT_MAP = {
      suffix: "append",
      prefix: "prepend"
    };
    const instance = getCurrentInstance();
    const rawAttrs = useAttrs$1();
    const slots = useSlots();
    const containerAttrs = computed(() => {
      const comboBoxAttrs = {};
      if (props.containerRole === "combobox") {
        comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
        comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
        comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
      }
      return comboBoxAttrs;
    });
    const attrs = useAttrs({
      excludeKeys: computed(() => {
        return Object.keys(containerAttrs.value);
      })
    });
    const { form, formItem } = useFormItem();
    const { inputId } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const inputSize = useSize();
    const inputDisabled = useDisabled$1();
    const nsInput = useNamespace("input");
    const nsTextarea = useNamespace("textarea");
    const input = shallowRef();
    const textarea = shallowRef();
    const focused = ref(false);
    const hovering = ref(false);
    const isComposing = ref(false);
    const passwordVisible = ref(false);
    const countStyle = ref();
    const textareaCalcStyle = shallowRef(props.inputStyle);
    const _ref = computed(() => input.value || textarea.value);
    const needStatusIcon = computed(() => {
      var _a2;
      return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
    });
    const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
    const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
    const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
    const containerStyle = computed(() => [
      rawAttrs.style,
      props.inputStyle
    ]);
    const textareaStyle = computed(() => [
      props.inputStyle,
      textareaCalcStyle.value,
      { resize: props.resize }
    ]);
    const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
    const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
    const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || focused.value));
    const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
    const textLength = computed(() => Array.from(nativeInputValue.value).length);
    const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
    const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
    const [recordCursor, setCursor] = useCursor(input);
    useResizeObserver(textarea, (entries) => {
      if (!isWordLimitVisible.value || props.resize !== "both")
        return;
      const entry = entries[0];
      const { width } = entry.contentRect;
      countStyle.value = {
        right: `calc(100% - ${width + 15 + 6}px)`
      };
    });
    const resizeTextarea = () => {
      const { type: type4, autosize } = props;
      if (!isClient || type4 !== "textarea")
        return;
      if (autosize) {
        const minRows = isObject(autosize) ? autosize.minRows : void 0;
        const maxRows = isObject(autosize) ? autosize.maxRows : void 0;
        textareaCalcStyle.value = {
          ...calcTextareaHeight(textarea.value, minRows, maxRows)
        };
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input2 = _ref.value;
      if (!input2 || input2.value === nativeInputValue.value)
        return;
      input2.value = nativeInputValue.value;
    };
    const calcIconOffset = (place) => {
      const { el } = instance.vnode;
      if (!el)
        return;
      const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));
      const target = elList.find((item) => item.parentNode === el);
      if (!target)
        return;
      const pendant = PENDANT_MAP[place];
      if (slots[pendant]) {
        target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };
    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };
    const handleInput = async (event) => {
      recordCursor();
      let { value } = event.target;
      if (props.formatter) {
        value = props.parser ? props.parser(value) : value;
        value = props.formatter(value);
      }
      if (isComposing.value)
        return;
      if (value === nativeInputValue.value)
        return;
      emit(UPDATE_MODEL_EVENT, value);
      emit("input", value);
      await nextTick();
      setNativeInputValue();
      setCursor();
    };
    const handleChange = (event) => {
      emit("change", event.target.value);
    };
    const handleCompositionStart = (event) => {
      emit("compositionstart", event);
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event) => {
      var _a2;
      emit("compositionupdate", event);
      const text3 = (_a2 = event.target) == null ? void 0 : _a2.value;
      const lastCharacter = text3[text3.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event) => {
      emit("compositionend", event);
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus3();
    };
    const focus3 = async () => {
      var _a2;
      await nextTick();
      (_a2 = _ref.value) == null ? void 0 : _a2.focus();
    };
    const blur2 = () => {
      var _a2;
      return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
    };
    const handleFocus = (event) => {
      focused.value = true;
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      focused.value = false;
      emit("blur", event);
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err6) => debugWarn());
      }
    };
    const handleMouseLeave2 = (evt) => {
      hovering.value = false;
      emit("mouseleave", evt);
    };
    const handleMouseEnter = (evt) => {
      hovering.value = true;
      emit("mouseenter", evt);
    };
    const handleKeydown = (evt) => {
      emit("keydown", evt);
    };
    const select = () => {
      var _a2;
      (_a2 = _ref.value) == null ? void 0 : _a2.select();
    };
    const clear = () => {
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };
    watch(() => props.modelValue, () => {
      var _a2;
      nextTick(() => resizeTextarea());
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err6) => debugWarn());
      }
    });
    watch(nativeInputValue, () => setNativeInputValue());
    watch(() => props.type, async () => {
      await nextTick();
      setNativeInputValue();
      resizeTextarea();
      updateIconOffset();
    });
    onMounted(async () => {
      if (!props.formatter && props.parser)
        ;
      setNativeInputValue();
      updateIconOffset();
      await nextTick();
      resizeTextarea();
    });
    onUpdated(async () => {
      await nextTick();
      updateIconOffset();
    });
    expose({
      input,
      textarea,
      ref: _ref,
      textareaStyle,
      autosize: toRef(props, "autosize"),
      focus: focus3,
      blur: blur2,
      select,
      clear,
      resizeTextarea
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
        class: [
          _ctx.type === "textarea" ? unref(nsTextarea).b() : unref(nsInput).b(),
          unref(nsInput).m(unref(inputSize)),
          unref(nsInput).is("disabled", unref(inputDisabled)),
          unref(nsInput).is("exceed", unref(inputExceed)),
          {
            [unref(nsInput).b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
            [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
            [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend,
            [unref(nsInput).m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
            [unref(nsInput).m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
            [unref(nsInput).bm("suffix", "password-clear")]: unref(showClear) && unref(showPwdVisible)
          },
          _ctx.$attrs.class
        ],
        style: unref(containerStyle),
        role: _ctx.containerRole,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave2
      }), [
        createCommentVNode(" input "),
        _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment$6, { key: 0 }, [
          createCommentVNode(" prepend slot "),
          _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(nsInput).be("group", "prepend"))
          }, [
            renderSlot(_ctx.$slots, "prepend")
          ], 2)) : createCommentVNode("v-if", true),
          createElementVNode("div", {
            class: normalizeClass([unref(nsInput).e("wrapper"), unref(nsInput).is("focus", focused.value)])
          }, [
            createCommentVNode(" prefix slot "),
            _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(nsInput).e("prefix"))
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(nsInput).e("prefix-inner"))
              }, [
                renderSlot(_ctx.$slots, "prefix"),
                _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true),
            createElementVNode("input", mergeProps({
              id: unref(inputId),
              ref_key: "input",
              ref: input,
              class: unref(nsInput).e("inner")
            }, unref(attrs), {
              type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
              disabled: unref(inputDisabled),
              formatter: _ctx.formatter,
              parser: _ctx.parser,
              readonly: _ctx.readonly,
              autocomplete: _ctx.autocomplete,
              tabindex: _ctx.tabindex,
              "aria-label": _ctx.label,
              placeholder: _ctx.placeholder,
              style: _ctx.inputStyle,
              onCompositionstart: handleCompositionStart,
              onCompositionupdate: handleCompositionUpdate,
              onCompositionend: handleCompositionEnd,
              onInput: handleInput,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onChange: handleChange,
              onKeydown: handleKeydown
            }), null, 16, _hoisted_2$Z),
            createCommentVNode(" suffix slot "),
            unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(nsInput).e("suffix"))
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(nsInput).e("suffix-inner"))
              }, [
                !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment$6, { key: 0 }, [
                  renderSlot(_ctx.$slots, "suffix"),
                  _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 64)) : createCommentVNode("v-if", true),
                unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                  onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                  onClick: clear
                }, {
                  default: withCtx(() => [
                    createVNode(unref(circle_close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                  onClick: handlePasswordVisible
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass(unref(nsInput).e("count"))
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(nsInput).e("count-inner"))
                  }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                ], 2)) : createCommentVNode("v-if", true),
                unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 4,
                  class: normalizeClass([
                    unref(nsInput).e("icon"),
                    unref(nsInput).e("validateIcon"),
                    unref(nsInput).is("loading", unref(validateState) === "validating")
                  ])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true)
          ], 2),
          createCommentVNode(" append slot "),
          _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(nsInput).be("group", "append"))
          }, [
            renderSlot(_ctx.$slots, "append")
          ], 2)) : createCommentVNode("v-if", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment$6, { key: 1 }, [
          createCommentVNode(" textarea "),
          createElementVNode("textarea", mergeProps({
            id: unref(inputId),
            ref_key: "textarea",
            ref: textarea,
            class: unref(nsTextarea).e("inner")
          }, unref(attrs), {
            tabindex: _ctx.tabindex,
            disabled: unref(inputDisabled),
            readonly: _ctx.readonly,
            autocomplete: _ctx.autocomplete,
            style: unref(textareaStyle),
            "aria-label": _ctx.label,
            placeholder: _ctx.placeholder,
            onCompositionstart: handleCompositionStart,
            onCompositionupdate: handleCompositionUpdate,
            onCompositionend: handleCompositionEnd,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeydown: handleKeydown
          }), null, 16, _hoisted_3$P),
          unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
            key: 0,
            style: normalizeStyle(countStyle.value),
            class: normalizeClass(unref(nsInput).e("count"))
          }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
        ], 64))
      ], 16, _hoisted_1$16)), [
        [vShow, _ctx.type !== "hidden"]
      ]);
    };
  }
});
var Input = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const ElInput = withInstall(Input);
const GAP = 4;
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
const renderThumbStyle = ({
  move: move2,
  size,
  bar
}) => ({
  [bar.size]: size,
  transform: `translate${bar.axis}(${move2}%)`
});
const thumbProps = buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "thumb",
  props: thumbProps,
  setup(__props) {
    const props = __props;
    const COMPONENT_NAME2 = "Thumb";
    const scrollbar = inject(scrollbarContextKey);
    const ns2 = useNamespace("scrollbar");
    if (!scrollbar)
      throwError(COMPONENT_NAME2, "can not inject scrollbar context");
    const instance = ref();
    const thumb = ref();
    const thumbState = ref({});
    const visible = ref(false);
    let cursorDown = false;
    let cursorLeave = false;
    let originalOnSelectStart = isClient ? document.onselectstart : null;
    const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
    const thumbStyle = computed(() => renderThumbStyle({
      size: props.size,
      move: props.move,
      bar: bar.value
    }));
    const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
    const clickThumbHandler = (e) => {
      var _a2;
      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button))
        return;
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
      startDrag(e);
      const el = e.currentTarget;
      if (!el)
        return;
      thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e) => {
      if (!thumb.value || !instance.value || !scrollbar.wrapElement)
        return;
      const offset6 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset6 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const startDrag = (e) => {
      e.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener("mousemove", mouseMoveDocumentHandler);
      document.addEventListener("mouseup", mouseUpDocumentHandler);
      originalOnSelectStart = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e) => {
      if (!instance.value || !thumb.value)
        return;
      if (cursorDown === false)
        return;
      const prevPage = thumbState.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset6 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset6 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown = false;
      thumbState.value[bar.value.axis] = 0;
      document.removeEventListener("mousemove", mouseMoveDocumentHandler);
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave)
        visible.value = false;
    };
    const mouseMoveScrollbarHandler = () => {
      cursorLeave = false;
      visible.value = !!props.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave = true;
      visible.value = cursorDown;
    };
    onBeforeUnmount(() => {
      restoreOnselectstart();
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
    });
    const restoreOnselectstart = () => {
      if (document.onselectstart !== originalOnSelectStart)
        document.onselectstart = originalOnSelectStart;
    };
    useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
    useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: unref(ns2).b("fade"),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            ref_key: "instance",
            ref: instance,
            class: normalizeClass([unref(ns2).e("bar"), unref(ns2).is(unref(bar).key)]),
            onMousedown: clickTrackHandler
          }, [
            createElementVNode("div", {
              ref_key: "thumb",
              ref: thumb,
              class: normalizeClass(unref(ns2).e("thumb")),
              style: normalizeStyle(unref(thumbStyle)),
              onMousedown: clickThumbHandler
            }, null, 38)
          ], 34), [
            [vShow, _ctx.always || visible.value]
          ])
        ]),
        _: 1
      }, 8, ["name"]);
    };
  }
});
var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const barProps = buildProps({
  always: {
    type: Boolean,
    default: true
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
});
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "bar",
  props: barProps,
  setup(__props, { expose }) {
    const props = __props;
    const moveX = ref(0);
    const moveY = ref(0);
    const handleScroll = (wrap2) => {
      if (wrap2) {
        const offsetHeight = wrap2.offsetHeight - GAP;
        const offsetWidth = wrap2.offsetWidth - GAP;
        moveY.value = wrap2.scrollTop * 100 / offsetHeight * props.ratioY;
        moveX.value = wrap2.scrollLeft * 100 / offsetWidth * props.ratioX;
      }
    };
    expose({
      handleScroll
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment$6, null, [
        createVNode(Thumb, {
          move: moveX.value,
          ratio: _ctx.ratioX,
          size: _ctx.width,
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        createVNode(Thumb, {
          move: moveY.value,
          ratio: _ctx.ratioY,
          size: _ctx.height,
          vertical: "",
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ], 64);
    };
  }
});
var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const scrollbarProps = buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: Boolean,
  wrapStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  }
});
const scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => [scrollTop, scrollLeft].every(isNumber)
};
const __default__$j = {
  name: "ElScrollbar"
};
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  ...__default__$j,
  props: scrollbarProps,
  emits: scrollbarEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("scrollbar");
    let stopResizeObserver = void 0;
    let stopResizeListener = void 0;
    const scrollbar$ = ref();
    const wrap$ = ref();
    const resize$ = ref();
    const sizeWidth = ref("0");
    const sizeHeight = ref("0");
    const barRef = ref();
    const ratioY = ref(1);
    const ratioX = ref(1);
    const style2 = computed(() => {
      const style22 = {};
      if (props.height)
        style22.height = addUnit(props.height);
      if (props.maxHeight)
        style22.maxHeight = addUnit(props.maxHeight);
      return [props.wrapStyle, style22];
    });
    const handleScroll = () => {
      var _a2;
      if (wrap$.value) {
        (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
        emit("scroll", {
          scrollTop: wrap$.value.scrollTop,
          scrollLeft: wrap$.value.scrollLeft
        });
      }
    };
    function scrollTo(arg1, arg2) {
      if (isObject(arg1)) {
        wrap$.value.scrollTo(arg1);
      } else if (isNumber(arg1) && isNumber(arg2)) {
        wrap$.value.scrollTo(arg1, arg2);
      }
    }
    const setScrollTop = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollTop = value;
    };
    const setScrollLeft = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollLeft = value;
    };
    const update3 = () => {
      if (!wrap$.value)
        return;
      const offsetHeight = wrap$.value.offsetHeight - GAP;
      const offsetWidth = wrap$.value.offsetWidth - GAP;
      const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
      const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
      const height = Math.max(originalHeight, props.minSize);
      const width = Math.max(originalWidth, props.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
      sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
    };
    watch(() => props.noresize, (noresize) => {
      if (noresize) {
        stopResizeObserver == null ? void 0 : stopResizeObserver();
        stopResizeListener == null ? void 0 : stopResizeListener();
      } else {
        ({ stop: stopResizeObserver } = useResizeObserver(resize$, update3));
        stopResizeListener = useEventListener("resize", update3);
      }
    }, { immediate: true });
    watch(() => [props.maxHeight, props.height], () => {
      if (!props.native)
        nextTick(() => {
          var _a2;
          update3();
          if (wrap$.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
          }
        });
    });
    provide(scrollbarContextKey, reactive({
      scrollbarElement: scrollbar$,
      wrapElement: wrap$
    }));
    onMounted(() => {
      if (!props.native)
        nextTick(() => update3());
    });
    onUpdated(() => update3());
    expose({
      wrap$,
      update: update3,
      scrollTo,
      setScrollTop,
      setScrollLeft,
      handleScroll
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "scrollbar$",
        ref: scrollbar$,
        class: normalizeClass(unref(ns2).b())
      }, [
        createElementVNode("div", {
          ref_key: "wrap$",
          ref: wrap$,
          class: normalizeClass([
            _ctx.wrapClass,
            unref(ns2).e("wrap"),
            { [unref(ns2).em("wrap", "hidden-default")]: !_ctx.native }
          ]),
          style: normalizeStyle(unref(style2)),
          onScroll: handleScroll
        }, [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            ref_key: "resize$",
            ref: resize$,
            class: normalizeClass([unref(ns2).e("view"), _ctx.viewClass]),
            style: normalizeStyle(_ctx.viewStyle)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]))
        ], 38),
        !_ctx.native ? (openBlock(), createBlock(Bar, {
          key: 0,
          ref_key: "barRef",
          ref: barRef,
          height: sizeHeight.value,
          width: sizeWidth.value,
          always: _ctx.always,
          "ratio-x": ratioX.value,
          "ratio-y": ratioY.value
        }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const ElScrollbar = withInstall(Scrollbar);
const usePopperProps = buildProps({
  role: {
    type: String,
    default: "tooltip"
  }
});
const __default__$i = {
  name: "ElPopperRoot",
  inheritAttrs: false
};
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  ...__default__$i,
  props: usePopperProps,
  setup(__props, { expose }) {
    const props = __props;
    const triggerRef = ref();
    const popperInstanceRef = ref();
    const contentRef = ref();
    const referenceRef = ref();
    const role = computed(() => props.role);
    const popperProvides = {
      triggerRef,
      popperInstanceRef,
      contentRef,
      referenceRef,
      role
    };
    expose(popperProvides);
    provide(POPPER_INJECTION_KEY, popperProvides);
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const usePopperArrowProps = buildProps({
  arrowOffset: {
    type: Number,
    default: 5
  }
});
const __default__$h = {
  name: "ElPopperArrow",
  inheritAttrs: false
};
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  ...__default__$h,
  props: usePopperArrowProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("popper");
    const { arrowOffset, arrowRef } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
    watch(() => props.arrowOffset, (val) => {
      arrowOffset.value = val;
    });
    onBeforeUnmount(() => {
      arrowRef.value = void 0;
    });
    expose({
      arrowRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        class: normalizeClass(unref(ns2).e("arrow")),
        "data-popper-arrow": ""
      }, null, 2);
    };
  }
});
var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const NAME = "ElOnlyChild";
const OnlyChild = defineComponent({
  name: NAME,
  setup(_, {
    slots,
    attrs
  }) {
    var _a2;
    const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
    const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
    return () => {
      var _a22;
      const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
      if (!defaultSlot)
        return null;
      if (defaultSlot.length > 1) {
        return null;
      }
      const firstLegitNode = findFirstLegitChild(defaultSlot);
      if (!firstLegitNode) {
        return null;
      }
      return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
    };
  }
});
function findFirstLegitChild(node8) {
  if (!node8)
    return null;
  const children = node8;
  for (const child11 of children) {
    if (isObject(child11)) {
      switch (child11.type) {
        case Comment:
          continue;
        case Text$2:
        case "svg":
          return wrapTextContent(child11);
        case Fragment$6:
          return findFirstLegitChild(child11.children);
        default:
          return child11;
      }
    }
    return wrapTextContent(child11);
  }
  return null;
}
function wrapTextContent(s) {
  return createVNode("span", {
    "class": "el-only-child__content"
  }, [s]);
}
const usePopperTriggerProps = buildProps({
  virtualRef: {
    type: definePropType(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  onBlur: Function,
  onContextmenu: Function,
  id: String,
  open: Boolean
});
const __default__$g = {
  name: "ElPopperTrigger",
  inheritAttrs: false
};
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  ...__default__$g,
  props: usePopperTriggerProps,
  setup(__props, { expose }) {
    const props = __props;
    const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
    useForwardRef(triggerRef);
    const ariaControls = computed(() => {
      return ariaHaspopup.value ? props.id : void 0;
    });
    const ariaDescribedby = computed(() => {
      if (role && role.value === "tooltip") {
        return props.open && props.id ? props.id : void 0;
      }
      return void 0;
    });
    const ariaHaspopup = computed(() => {
      if (role && role.value !== "tooltip") {
        return role.value;
      }
      return void 0;
    });
    const ariaExpanded = computed(() => {
      return ariaHaspopup.value ? `${props.open}` : void 0;
    });
    let virtualTriggerAriaStopWatch = void 0;
    onMounted(() => {
      watch(() => props.virtualRef, (virtualEl) => {
        if (virtualEl) {
          triggerRef.value = unrefElement(virtualEl);
        }
      }, {
        immediate: true
      });
      watch(() => triggerRef.value, (el, prevEl) => {
        virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
        virtualTriggerAriaStopWatch = void 0;
        if (isElement(el)) {
          [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ].forEach((eventName) => {
            var _a2;
            const handler = props[eventName];
            if (handler) {
              el.addEventListener(eventName.slice(2).toLowerCase(), handler);
              (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
            }
          });
          virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
            [
              "aria-controls",
              "aria-describedby",
              "aria-haspopup",
              "aria-expanded"
            ].forEach((key2, idx) => {
              isNil(watches[idx]) ? el.removeAttribute(key2) : el.setAttribute(key2, watches[idx]);
            });
          }, { immediate: true });
        }
        if (isElement(prevEl)) {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((key2) => prevEl.removeAttribute(key2));
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
      virtualTriggerAriaStopWatch = void 0;
    });
    expose({
      triggerRef
    });
    return (_ctx, _cache) => {
      return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
        "aria-controls": unref(ariaControls),
        "aria-describedby": unref(ariaDescribedby),
        "aria-expanded": unref(ariaExpanded),
        "aria-haspopup": unref(ariaHaspopup)
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
    };
  }
});
var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
  return t.concat([e + "-" + U, e + "-" + J]);
}, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
  return t.concat([e, e + "-" + U, e + "-" + J]);
}, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
function C(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function H(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Q(t) {
  var e = H(t).Element;
  return t instanceof e || t instanceof Element;
}
function B(t) {
  var e = H(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Pe(t) {
  if (typeof ShadowRoot == "undefined")
    return false;
  var e = H(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function Mt(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
    !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
      var s = o[a];
      s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
    }));
  });
}
function Rt(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
        return f[c] = "", f;
      }, {});
      !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
        o.removeAttribute(f);
      }));
    });
  };
}
var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
function q(t) {
  return t.split("-")[0];
}
var X = Math.max, ve = Math.min, Z = Math.round;
function ee(t, e) {
  e === void 0 && (e = false);
  var n = t.getBoundingClientRect(), r = 1, o = 1;
  if (B(t) && e) {
    var i = t.offsetHeight, a = t.offsetWidth;
    a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
  }
  return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
}
function ke(t) {
  var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function it(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return true;
  if (n && Pe(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return true;
      r = r.parentNode || r.host;
    } while (r);
  }
  return false;
}
function N(t) {
  return H(t).getComputedStyle(t);
}
function Wt(t) {
  return ["table", "td", "th"].indexOf(C(t)) >= 0;
}
function I(t) {
  return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function ge(t) {
  return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
}
function at(t) {
  return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
}
function Bt(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && B(t)) {
    var r = N(t);
    if (r.position === "fixed")
      return null;
  }
  var o = ge(t);
  for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
    var i = N(o);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return o;
    o = o.parentNode;
  }
  return null;
}
function se(t) {
  for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
    n = at(n);
  return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
}
function Le(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fe(t, e, n) {
  return X(t, ve(e, n));
}
function St(t, e, n) {
  var r = fe(t, e, n);
  return r > n ? n : r;
}
function st() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function ft(t) {
  return Object.assign({}, st(), t);
}
function ct(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var Tt = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
};
function Ht(t) {
  var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
  if (!(!i || !a)) {
    var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
    n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
  }
}
function Ct(t) {
  var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
}
var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function te(t) {
  return t.split("-")[1];
}
var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Vt(t) {
  var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
  return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
}
function ut(t) {
  var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p }) : { x: l, y: p };
  l = g.x, p = g.y;
  var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
  if (c) {
    var w = se(n), O = "clientHeight", j = "clientWidth";
    if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
      d = R;
      var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
      p -= A - r.height, p *= f ? 1 : -1;
    }
    if (o === P || (o === E || o === R) && i === J) {
      $ = W;
      var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
      l -= k - r.width, l *= f ? 1 : -1;
    }
  }
  var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p }) : { x: l, y: p };
  if (l = S.x, p = S.y, f) {
    var L;
    return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p + "px)" : "translate3d(" + l + "px, " + p + "px, 0)", L));
  }
  return Object.assign({}, D, (e = {}, e[d] = y ? p + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
}
function Nt(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
function It(t) {
  var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, ye);
  }), s && f.addEventListener("resize", n.update, ye), function() {
    i && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, ye);
    }), s && f.removeEventListener("resize", n.update, ye);
  };
}
var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
}, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
function be(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return _t[e];
  });
}
var zt = { start: "end", end: "start" };
function lt(t) {
  return t.replace(/start|end/g, function(e) {
    return zt[e];
  });
}
function We(t) {
  var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function Be(t) {
  return ee(I(t)).left + We(t).scrollLeft;
}
function Ft(t) {
  var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
  return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
}
function Ut(t) {
  var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
  return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
}
function Se(t) {
  var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function dt(t) {
  return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
}
function ce(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
  return o ? s : s.concat(ce(ge(a)));
}
function Te(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function Xt(t) {
  var e = ee(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function ht(t, e) {
  return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
}
function Yt(t) {
  var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
  return Q(r) ? e.filter(function(o) {
    return Q(o) && it(o, r) && C(o) !== "body";
  }) : [];
}
function Gt(t, e, n) {
  var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
    var c = ht(t, f);
    return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
  }, ht(t, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function mt(t) {
  var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
  switch (o) {
    case E:
      f = { x: a, y: e.y - n.height };
      break;
    case R:
      f = { x: a, y: e.y + e.height };
      break;
    case W:
      f = { x: e.x + e.width, y: s };
      break;
    case P:
      f = { x: e.x - n.width, y: s };
      break;
    default:
      f = { x: e.x, y: e.y };
  }
  var c = o ? Le(o) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (i) {
      case U:
        f[c] = f[c] - (e[u] / 2 - n[u] / 2);
        break;
      case J:
        f[c] = f[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return f;
}
function ne(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p.top, bottom: O.bottom - $.bottom + p.bottom, left: $.left - O.left + p.left, right: O.right - $.right + p.right }, A = t.modifiersData.offset;
  if (u === K && A) {
    var k = A[o];
    Object.keys(j).forEach(function(D) {
      var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
      j[D] += k[L] * S;
    });
  }
  return j;
}
function Jt(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
    return te(h2) === u;
  }) : G, v = m.filter(function(h2) {
    return c.indexOf(h2) >= 0;
  });
  v.length === 0 && (v = m);
  var l = v.reduce(function(h2, p) {
    return h2[p] = ne(t, { placement: p, boundary: o, rootBoundary: i, padding: a })[q(p)], h2;
  }, {});
  return Object.keys(l).sort(function(h2, p) {
    return l[h2] - l[p];
  });
}
function Kt(t) {
  if (q(t) === me)
    return [];
  var e = be(t);
  return [lt(t), e, lt(e)];
}
function Qt(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
      return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p }) : V);
    }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
      var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
      b[oe] > w[oe] && (T = be(T));
      var pe = be(T), _ = [];
      if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
        return z;
      })) {
        A = D, j = false;
        break;
      }
      O.set(D, _);
    }
    if (j)
      for (var ue = h2 ? 3 : 1, xe = function(z) {
        var V = d.find(function(de) {
          var ae = O.get(de);
          if (ae)
            return ae.slice(0, z).every(function(Y) {
              return Y;
            });
        });
        if (V)
          return A = V, "break";
      }, ie2 = ue; ie2 > 0; ie2--) {
        var le = xe(ie2);
        if (le === "break")
          break;
      }
    e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
  }
}
var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
function gt(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function yt(t) {
  return [E, W, R, P].some(function(e) {
    return t[e] >= 0;
  });
}
function Zt(t) {
  var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
  e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
}
var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
function en(t, e, n) {
  var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
  return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
}
function tn(t) {
  var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
    return u[m] = en(m, e.rects, i), u;
  }, {}), s = a[e.placement], f = s.x, c = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
}
var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
function nn(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
function rn(t) {
  return t === "x" ? "y" : "x";
}
function on(t) {
  var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p == "function" ? p(Object.assign({}, e.rects, { placement: e.placement })) : p, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
  if (w) {
    if (i) {
      var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie2 = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie2 + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
      w[d] = qe, S[d] = qe - T;
    }
    if (s) {
      var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
      w[b] = Ue, S[b] = Ue - F;
    }
    e.modifiersData[r] = S;
  }
}
var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
function an(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function sn(t) {
  return t === H(t) || !B(t) ? We(t) : an(t);
}
function fn2(t) {
  var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function cn(t, e, n) {
  n === void 0 && (n = false);
  var r = B(e), o = B(e) && fn2(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
  return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
}
function pn(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(i) {
    e.set(i.name, i);
  });
  function o(i) {
    n.add(i.name);
    var a = [].concat(i.requires || [], i.requiresIfExists || []);
    a.forEach(function(s) {
      if (!n.has(s)) {
        var f = e.get(s);
        f && o(f);
      }
    }), r.push(i);
  }
  return t.forEach(function(i) {
    n.has(i.name) || o(i);
  }), r;
}
function un(t) {
  var e = pn(t);
  return ot.reduce(function(n, r) {
    return n.concat(e.filter(function(o) {
      return o.phase === r;
    }));
  }, []);
}
function ln(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function dn(t) {
  var e = t.reduce(function(n, r) {
    var o = n[r.name];
    return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
function $t() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function we(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
  return function(a, s, f) {
    f === void 0 && (f = i);
    var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p) {
      var g = typeof p == "function" ? p(c.options) : p;
      h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
      var x = un(dn([].concat(r, c.options.modifiers)));
      return c.orderedModifiers = x.filter(function(y) {
        return y.enabled;
      }), l(), v.update();
    }, forceUpdate: function() {
      if (!m) {
        var p = c.elements, g = p.reference, x = p.popper;
        if ($t(g, x)) {
          c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
            return c.modifiersData[j.name] = Object.assign({}, j.data);
          });
          for (var y = 0; y < c.orderedModifiers.length; y++) {
            if (c.reset === true) {
              c.reset = false, y = -1;
              continue;
            }
            var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
            typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
          }
        }
      }
    }, update: ln(function() {
      return new Promise(function(p) {
        v.forceUpdate(), p(c);
      });
    }), destroy: function() {
      h2(), m = true;
    } };
    if (!$t(a, s))
      return v;
    v.setOptions(f).then(function(p) {
      !m && f.onFirstUpdate && f.onFirstUpdate(p);
    });
    function l() {
      c.orderedModifiers.forEach(function(p) {
        var g = p.name, x = p.options, y = x === void 0 ? {} : x, $ = p.effect;
        if (typeof $ == "function") {
          var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
          };
          u.push(d || b);
        }
      });
    }
    function h2() {
      u.forEach(function(p) {
        return p();
      }), u = [];
    }
    return v;
  };
}
we();
var mn = [Re, He, Me, Ae];
we({ defaultModifiers: mn });
var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
const obtainAllFocusableElements = (element) => {
  const nodes = [];
  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node8) => {
      const isHiddenInput = node8.tagName === "INPUT" && node8.type === "hidden";
      if (node8.disabled || node8.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node8.tabIndex >= 0 || node8 === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
};
const getVisibleElement = (elements, container) => {
  for (const element of elements) {
    if (!isHidden(element, container))
      return element;
  }
};
const isHidden = (element, container) => {
  if (getComputedStyle(element).visibility === "hidden")
    return true;
  while (element) {
    if (container && element === container)
      return false;
    if (getComputedStyle(element).display === "none")
      return true;
    element = element.parentElement;
  }
  return false;
};
const getEdges = (container) => {
  const focusable = obtainAllFocusableElements(container);
  const first2 = getVisibleElement(focusable, container);
  const last = getVisibleElement(focusable.reverse(), container);
  return [first2, last];
};
const isSelectable = (element) => {
  return element instanceof HTMLInputElement && "select" in element;
};
const tryFocus = (element, shouldSelect) => {
  if (element && element.focus) {
    const prevFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
      element.select();
    }
  }
};
function removeFromStack(list, item) {
  const copy12 = [...list];
  const idx = list.indexOf(item);
  if (idx !== -1) {
    copy12.splice(idx, 1);
  }
  return copy12;
}
const createFocusableStack = () => {
  let stack = [];
  const push = (layer) => {
    const currentLayer = stack[0];
    if (currentLayer && layer !== currentLayer) {
      currentLayer.pause();
    }
    stack = removeFromStack(stack, layer);
    stack.unshift(layer);
  };
  const remove2 = (layer) => {
    var _a2, _b;
    stack = removeFromStack(stack, layer);
    (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
  };
  return {
    push,
    remove: remove2
  };
};
const focusFirstDescendant = (elements, shouldSelect = false) => {
  const prevFocusedElement = document.activeElement;
  for (const element of elements) {
    tryFocus(element, shouldSelect);
    if (document.activeElement !== prevFocusedElement)
      return;
  }
};
const focusableStack = createFocusableStack();
const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
const FOCUS_AFTER_TRAPPED_OPTS = {
  cancelable: true,
  bubbles: false
};
const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
const _sfc_main$Q = defineComponent({
  name: "ElFocusTrap",
  inheritAttrs: false,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    ON_TRAP_FOCUS_EVT,
    ON_RELEASE_FOCUS_EVT,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(props, { emit }) {
    const forwardRef = ref();
    let lastFocusBeforeTrapped;
    let lastFocusAfterTrapped;
    useEscapeKeydown((event) => {
      if (props.trapped && !focusLayer.paused) {
        emit("release-requested", event);
      }
    });
    const focusLayer = {
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    };
    const onKeydown = (e) => {
      if (!props.loop && !props.trapped)
        return;
      if (focusLayer.paused)
        return;
      const { key: key2, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
      const { loop } = props;
      const isTabbing = key2 === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
      const currentFocusingEl = document.activeElement;
      if (isTabbing && currentFocusingEl) {
        const container = currentTarget;
        const [first2, last] = getEdges(container);
        const isTabbable = first2 && last;
        if (!isTabbable) {
          if (currentFocusingEl === container) {
            e.preventDefault();
            emit("focusout-prevented");
          }
        } else {
          if (!shiftKey && currentFocusingEl === last) {
            e.preventDefault();
            if (loop)
              tryFocus(first2, true);
            emit("focusout-prevented");
          } else if (shiftKey && [first2, container].includes(currentFocusingEl)) {
            e.preventDefault();
            if (loop)
              tryFocus(last, true);
            emit("focusout-prevented");
          }
        }
      }
    };
    provide(FOCUS_TRAP_INJECTION_KEY, {
      focusTrapRef: forwardRef,
      onKeydown
    });
    watch(() => props.focusTrapEl, (focusTrapEl) => {
      if (focusTrapEl) {
        forwardRef.value = focusTrapEl;
      }
    }, { immediate: true });
    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
      if (forwardRef2) {
        forwardRef2.addEventListener("keydown", onKeydown);
        forwardRef2.addEventListener("focusin", onFocusIn);
        forwardRef2.addEventListener("focusout", onFocusOut);
      }
      if (oldForwardRef) {
        oldForwardRef.removeEventListener("keydown", onKeydown);
        oldForwardRef.removeEventListener("focusin", onFocusIn);
        oldForwardRef.removeEventListener("focusout", onFocusOut);
      }
    });
    const trapOnFocus = (e) => {
      emit(ON_TRAP_FOCUS_EVT, e);
    };
    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
    const onFocusIn = (e) => {
      const trapContainer = unref(forwardRef);
      if (!trapContainer)
        return;
      const target = e.target;
      const isFocusedInTrap = target && trapContainer.contains(target);
      if (isFocusedInTrap)
        emit("focusin", e);
      if (focusLayer.paused)
        return;
      if (props.trapped) {
        if (isFocusedInTrap) {
          lastFocusAfterTrapped = target;
        } else {
          tryFocus(lastFocusAfterTrapped, true);
        }
      }
    };
    const onFocusOut = (e) => {
      const trapContainer = unref(forwardRef);
      if (focusLayer.paused || !trapContainer)
        return;
      if (props.trapped) {
        const relatedTarget = e.relatedTarget;
        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
          setTimeout(() => {
            if (!focusLayer.paused && props.trapped) {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }, 0);
        }
      } else {
        const target = e.target;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!isFocusedInTrap)
          emit("focusout", e);
      }
    };
    async function startTrap() {
      await nextTick();
      const trapContainer = unref(forwardRef);
      if (trapContainer) {
        focusableStack.push(focusLayer);
        const prevFocusedElement = document.activeElement;
        lastFocusBeforeTrapped = prevFocusedElement;
        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
        if (!isPrevFocusContained) {
          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
          trapContainer.dispatchEvent(focusEvent);
          if (!focusEvent.defaultPrevented) {
            nextTick(() => {
              let focusStartEl = props.focusStartEl;
              if (!isString(focusStartEl)) {
                tryFocus(focusStartEl);
                if (document.activeElement !== focusStartEl) {
                  focusStartEl = "first";
                }
              }
              if (focusStartEl === "first") {
                focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
              }
              if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                tryFocus(trapContainer);
              }
            });
          }
        }
      }
    }
    function stopTrap() {
      const trapContainer = unref(forwardRef);
      if (trapContainer) {
        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
        const releasedEvent = new Event(FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED_OPTS);
        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
        trapContainer.dispatchEvent(releasedEvent);
        if (!releasedEvent.defaultPrevented) {
          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body, true);
        }
        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
        focusableStack.remove(focusLayer);
      }
    }
    onMounted(() => {
      if (props.trapped) {
        startTrap();
      }
      watch(() => props.trapped, (trapped) => {
        if (trapped) {
          startTrap();
        } else {
          stopTrap();
        }
      });
    });
    onBeforeUnmount(() => {
      if (props.trapped) {
        stopTrap();
      }
    });
    return {
      onKeydown
    };
  }
});
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
}
var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$A], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const POSITIONING_STRATEGIES = ["fixed", "absolute"];
const usePopperCoreConfigProps = buildProps({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: () => []
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Ee,
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: POSITIONING_STRATEGIES,
    default: "absolute"
  }
});
const usePopperContentProps = buildProps({
  ...usePopperCoreConfigProps,
  id: String,
  style: { type: definePropType([String, Array, Object]) },
  className: { type: definePropType([String, Array, Object]) },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: false
  },
  trapping: {
    type: Boolean,
    default: false
  },
  popperClass: {
    type: definePropType([String, Array, Object])
  },
  popperStyle: {
    type: definePropType([String, Array, Object])
  },
  referenceEl: {
    type: definePropType(Object)
  },
  triggerTargetEl: {
    type: definePropType(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
});
const usePopperContentEmits = [
  "mouseenter",
  "mouseleave",
  "focus",
  "blur",
  "close"
];
const buildPopperOptions = (props, arrowProps) => {
  const { placement, strategy, popperOptions } = props;
  const options = {
    placement,
    strategy,
    ...popperOptions,
    modifiers: genModifiers(props)
  };
  attachArrow(options, arrowProps);
  deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
  return options;
};
const unwrapMeasurableEl = ($el) => {
  if (!isClient)
    return;
  return unrefElement($el);
};
function genModifiers(options) {
  const { offset: offset6, gpuAcceleration, fallbackPlacements } = options;
  return [
    {
      name: "offset",
      options: {
        offset: [0, offset6 != null ? offset6 : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
}
function attachArrow(options, { arrowEl, arrowOffset }) {
  options.modifiers.push({
    name: "arrow",
    options: {
      element: arrowEl,
      padding: arrowOffset != null ? arrowOffset : 5
    }
  });
}
function deriveExtraModifiers(options, modifiers2) {
  if (modifiers2) {
    options.modifiers = [...options.modifiers, ...modifiers2 != null ? modifiers2 : []];
  }
}
const __default__$f = {
  name: "ElPopperContent"
};
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  ...__default__$f,
  props: usePopperContentProps,
  emits: usePopperContentEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
    const formItemContext = inject(formItemContextKey, void 0);
    const { nextZIndex } = useZIndex();
    const ns2 = useNamespace("popper");
    const popperContentRef = ref();
    const focusStartRef = ref("first");
    const arrowRef = ref();
    const arrowOffset = ref();
    provide(POPPER_CONTENT_INJECTION_KEY, {
      arrowRef,
      arrowOffset
    });
    if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
      provide(formItemContextKey, {
        ...formItemContext,
        addInputId: NOOP,
        removeInputId: NOOP
      });
    }
    const contentZIndex = ref(props.zIndex || nextZIndex());
    const trapped = ref(false);
    let triggerTargetAriaStopWatch = void 0;
    const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
    const contentStyle = computed(() => [{ zIndex: unref(contentZIndex) }, props.popperStyle]);
    const contentClass = computed(() => [
      ns2.b(),
      ns2.is("pure", props.pure),
      ns2.is(props.effect),
      props.popperClass
    ]);
    const ariaModal = computed(() => {
      return role && role.value === "dialog" ? "false" : void 0;
    });
    const createPopperInstance = ({ referenceEl, popperContentEl, arrowEl }) => {
      const options = buildPopperOptions(props, {
        arrowEl,
        arrowOffset: unref(arrowOffset)
      });
      return yn(referenceEl, popperContentEl, options);
    };
    const updatePopper = (shouldUpdateZIndex = true) => {
      var _a2;
      (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.update();
      shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());
    };
    const togglePopperAlive = () => {
      var _a2, _b;
      const monitorable = { name: "eventListeners", enabled: props.visible };
      (_b = (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.setOptions) == null ? void 0 : _b.call(_a2, (options) => ({
        ...options,
        modifiers: [...options.modifiers || [], monitorable]
      }));
      updatePopper(false);
      if (props.visible && props.focusOnShow) {
        trapped.value = true;
      } else if (props.visible === false) {
        trapped.value = false;
      }
    };
    const onFocusAfterTrapped = () => {
      emit("focus");
    };
    const onFocusAfterReleased = () => {
      focusStartRef.value = "first";
      emit("blur");
    };
    const onFocusInTrap = (event) => {
      var _a2;
      if (props.visible && !trapped.value) {
        if (event.relatedTarget) {
          (_a2 = event.relatedTarget) == null ? void 0 : _a2.focus();
        }
        if (event.target) {
          focusStartRef.value = event.target;
        }
        trapped.value = true;
      }
    };
    const onFocusoutPrevented = () => {
      if (!props.trapping) {
        trapped.value = false;
      }
    };
    const onReleaseRequested = () => {
      trapped.value = false;
      emit("close");
    };
    onMounted(() => {
      let updateHandle2;
      watch(computedReference, (referenceEl) => {
        var _a2;
        updateHandle2 == null ? void 0 : updateHandle2();
        const popperInstance = unref(popperInstanceRef);
        (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
        if (referenceEl) {
          const popperContentEl = unref(popperContentRef);
          contentRef.value = popperContentEl;
          popperInstanceRef.value = createPopperInstance({
            referenceEl,
            popperContentEl,
            arrowEl: unref(arrowRef)
          });
          updateHandle2 = watch(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
            immediate: true
          });
        } else {
          popperInstanceRef.value = void 0;
        }
      }, {
        immediate: true
      });
      watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
        triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
        triggerTargetAriaStopWatch = void 0;
        const el = unref(triggerTargetEl || popperContentRef.value);
        const prevEl = unref(prevTriggerTargetEl || popperContentRef.value);
        if (isElement(el)) {
          const { ariaLabel, id } = toRefs(props);
          triggerTargetAriaStopWatch = watch([role, ariaLabel, ariaModal, id], (watches) => {
            ["role", "aria-label", "aria-modal", "id"].forEach((key2, idx) => {
              isNil(watches[idx]) ? el.removeAttribute(key2) : el.setAttribute(key2, watches[idx]);
            });
          }, { immediate: true });
        }
        if (isElement(prevEl)) {
          ["role", "aria-label", "aria-modal", "id"].forEach((key2) => {
            prevEl.removeAttribute(key2);
          });
        }
      }, { immediate: true });
      watch(() => props.visible, togglePopperAlive, { immediate: true });
      watch(() => buildPopperOptions(props, {
        arrowEl: unref(arrowRef),
        arrowOffset: unref(arrowOffset)
      }), (option) => {
        var _a2;
        return (_a2 = popperInstanceRef.value) == null ? void 0 : _a2.setOptions(option);
      });
    });
    onBeforeUnmount(() => {
      triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
      triggerTargetAriaStopWatch = void 0;
    });
    expose({
      popperContentRef,
      popperInstanceRef,
      updatePopper,
      contentStyle
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "popperContentRef",
        ref: popperContentRef,
        style: normalizeStyle(unref(contentStyle)),
        class: normalizeClass(unref(contentClass)),
        tabindex: "-1",
        onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
        onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
      }, [
        createVNode(unref(ElFocusTrap), {
          trapped: trapped.value,
          "trap-on-focus-in": true,
          "focus-trap-el": popperContentRef.value,
          "focus-start-el": focusStartRef.value,
          onFocusAfterTrapped,
          onFocusAfterReleased,
          onFocusin: onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el"])
      ], 38);
    };
  }
});
var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const ElPopper = withInstall(Popper);
const ns = useNamespace("tooltip");
const useTooltipContentProps = buildProps({
  ...useDelayedToggleProps,
  ...usePopperContentProps,
  appendTo: {
    type: definePropType([String, Object]),
    default: POPPER_CONTAINER_SELECTOR
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: false
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: definePropType(Boolean),
    default: null
  },
  transition: {
    type: String,
    default: `${ns.namespace.value}-fade-in-linear`
  },
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean
  }
});
const useTooltipTriggerProps = buildProps({
  ...usePopperTriggerProps,
  disabled: Boolean,
  trigger: {
    type: definePropType([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: definePropType(Array),
    default: () => [EVENT_CODE.enter, EVENT_CODE.space]
  }
});
const useTooltipProps = buildProps({
  openDelay: {
    type: Number
  },
  visibleArrow: {
    type: Boolean,
    default: void 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  showArrow: {
    type: Boolean,
    default: true
  }
});
const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
const _sfc_main$O = defineComponent({
  name: "ElTooltipContent",
  components: {
    ElPopperContent
  },
  inheritAttrs: false,
  props: useTooltipContentProps,
  setup(props) {
    const contentRef = ref(null);
    const intermediateOpen = ref(false);
    const entering = ref(false);
    const leaving = ref(false);
    const destroyed = ref(false);
    const {
      controlled,
      id,
      open,
      trigger,
      onClose,
      onOpen,
      onShow: onShow2,
      onHide: onHide2,
      onBeforeShow,
      onBeforeHide
    } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = computed(() => {
      return props.persistent;
    });
    onBeforeUnmount(() => {
      destroyed.value = true;
    });
    const shouldRender = computed(() => {
      return unref(persistentRef) ? true : unref(open);
    });
    const shouldShow = computed(() => {
      return props.disabled ? false : unref(open);
    });
    const contentStyle = computed(() => {
      var _a2;
      return (_a2 = props.style) != null ? _a2 : {};
    });
    const ariaHidden = computed(() => !unref(open));
    const onTransitionLeave = () => {
      onHide2();
    };
    const stopWhenControlled = () => {
      if (unref(controlled))
        return true;
    };
    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable && unref(trigger) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if (unref(trigger) === "hover") {
        onClose();
      }
    });
    const onBeforeEnter = () => {
      var _a2, _b;
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      onBeforeShow == null ? void 0 : onBeforeShow();
    };
    const onBeforeLeave = () => {
      onBeforeHide == null ? void 0 : onBeforeHide();
    };
    const onAfterShow = () => {
      onShow2();
      stopHandle = onClickOutside2(computed(() => {
        var _a2;
        return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
      }), () => {
        if (unref(controlled))
          return;
        const $trigger = unref(trigger);
        if ($trigger !== "hover") {
          onClose();
        }
      });
    };
    const onBlur = () => {
      if (!props.virtualTriggering) {
        onClose();
      }
    };
    let stopHandle;
    watch(() => unref(open), (val) => {
      if (!val) {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      destroyed,
      shouldRender,
      shouldShow,
      onClose,
      open,
      onAfterShow,
      onBeforeEnter,
      onBeforeLeave,
      onContentEnter,
      onContentLeave,
      onTransitionLeave,
      onBlur
    };
  }
});
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_content = resolveComponent("el-popper-content");
  return openBlock(), createBlock(Teleport, {
    disabled: !_ctx.teleported,
    to: _ctx.appendTo
  }, [
    createVNode(Transition, {
      name: _ctx.transition,
      onAfterLeave: _ctx.onTransitionLeave,
      onBeforeEnter: _ctx.onBeforeEnter,
      onAfterEnter: _ctx.onAfterShow,
      onBeforeLeave: _ctx.onBeforeLeave
    }, {
      default: withCtx(() => [
        _ctx.shouldRender ? withDirectives((openBlock(), createBlock(_component_el_popper_content, mergeProps({
          key: 0,
          id: _ctx.id,
          ref: "contentRef"
        }, _ctx.$attrs, {
          "aria-label": _ctx.ariaLabel,
          "aria-hidden": _ctx.ariaHidden,
          "boundaries-padding": _ctx.boundariesPadding,
          "fallback-placements": _ctx.fallbackPlacements,
          "gpu-acceleration": _ctx.gpuAcceleration,
          offset: _ctx.offset,
          placement: _ctx.placement,
          "popper-options": _ctx.popperOptions,
          strategy: _ctx.strategy,
          effect: _ctx.effect,
          enterable: _ctx.enterable,
          pure: _ctx.pure,
          "popper-class": _ctx.popperClass,
          "popper-style": [_ctx.popperStyle, _ctx.contentStyle],
          "reference-el": _ctx.referenceEl,
          "trigger-target-el": _ctx.triggerTargetEl,
          visible: _ctx.shouldShow,
          "z-index": _ctx.zIndex,
          onMouseenter: _ctx.onContentEnter,
          onMouseleave: _ctx.onContentLeave,
          onBlur: _ctx.onBlur,
          onClose: _ctx.onClose
        }), {
          default: withCtx(() => [
            createCommentVNode(" Workaround bug #6378 "),
            !_ctx.destroyed ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onBlur", "onClose"])), [
          [vShow, _ctx.shouldShow]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"])
  ], 8, ["disabled", "to"]);
}
var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$z], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const isTriggerType = (trigger, type4) => {
  if (isArray(trigger)) {
    return trigger.includes(type4);
  }
  return trigger === type4;
};
const whenTrigger = (trigger, type4, handler) => {
  return (e) => {
    isTriggerType(unref(trigger), type4) && handler(e);
  };
};
const _sfc_main$N = defineComponent({
  name: "ElTooltipTrigger",
  components: {
    ElPopperTrigger
  },
  props: useTooltipTriggerProps,
  setup(props) {
    const ns2 = useNamespace("tooltip");
    const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const triggerRef = ref(null);
    const stopWhenControlledOrDisabled = () => {
      if (unref(controlled) || props.disabled) {
        return true;
      }
    };
    const trigger = toRef(props, "trigger");
    const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
    const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
    const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
      if (e.button === 0) {
        onToggle(e);
      }
    }));
    const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
    const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
    const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
      e.preventDefault();
      onToggle(e);
    }));
    const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
      const { code: code2 } = e;
      if (props.triggerKeys.includes(code2)) {
        e.preventDefault();
        onToggle(e);
      }
    });
    return {
      onBlur,
      onContextMenu,
      onFocus,
      onMouseenter,
      onMouseleave,
      onClick,
      onKeydown,
      open,
      id,
      triggerRef,
      ns: ns2
    };
  }
});
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_trigger = resolveComponent("el-popper-trigger");
  return openBlock(), createBlock(_component_el_popper_trigger, {
    id: _ctx.id,
    "virtual-ref": _ctx.virtualRef,
    open: _ctx.open,
    "virtual-triggering": _ctx.virtualTriggering,
    class: normalizeClass(_ctx.ns.e("trigger")),
    onBlur: _ctx.onBlur,
    onClick: _ctx.onClick,
    onContextmenu: _ctx.onContextMenu,
    onFocus: _ctx.onFocus,
    onMouseenter: _ctx.onMouseenter,
    onMouseleave: _ctx.onMouseleave,
    onKeydown: _ctx.onKeydown
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
}
var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$y], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const { useModelToggleProps, useModelToggle, useModelToggleEmits } = createModelToggleComposable("visible");
const _sfc_main$M = defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper,
    ElPopperArrow,
    ElTooltipContent,
    ElTooltipTrigger
  },
  props: {
    ...usePopperProps,
    ...useModelToggleProps,
    ...useTooltipContentProps,
    ...useTooltipTriggerProps,
    ...usePopperArrowProps,
    ...useTooltipProps
  },
  emits: [
    ...useModelToggleEmits,
    "before-show",
    "before-hide",
    "show",
    "hide",
    "open",
    "close"
  ],
  setup(props, { emit }) {
    usePopperContainer();
    const compatShowAfter = computed(() => {
      if (!isUndefined(props.openDelay))
        ;
      return props.openDelay || props.showAfter;
    });
    const compatShowArrow = computed(() => {
      if (!isUndefined(props.visibleArrow))
        ;
      return isBoolean(props.visibleArrow) ? props.visibleArrow : props.showArrow;
    });
    const id = useId();
    const popperRef = ref(null);
    const contentRef = ref(null);
    const updatePopper = () => {
      var _a2;
      const popperComponent = unref(popperRef);
      if (popperComponent) {
        (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
      }
    };
    const open = ref(false);
    const toggleReason = ref(void 0);
    const { show, hide: hide2 } = useModelToggle({
      indicator: open,
      toggleReason
    });
    const { onOpen, onClose } = useDelayedToggle({
      showAfter: compatShowAfter,
      hideAfter: toRef(props, "hideAfter"),
      open: show,
      close: hide2
    });
    const controlled = computed(() => isBoolean(props.visible));
    provide(TOOLTIP_INJECTION_KEY, {
      controlled,
      id,
      open: readonly(open),
      trigger: toRef(props, "trigger"),
      onOpen: (event) => {
        onOpen(event);
      },
      onClose: (event) => {
        onClose(event);
      },
      onToggle: (event) => {
        if (unref(open)) {
          onClose(event);
        } else {
          onOpen(event);
        }
      },
      onShow: () => {
        emit("show", toggleReason.value);
      },
      onHide: () => {
        emit("hide", toggleReason.value);
      },
      onBeforeShow: () => {
        emit("before-show", toggleReason.value);
      },
      onBeforeHide: () => {
        emit("before-hide", toggleReason.value);
      },
      updatePopper
    });
    watch(() => props.disabled, (disabled) => {
      if (disabled && open.value) {
        open.value = false;
      }
    });
    const isFocusInsideContent = () => {
      var _a2, _b;
      const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
      return popperContent && popperContent.contains(document.activeElement);
    };
    onDeactivated(() => open.value && hide2());
    return {
      compatShowAfter,
      compatShowArrow,
      popperRef,
      contentRef,
      open,
      hide: hide2,
      isFocusInsideContent,
      updatePopper,
      onOpen,
      onClose
    };
  }
});
const _hoisted_1$15 = ["innerHTML"];
const _hoisted_2$Y = { key: 1 };
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip_trigger = resolveComponent("el-tooltip-trigger");
  const _component_el_popper_arrow = resolveComponent("el-popper-arrow");
  const _component_el_tooltip_content = resolveComponent("el-tooltip-content");
  const _component_el_popper = resolveComponent("el-popper");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popperRef",
    role: _ctx.role
  }, {
    default: withCtx(() => [
      createVNode(_component_el_tooltip_trigger, {
        disabled: _ctx.disabled,
        trigger: _ctx.trigger,
        "trigger-keys": _ctx.triggerKeys,
        "virtual-ref": _ctx.virtualRef,
        "virtual-triggering": _ctx.virtualTriggering
      }, {
        default: withCtx(() => [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
      createVNode(_component_el_tooltip_content, {
        ref: "contentRef",
        "aria-label": _ctx.ariaLabel,
        "boundaries-padding": _ctx.boundariesPadding,
        content: _ctx.content,
        disabled: _ctx.disabled,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "fallback-placements": _ctx.fallbackPlacements,
        "hide-after": _ctx.hideAfter,
        "gpu-acceleration": _ctx.gpuAcceleration,
        offset: _ctx.offset,
        persistent: _ctx.persistent,
        "popper-class": _ctx.popperClass,
        "popper-style": _ctx.popperStyle,
        placement: _ctx.placement,
        "popper-options": _ctx.popperOptions,
        pure: _ctx.pure,
        "raw-content": _ctx.rawContent,
        "reference-el": _ctx.referenceEl,
        "trigger-target-el": _ctx.triggerTargetEl,
        "show-after": _ctx.compatShowAfter,
        strategy: _ctx.strategy,
        teleported: _ctx.teleported,
        transition: _ctx.transition,
        "virtual-triggering": _ctx.virtualTriggering,
        "z-index": _ctx.zIndex,
        "append-to": _ctx.appendTo
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content", {}, () => [
            _ctx.rawContent ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: _ctx.content
            }, null, 8, _hoisted_1$15)) : (openBlock(), createElementBlock("span", _hoisted_2$Y, toDisplayString(_ctx.content), 1))
          ]),
          _ctx.compatShowArrow ? (openBlock(), createBlock(_component_el_popper_arrow, {
            key: 0,
            "arrow-offset": _ctx.arrowOffset
          }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
    ]),
    _: 3
  }, 8, ["role"]);
}
var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$x], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const ElTooltip = withInstall(Tooltip);
const buttonTypes = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
const buttonNativeTypes = ["button", "submit", "reset"];
const buttonProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonTypes,
    default: ""
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  nativeType: {
    type: String,
    values: buttonNativeTypes,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: iconPropType,
    default: () => loading_default
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
const buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};
function bound01(n, max7) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max7 === 360 ? n : Math.min(max7, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max7), 10) / 100;
  }
  if (Math.abs(n - max7) < 1e-6) {
    return 1;
  }
  if (max7 === 360) {
    n = (n < 0 ? n % max7 + max7 : n % max7) / parseFloat(String(max7));
  } else {
    n = n % max7 / parseFloat(String(max7));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max7 = Math.max(r, g, b);
  var min7 = Math.min(r, g, b);
  var h2 = 0;
  var s = 0;
  var l = (max7 + min7) / 2;
  if (max7 === min7) {
    s = 0;
    h2 = 0;
  } else {
    var d = max7 - min7;
    s = l > 0.5 ? d / (2 - max7 - min7) : d / (max7 + min7);
    switch (max7) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
function hue2rgb(p, q2, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q2 - p) * (6 * t);
  }
  if (t < 1 / 2) {
    return q2;
  }
  if (t < 2 / 3) {
    return p + (q2 - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h2, s, l) {
  var r;
  var g;
  var b;
  h2 = bound01(h2, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q2;
    r = hue2rgb(p, q2, h2 + 1 / 3);
    g = hue2rgb(p, q2, h2);
    b = hue2rgb(p, q2, h2 - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max7 = Math.max(r, g, b);
  var min7 = Math.min(r, g, b);
  var h2 = 0;
  var v = max7;
  var d = max7 - min7;
  var s = max7 === 0 ? 0 : d / max7;
  if (max7 === min7) {
    h2 = 0;
  } else {
    switch (max7) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, v };
}
function hsvToRgb(h2, s, v) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h2);
  var f = h2 - i;
  var p = v * (1 - s);
  var q2 = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q2, p, p, t, v][mod];
  var g = [t, v, v, q2, p, p][mod];
  var b = [p, p, t, v, v, q2][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex2 = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex2 = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok5 = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok5 = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok5 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok5 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok5,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
  function TinyColor2(color, opts) {
    if (color === void 0) {
      color = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r = Math.round(this.r);
    var g = Math.round(this.g);
    var b = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x) {
      return "".concat(Math.round(bound01(x, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x) {
      return Math.round(bound01(x, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
      var _b = _a2[_i], key2 = _b[0], value = _b[1];
      if (hex2 === value) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s = hsv.s;
    var v = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s, v }));
      v = (v + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result2 = [this];
    var increment = 360 / n;
    for (var i = 1; i < n; i++) {
      result2.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result2;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();
function darken(color, amount = 20) {
  return color.mix("#141414", amount).toString();
}
function useButtonCustomStyle(props) {
  const _disabled = useDisabled$1();
  const ns2 = useNamespace("button");
  return computed(() => {
    let styles = {};
    const buttonColor = props.color;
    if (buttonColor) {
      const color = new TinyColor(buttonColor);
      const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
      if (props.plain) {
        styles = ns2.cssVarBlock({
          "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
          "text-color": buttonColor,
          "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
          "hover-text-color": `var(${ns2.cssVarName("color-white")})`,
          "hover-bg-color": buttonColor,
          "hover-border-color": buttonColor,
          "active-bg-color": activeBgColor,
          "active-text-color": `var(${ns2.cssVarName("color-white")})`,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          styles[ns2.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
        }
      } else {
        const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
        const textColor = color.isDark() ? `var(${ns2.cssVarName("color-white")})` : `var(${ns2.cssVarName("color-black")})`;
        styles = ns2.cssVarBlock({
          "bg-color": buttonColor,
          "text-color": textColor,
          "border-color": buttonColor,
          "hover-bg-color": hoverBgColor,
          "hover-text-color": textColor,
          "hover-border-color": hoverBgColor,
          "active-bg-color": activeBgColor,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns2.cssVarName("color-white")})`;
          styles[ns2.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
        }
      }
    }
    return styles;
  });
}
const _hoisted_1$14 = ["aria-disabled", "disabled", "autofocus", "type"];
const __default__$e = {
  name: "ElButton"
};
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  ...__default__$e,
  props: buttonProps,
  emits: buttonEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots = useSlots();
    useDeprecated({
      from: "type.text",
      replacement: "type.link",
      version: "3.0.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, computed(() => props.type === "text"));
    const buttonGroupContext = inject(buttonGroupContextKey, void 0);
    const globalConfig2 = useGlobalConfig("button");
    const ns2 = useNamespace("button");
    const { form } = useFormItem();
    const _size = useSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
    const _disabled = useDisabled$1();
    const _ref = ref();
    const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
    const autoInsertSpace = computed(() => {
      var _a2, _b, _c;
      return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
    });
    const shouldAddSpace = computed(() => {
      var _a2;
      const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
        const slot = defaultSlot[0];
        if ((slot == null ? void 0 : slot.type) === Text$2) {
          const text3 = slot.children;
          return /^\p{Unified_Ideograph}{2}$/u.test(text3.trim());
        }
      }
      return false;
    });
    const buttonStyle = useButtonCustomStyle(props);
    const handleClick = (evt) => {
      if (props.nativeType === "reset") {
        form == null ? void 0 : form.resetFields();
      }
      emit("click", evt);
    };
    expose({
      ref: _ref,
      size: _size,
      type: _type,
      disabled: _disabled,
      shouldAddSpace
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        ref_key: "_ref",
        ref: _ref,
        class: normalizeClass([
          unref(ns2).b(),
          unref(ns2).m(unref(_type)),
          unref(ns2).m(unref(_size)),
          unref(ns2).is("disabled", unref(_disabled)),
          unref(ns2).is("loading", _ctx.loading),
          unref(ns2).is("plain", _ctx.plain),
          unref(ns2).is("round", _ctx.round),
          unref(ns2).is("circle", _ctx.circle),
          unref(ns2).is("text", _ctx.text),
          unref(ns2).is("link", _ctx.link),
          unref(ns2).is("has-bg", _ctx.bg)
        ]),
        "aria-disabled": unref(_disabled) || _ctx.loading,
        disabled: unref(_disabled) || _ctx.loading,
        autofocus: _ctx.autofocus,
        type: _ctx.nativeType,
        style: normalizeStyle(unref(buttonStyle)),
        onClick: handleClick
      }, [
        _ctx.loading ? (openBlock(), createElementBlock(Fragment$6, { key: 0 }, [
          _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
            key: 1,
            class: normalizeClass(unref(ns2).is("loading"))
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
          default: withCtx(() => [
            _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : createCommentVNode("v-if", true),
        _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass({ [unref(ns2).em("text", "expand")]: unref(shouldAddSpace) })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)) : createCommentVNode("v-if", true)
      ], 14, _hoisted_1$14);
    };
  }
});
var Button$1 = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};
const __default__$d = {
  name: "ElButtonGroup"
};
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  ...__default__$d,
  props: buttonGroupProps,
  setup(__props) {
    const props = __props;
    provide(buttonGroupContextKey, reactive({
      size: toRef(props, "size"),
      type: toRef(props, "type")
    }));
    const ns2 = useNamespace("button");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(`${unref(ns2).b("group")}`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const ElButton = withInstall(Button$1, {
  ButtonGroup
});
withNoopInstall(ButtonGroup);
const FOCUSABLE_CHILDREN = "_trap-focus-children";
const FOCUS_STACK = [];
const FOCUS_HANDLER = (e) => {
  if (FOCUS_STACK.length === 0)
    return;
  const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
  if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
    if (focusableElement.length === 1) {
      e.preventDefault();
      if (document.activeElement !== focusableElement[0]) {
        focusableElement[0].focus();
      }
      return;
    }
    const goingBackward = e.shiftKey;
    const isFirst = e.target === focusableElement[0];
    const isLast = e.target === focusableElement[focusableElement.length - 1];
    if (isFirst && goingBackward) {
      e.preventDefault();
      focusableElement[focusableElement.length - 1].focus();
    }
    if (isLast && !goingBackward) {
      e.preventDefault();
      focusableElement[0].focus();
    }
  }
};
const TrapFocus = {
  beforeMount(el) {
    el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
    FOCUS_STACK.push(el);
    if (FOCUS_STACK.length <= 1) {
      on$1(document, "keydown", FOCUS_HANDLER);
    }
  },
  updated(el) {
    nextTick(() => {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
    });
  },
  unmounted() {
    FOCUS_STACK.shift();
    if (FOCUS_STACK.length === 0) {
      off(document, "keydown", FOCUS_HANDLER);
    }
  }
};
const useCheckboxGroupProps = {
  modelValue: {
    type: Array,
    default: () => []
  },
  disabled: Boolean,
  min: {
    type: Number,
    default: void 0
  },
  max: {
    type: Number,
    default: void 0
  },
  size: useSizeProp,
  id: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  fill: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: void 0
  },
  tag: {
    type: String,
    default: "div"
  }
};
const checkboxProps = {
  modelValue: {
    type: [Number, String, Boolean],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: useSizeProp,
  tabindex: [String, Number]
};
const useCheckboxGroup = () => {
  const elForm2 = inject(formContextKey, {});
  const elFormItem2 = inject(formItemContextKey, {});
  const checkboxGroup = inject("CheckboxGroup", {});
  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = computed(() => {
    return elFormItem2.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm: elForm2,
    elFormItemSize,
    elFormItem: elFormItem2
  };
};
const useCheckboxGroupId = (props, { elFormItem: elFormItem2 }) => {
  const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
    formItemContext: elFormItem2
  });
  return {
    isLabeledByFormItem,
    groupId
  };
};
const useModel = (props) => {
  const selfModel = ref(false);
  const { emit } = getCurrentInstance();
  const { isGroup, checkboxGroup, elFormItem: elFormItem2 } = useCheckboxGroup();
  const isLimitExceeded = ref(false);
  const model = computed({
    get() {
      var _a2, _b;
      return isGroup.value ? (_a2 = checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
    },
    set(val) {
      var _a2;
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;
        isLimitExceeded.value === false && ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a2.call(checkboxGroup, val));
      } else {
        emit(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isGroup,
    isLimitExceeded,
    elFormItem: elFormItem2
  };
};
const useCheckboxStatus = (props, slots, { model }) => {
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const focus3 = ref(false);
  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, { prop: true });
  const isChecked = computed(() => {
    const value = model.value;
    if (toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props.label);
    } else if (value !== null && value !== void 0) {
      return value === props.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = useSize(computed(() => {
    var _a2;
    return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a2.value : void 0;
  }));
  const hasOwnLabel = computed(() => {
    return !!(slots.default || props.label);
  });
  return {
    isChecked,
    focus: focus3,
    size,
    checkboxSize,
    hasOwnLabel
  };
};
const useDisabled = (props, {
  model,
  isChecked
}) => {
  const { elForm: elForm2, isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitDisabled = computed(() => {
    var _a2, _b;
    const max7 = (_a2 = checkboxGroup.max) == null ? void 0 : _a2.value;
    const min7 = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
    return !!(max7 || min7) && model.value.length >= max7 && !isChecked.value || model.value.length <= min7 && isChecked.value;
  });
  const isDisabled = computed(() => {
    var _a2, _b;
    const disabled = props.disabled || (elForm2 == null ? void 0 : elForm2.disabled);
    return (_b = isGroup.value ? ((_a2 = checkboxGroup.disabled) == null ? void 0 : _a2.value) || disabled || isLimitDisabled.value : disabled) != null ? _b : false;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props.label)) {
      model.value.push(props.label);
    } else {
      model.value = props.trueLabel || true;
    }
  }
  props.checked && addToStore();
};
const useEvent = (props, {
  model,
  isLimitExceeded,
  hasOwnLabel,
  isDisabled,
  isLabeledByFormItem
}) => {
  const { elFormItem: elFormItem2 } = useCheckboxGroup();
  const { emit } = getCurrentInstance();
  function getLabeledValue(value) {
    var _a2, _b;
    return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
  }
  function emitChangeEvent(checked, e) {
    emit("change", getLabeledValue(checked), e);
  }
  function handleChange(e) {
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    emit("change", getLabeledValue(target.checked), e);
  }
  async function onClickRoot(e) {
    if (isLimitExceeded.value)
      return;
    if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
      model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
      await nextTick();
      emitChangeEvent(model.value, e);
    }
  }
  watch(() => props.modelValue, () => {
    var _a2;
    (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err6) => debugWarn());
  });
  return {
    handleChange,
    onClickRoot
  };
};
const checkboxEmits = {
  [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
  change: (val) => isString(val) || isNumber(val) || isBoolean(val)
};
const checkboxGroupEmits = {
  [UPDATE_MODEL_EVENT]: (val) => isArray(val),
  change: (val) => isArray(val)
};
const useCheckbox = (props, slots) => {
  const { model, isGroup, isLimitExceeded, elFormItem: elFormItem2 } = useModel(props);
  const { focus: focus3, size, isChecked, checkboxSize, hasOwnLabel } = useCheckboxStatus(props, slots, {
    model
  });
  const { isDisabled } = useDisabled(props, { model, isChecked });
  const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
    formItemContext: elFormItem2,
    disableIdGeneration: hasOwnLabel,
    disableIdManagement: isGroup
  });
  const { handleChange, onClickRoot } = useEvent(props, {
    model,
    isLimitExceeded,
    hasOwnLabel,
    isDisabled,
    isLabeledByFormItem
  });
  setStoreValue(props, { model });
  return {
    elFormItem: elFormItem2,
    inputId,
    isLabeledByFormItem,
    isChecked,
    isDisabled,
    isGroup,
    checkboxSize,
    hasOwnLabel,
    model,
    handleChange,
    onClickRoot,
    focus: focus3,
    size
  };
};
const _hoisted_1$13 = ["tabindex", "role", "aria-checked"];
const _hoisted_2$X = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_3$O = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
const __default__$c = {
  name: "ElCheckbox"
};
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  ...__default__$c,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const {
      inputId,
      isLabeledByFormItem,
      isChecked,
      isDisabled,
      checkboxSize,
      hasOwnLabel,
      model,
      handleChange,
      onClickRoot,
      focus: focus3
    } = useCheckbox(props, slots);
    const ns2 = useNamespace("checkbox");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
        class: normalizeClass([
          unref(ns2).b(),
          unref(ns2).m(unref(checkboxSize)),
          unref(ns2).is("disabled", unref(isDisabled)),
          unref(ns2).is("bordered", _ctx.border),
          unref(ns2).is("checked", unref(isChecked))
        ]),
        "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
        onClick: unref(onClickRoot)
      }, {
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass([
              unref(ns2).e("input"),
              unref(ns2).is("disabled", unref(isDisabled)),
              unref(ns2).is("checked", unref(isChecked)),
              unref(ns2).is("indeterminate", _ctx.indeterminate),
              unref(ns2).is("focus", unref(focus3))
            ]),
            tabindex: _ctx.indeterminate ? 0 : void 0,
            role: _ctx.indeterminate ? "checkbox" : void 0,
            "aria-checked": _ctx.indeterminate ? "mixed" : void 0
          }, [
            _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              id: unref(inputId),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref(isDisabled),
              "true-value": _ctx.trueLabel,
              "false-value": _ctx.falseLabel,
              onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[2] || (_cache[2] = ($event) => focus3.value = true),
              onBlur: _cache[3] || (_cache[3] = ($event) => focus3.value = false)
            }, null, 42, _hoisted_2$X)), [
              [vModelCheckbox, unref(model)]
            ]) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              id: unref(inputId),
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              disabled: unref(isDisabled),
              value: _ctx.label,
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[6] || (_cache[6] = ($event) => focus3.value = true),
              onBlur: _cache[7] || (_cache[7] = ($event) => focus3.value = false)
            }, null, 42, _hoisted_3$O)), [
              [vModelCheckbox, unref(model)]
            ]),
            createElementVNode("span", {
              class: normalizeClass(unref(ns2).e("inner"))
            }, null, 2)
          ], 10, _hoisted_1$13),
          unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(ns2).e("label"))
          }, [
            renderSlot(_ctx.$slots, "default"),
            !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment$6, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64)) : createCommentVNode("v-if", true)
          ], 2)) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]);
    };
  }
});
var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const _hoisted_1$12 = ["name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_2$W = ["name", "tabindex", "disabled", "value"];
const __default__$b = {
  name: "ElCheckboxButton"
};
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  ...__default__$b,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const { focus: focus3, isChecked, isDisabled, size, model, handleChange } = useCheckbox(props, slots);
    const { checkboxGroup } = useCheckboxGroup();
    const ns2 = useNamespace("checkbox");
    const activeStyle = computed(() => {
      var _a2, _b, _c, _d;
      const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass([
          unref(ns2).b("button"),
          unref(ns2).bm("button", unref(size)),
          unref(ns2).is("disabled", unref(isDisabled)),
          unref(ns2).is("checked", unref(isChecked)),
          unref(ns2).is("focus", unref(focus3))
        ])
      }, [
        _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
          key: 0,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
          class: normalizeClass(unref(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: unref(isDisabled),
          "true-value": _ctx.trueLabel,
          "false-value": _ctx.falseLabel,
          onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
          onFocus: _cache[2] || (_cache[2] = ($event) => focus3.value = true),
          onBlur: _cache[3] || (_cache[3] = ($event) => focus3.value = false)
        }, null, 42, _hoisted_1$12)), [
          [vModelCheckbox, unref(model)]
        ]) : withDirectives((openBlock(), createElementBlock("input", {
          key: 1,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
          class: normalizeClass(unref(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: unref(isDisabled),
          value: _ctx.label,
          onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
          onFocus: _cache[6] || (_cache[6] = ($event) => focus3.value = true),
          onBlur: _cache[7] || (_cache[7] = ($event) => focus3.value = false)
        }, null, 42, _hoisted_2$W)), [
          [vModelCheckbox, unref(model)]
        ]),
        _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(unref(ns2).be("button", "inner")),
          style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 6)) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const __default__$a = {
  name: "ElCheckboxGroup"
};
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  ...__default__$a,
  props: useCheckboxGroupProps,
  emits: checkboxGroupEmits,
  setup(__props, { emit }) {
    const props = __props;
    const { elFormItem: elFormItem2 } = useCheckboxGroup();
    const { groupId, isLabeledByFormItem } = useCheckboxGroupId(props, {
      elFormItem: elFormItem2
    });
    const checkboxGroupSize = useSize();
    const ns2 = useNamespace("checkbox");
    const changeEvent = (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      nextTick(() => {
        emit("change", value);
      });
    };
    const modelValue = computed({
      get() {
        return props.modelValue;
      },
      set(val) {
        changeEvent(val);
      }
    });
    provide("CheckboxGroup", {
      name: "ElCheckboxGroup",
      modelValue,
      ...toRefs(props),
      checkboxGroupSize,
      changeEvent
    });
    watch(() => props.modelValue, () => {
      var _a2;
      (_a2 = elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err6) => debugWarn());
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        id: unref(groupId),
        class: normalizeClass(unref(ns2).b("group")),
        role: "group",
        "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
        "aria-labelledby": unref(isLabeledByFormItem) ? unref(elFormItem2).labelId : void 0
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const ElCheckbox = withInstall(Checkbox, {
  CheckboxButton,
  CheckboxGroup
});
withNoopInstall(CheckboxButton);
withNoopInstall(CheckboxGroup);
const overlayProps = buildProps({
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: {
    type: Boolean,
    default: false
  },
  overlayClass: {
    type: definePropType([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: definePropType([String, Number])
  }
});
const overlayEmits = {
  click: (evt) => evt instanceof MouseEvent
};
var Overlay = defineComponent({
  name: "ElOverlay",
  props: overlayProps,
  emits: overlayEmits,
  setup(props, { slots, emit }) {
    const ns2 = useNamespace("overlay");
    const onMaskClick = (e) => {
      emit("click", e);
    };
    const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
    return () => {
      return props.mask ? createVNode("div", {
        class: [ns2.b(), props.overlayClass],
        style: {
          zIndex: props.zIndex
        },
        onClick,
        onMousedown,
        onMouseup
      }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
        class: props.overlayClass,
        style: {
          zIndex: props.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [renderSlot(slots, "default")]);
    };
  }
});
const ElOverlay = Overlay;
const dialogContentProps = buildProps({
  center: {
    type: Boolean,
    default: false
  },
  closeIcon: {
    type: iconPropType,
    default: ""
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: {
    type: Boolean,
    default: false
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  }
});
const dialogContentEmits = {
  close: () => true
};
const _hoisted_1$11 = ["aria-label"];
const _hoisted_2$V = ["id"];
const __default__$9 = { name: "ElDialogContent" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  ...__default__$9,
  props: dialogContentProps,
  emits: dialogContentEmits,
  setup(__props) {
    const props = __props;
    const { t } = useLocale();
    const { Close } = CloseComponents;
    const { dialogRef, headerRef, bodyId, ns: ns2, style: style2 } = inject(dialogInjectionKey);
    const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
    const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
    const draggable = computed(() => props.draggable);
    useDraggable(dialogRef, headerRef, draggable);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref: unref(composedDialogRef),
        class: normalizeClass([
          unref(ns2).b(),
          unref(ns2).is("fullscreen", _ctx.fullscreen),
          unref(ns2).is("draggable", unref(draggable)),
          { [unref(ns2).m("center")]: _ctx.center },
          _ctx.customClass
        ]),
        style: normalizeStyle(unref(style2)),
        tabindex: "-1",
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["stop"]))
      }, [
        createElementVNode("header", {
          ref_key: "headerRef",
          ref: headerRef,
          class: normalizeClass(unref(ns2).e("header"))
        }, [
          renderSlot(_ctx.$slots, "header", {}, () => [
            createElementVNode("span", {
              role: "heading",
              class: normalizeClass(unref(ns2).e("title"))
            }, toDisplayString(_ctx.title), 3)
          ]),
          _ctx.showClose ? (openBlock(), createElementBlock("button", {
            key: 0,
            "aria-label": unref(t)("el.dialog.close"),
            class: normalizeClass(unref(ns2).e("headerbtn")),
            type: "button",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
          }, [
            createVNode(unref(ElIcon), {
              class: normalizeClass(unref(ns2).e("close"))
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
              ]),
              _: 1
            }, 8, ["class"])
          ], 10, _hoisted_1$11)) : createCommentVNode("v-if", true)
        ], 2),
        createElementVNode("div", {
          id: unref(bodyId),
          class: normalizeClass(unref(ns2).e("body"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_2$V),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
          key: 0,
          class: normalizeClass(unref(ns2).e("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true)
      ], 6);
    };
  }
});
var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const dialogProps = buildProps({
  ...dialogContentProps,
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: definePropType(Function)
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: false
  }
});
const dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
  openAutoFocus: () => true,
  closeAutoFocus: () => true
};
const useDialog = (props, targetRef) => {
  const instance = getCurrentInstance();
  const emit = instance.emit;
  const { nextZIndex } = useZIndex();
  let lastPosition = "";
  const titleId = useId();
  const bodyId = useId();
  const visible = ref(false);
  const closed = ref(false);
  const rendered = ref(false);
  const zIndex2 = ref(props.zIndex || nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const style2 = computed(() => {
    const style22 = {};
    const varPrefix = `--${namespace.value}-dialog`;
    if (!props.fullscreen) {
      if (props.top) {
        style22[`${varPrefix}-margin-top`] = props.top;
      }
      if (props.width) {
        style22[`${varPrefix}-width`] = addUnit(props.width);
      }
    }
    return style22;
  });
  function afterEnter() {
    emit("opened");
  }
  function afterLeave() {
    emit("closed");
    emit(UPDATE_MODEL_EVENT, false);
    if (props.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    emit("close");
  }
  function open() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();
    if (props.openDelay && props.openDelay > 0) {
      ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
    } else {
      doOpen();
    }
  }
  function close6() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();
    if (props.closeDelay && props.closeDelay > 0) {
      ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
    } else {
      doClose();
    }
  }
  function handleClose() {
    function hide2(shouldCancel) {
      if (shouldCancel)
        return;
      closed.value = true;
      visible.value = false;
    }
    if (props.beforeClose) {
      props.beforeClose(hide2);
    } else {
      close6();
    }
  }
  function onModalClick() {
    if (props.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (!isClient)
      return;
    visible.value = true;
  }
  function doClose() {
    visible.value = false;
  }
  function onOpenAutoFocus() {
    emit("openAutoFocus");
  }
  function onCloseAutoFocus() {
    emit("closeAutoFocus");
  }
  if (props.lockScroll) {
    useLockscreen(visible);
  }
  function onCloseRequested() {
    if (props.closeOnPressEscape) {
      handleClose();
    }
  }
  watch(() => props.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true;
      emit("open");
      zIndex2.value = props.zIndex ? zIndex2.value++ : nextZIndex();
      nextTick(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close6();
      }
    }
  });
  watch(() => props.fullscreen, (val) => {
    if (!targetRef.value)
      return;
    if (val) {
      lastPosition = targetRef.value.style.transform;
      targetRef.value.style.transform = "";
    } else {
      targetRef.value.style.transform = lastPosition;
    }
  });
  onMounted(() => {
    if (props.modelValue) {
      visible.value = true;
      rendered.value = true;
      open();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick,
    close: close6,
    doClose,
    onOpenAutoFocus,
    onCloseAutoFocus,
    onCloseRequested,
    titleId,
    bodyId,
    closed,
    style: style2,
    rendered,
    visible,
    zIndex: zIndex2
  };
};
const _hoisted_1$10 = ["aria-label", "aria-labelledby", "aria-describedby"];
const __default__$8 = {
  name: "ElDialog"
};
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  ...__default__$8,
  props: dialogProps,
  emits: dialogEmits,
  setup(__props, { expose }) {
    const props = __props;
    const slots = useSlots();
    useDeprecated({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, computed(() => !!slots.title));
    const ns2 = useNamespace("dialog");
    const dialogRef = ref();
    const headerRef = ref();
    const dialogContentRef = ref();
    const {
      visible,
      titleId,
      bodyId,
      style: style2,
      rendered,
      zIndex: zIndex2,
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      onModalClick,
      onOpenAutoFocus,
      onCloseAutoFocus,
      onCloseRequested
    } = useDialog(props, dialogRef);
    provide(dialogInjectionKey, {
      dialogRef,
      headerRef,
      bodyId,
      ns: ns2,
      rendered,
      style: style2
    });
    const overlayEvent = useSameTarget(onModalClick);
    const draggable = computed(() => props.draggable && !props.fullscreen);
    expose({
      visible,
      dialogContentRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
      }, [
        createVNode(Transition, {
          name: "dialog-fade",
          onAfterEnter: unref(afterEnter),
          onAfterLeave: unref(afterLeave),
          onBeforeLeave: unref(beforeLeave),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(unref(ElOverlay), {
              "custom-mask-event": "",
              mask: _ctx.modal,
              "overlay-class": _ctx.modalClass,
              "z-index": unref(zIndex2)
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  role: "dialog",
                  "aria-modal": "true",
                  "aria-label": _ctx.title || void 0,
                  "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                  "aria-describedby": unref(bodyId),
                  class: normalizeClass(`${unref(ns2).namespace.value}-overlay-dialog`),
                  onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                  onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                  onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                }, [
                  createVNode(unref(ElFocusTrap), {
                    loop: "",
                    trapped: unref(visible),
                    "focus-start-el": "container",
                    onFocusAfterTrapped: unref(onOpenAutoFocus),
                    onFocusAfterReleased: unref(onCloseAutoFocus),
                    onReleaseRequested: unref(onCloseRequested)
                  }, {
                    default: withCtx(() => [
                      unref(rendered) ? (openBlock(), createBlock(ElDialogContent, {
                        key: 0,
                        ref_key: "dialogContentRef",
                        ref: dialogContentRef,
                        "custom-class": _ctx.customClass,
                        center: _ctx.center,
                        "close-icon": _ctx.closeIcon,
                        draggable: unref(draggable),
                        fullscreen: _ctx.fullscreen,
                        "show-close": _ctx.showClose,
                        style: normalizeStyle(unref(style2)),
                        title: _ctx.title,
                        onClose: unref(handleClose)
                      }, createSlots({
                        header: withCtx(() => [
                          !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                            key: 0,
                            close: unref(handleClose),
                            titleId: unref(titleId),
                            titleClass: unref(ns2).e("title")
                          }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                        ]),
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 2
                      }, [
                        _ctx.$slots.footer ? {
                          name: "footer",
                          fn: withCtx(() => [
                            renderSlot(_ctx.$slots, "footer")
                          ])
                        } : void 0
                      ]), 1032, ["custom-class", "center", "close-icon", "draggable", "fullscreen", "show-close", "style", "title", "onClose"])) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onReleaseRequested"])
                ], 42, _hoisted_1$10)
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index"]), [
              [vShow, unref(visible)]
            ])
          ]),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ], 8, ["disabled"]);
    };
  }
});
var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const ElDialog = withInstall(Dialog);
const _sfc_main$E = {
  inheritAttrs: false
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var Collection = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$w], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const _sfc_main$D = {
  name: "ElCollectionItem",
  inheritAttrs: false
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var CollectionItem = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$v], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
const createCollectionWithScope = (name) => {
  const COLLECTION_NAME = `El${name}Collection`;
  const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
  const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
  const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
  const ElCollection2 = {
    ...Collection,
    name: COLLECTION_NAME,
    setup() {
      const collectionRef = ref(null);
      const itemMap = /* @__PURE__ */ new Map();
      const getItems = () => {
        const collectionEl = unref(collectionRef);
        if (!collectionEl)
          return [];
        const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
        const items = [...itemMap.values()];
        return items.sort((a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref));
      };
      provide(COLLECTION_INJECTION_KEY2, {
        itemMap,
        getItems,
        collectionRef
      });
    }
  };
  const ElCollectionItem2 = {
    ...CollectionItem,
    name: COLLECTION_ITEM_NAME,
    setup(_, { attrs }) {
      const collectionItemRef = ref(null);
      const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
      provide(COLLECTION_ITEM_INJECTION_KEY2, {
        collectionItemRef
      });
      onMounted(() => {
        const collectionItemEl = unref(collectionItemRef);
        if (collectionItemEl) {
          collectionInjection.itemMap.set(collectionItemEl, {
            ref: collectionItemEl,
            ...attrs
          });
        }
      });
      onBeforeUnmount(() => {
        const collectionItemEl = unref(collectionItemRef);
        collectionInjection.itemMap.delete(collectionItemEl);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
    COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
    ElCollection: ElCollection2,
    ElCollectionItem: ElCollectionItem2
  };
};
const rovingFocusGroupProps = buildProps({
  style: { type: definePropType([String, Array, Object]) },
  currentTabId: {
    type: definePropType(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: definePropType(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
});
const {
  ElCollection: ElCollection$1,
  ElCollectionItem: ElCollectionItem$1,
  COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
  COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
} = createCollectionWithScope("RovingFocusGroup");
const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
const getDirectionAwareKey = (key2, dir) => {
  if (dir !== "rtl")
    return key2;
  switch (key2) {
    case EVENT_CODE.right:
      return EVENT_CODE.left;
    case EVENT_CODE.left:
      return EVENT_CODE.right;
    default:
      return key2;
  }
};
const getFocusIntent = (event, orientation, dir) => {
  const key2 = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key2))
    return void 0;
  if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key2))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key2];
};
const reorderArray = (array4, atIdx) => {
  return array4.map((_, idx) => array4[(idx + atIdx) % array4.length]);
};
const focusFirst = (elements) => {
  const { activeElement: prevActive } = document;
  for (const element of elements) {
    if (element === prevActive)
      return;
    element.focus();
    if (prevActive !== document.activeElement)
      return;
  }
};
const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
const EVT_OPTS = { bubbles: false, cancelable: true };
const _sfc_main$C = defineComponent({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: false,
  props: rovingFocusGroupProps,
  emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
  setup(props, { emit }) {
    var _a2;
    const currentTabbedId = ref((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
    const isBackingOut = ref(false);
    const isClickFocus = ref(false);
    const rovingFocusGroupRef = ref(null);
    const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
    const rovingFocusGroupRootStyle = computed(() => {
      return [
        {
          outline: "none"
        },
        props.style
      ];
    });
    const onItemFocus = (tabbedId) => {
      emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
    };
    const onItemShiftTab = () => {
      isBackingOut.value = true;
    };
    const onMousedown = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e);
    }, () => {
      isClickFocus.value = true;
    });
    const onFocus = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e);
    }, (e) => {
      const isKeyboardFocus = !unref(isClickFocus);
      const { target, currentTarget } = e;
      if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
        const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
        currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
        if (!entryFocusEvt.defaultPrevented) {
          const items = getItems().filter((item) => item.focusable);
          const activeItem = items.find((item) => item.active);
          const currentItem = items.find((item) => item.id === unref(currentTabbedId));
          const candidates = [activeItem, currentItem, ...items].filter(Boolean);
          const candidateNodes = candidates.map((item) => item.ref);
          focusFirst(candidateNodes);
        }
      }
      isClickFocus.value = false;
    });
    const onBlur = composeEventHandlers((e) => {
      var _a22;
      (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e);
    }, () => {
      isBackingOut.value = false;
    });
    const handleEntryFocus = (...args) => {
      emit("entryFocus", ...args);
    };
    provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
      currentTabbedId: readonly(currentTabbedId),
      loop: toRef(props, "loop"),
      tabIndex: computed(() => {
        return unref(isBackingOut) ? -1 : 0;
      }),
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      orientation: toRef(props, "orientation"),
      dir: toRef(props, "dir"),
      onItemFocus,
      onItemShiftTab,
      onBlur,
      onFocus,
      onMousedown
    });
    watch(() => props.currentTabId, (val) => {
      currentTabbedId.value = val != null ? val : null;
    });
    onMounted(() => {
      const rovingFocusGroupEl = unref(rovingFocusGroupRef);
      on$1(rovingFocusGroupEl, ENTRY_FOCUS_EVT, handleEntryFocus);
    });
    onBeforeUnmount(() => {
      const rovingFocusGroupEl = unref(rovingFocusGroupRef);
      off(rovingFocusGroupEl, ENTRY_FOCUS_EVT, handleEntryFocus);
    });
  }
});
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$u], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
const _sfc_main$B = defineComponent({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: ElCollection$1,
    ElRovingFocusGroupImpl
  }
});
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
  const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
  return openBlock(), createBlock(_component_el_focus_group_collection, null, {
    default: withCtx(() => [
      createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$t], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
const _sfc_main$A = defineComponent({
  components: {
    ElRovingFocusCollectionItem: ElCollectionItem$1
  },
  props: {
    focusable: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(props, { emit }) {
    const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
    const id = useId();
    const rovingFocusGroupItemRef = ref(null);
    const handleMousedown = composeEventHandlers((e) => {
      emit("mousedown", e);
    }, (e) => {
      if (!props.focusable) {
        e.preventDefault();
      } else {
        onItemFocus(unref(id));
      }
    });
    const handleFocus = composeEventHandlers((e) => {
      emit("focus", e);
    }, () => {
      onItemFocus(unref(id));
    });
    const handleKeydown = composeEventHandlers((e) => {
      emit("keydown", e);
    }, (e) => {
      const { key: key2, shiftKey, target, currentTarget } = e;
      if (key2 === EVENT_CODE.tab && shiftKey) {
        onItemShiftTab();
        return;
      }
      if (target !== currentTarget)
        return;
      const focusIntent = getFocusIntent(e);
      if (focusIntent) {
        e.preventDefault();
        const items = getItems().filter((item) => item.focusable);
        let elements = items.map((item) => item.ref);
        switch (focusIntent) {
          case "last": {
            elements.reverse();
            break;
          }
          case "prev":
          case "next": {
            if (focusIntent === "prev") {
              elements.reverse();
            }
            const currentIdx = elements.indexOf(currentTarget);
            elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
            break;
          }
        }
        nextTick(() => {
          focusFirst(elements);
        });
      }
    });
    const isCurrentTab = computed(() => currentTabbedId.value === unref(id));
    provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
      rovingFocusGroupItemRef,
      tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
      handleMousedown,
      handleFocus,
      handleKeydown
    });
    return {
      id,
      handleKeydown,
      handleFocus,
      handleMousedown
    };
  }
});
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
  return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
    id: _ctx.id,
    focusable: _ctx.focusable,
    active: _ctx.active
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$s], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
const dropdownProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  effect: {
    ...useTooltipContentProps.effect,
    default: "light"
  },
  type: {
    type: definePropType(String)
  },
  placement: {
    type: definePropType(String),
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: true
  },
  loop: {
    type: Boolean,
    default: true
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: definePropType([Number, String]),
    default: 0
  },
  maxHeight: {
    type: definePropType([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: definePropType(Object)
  }
});
const dropdownItemProps = buildProps({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: iconPropType
  }
});
const dropdownMenuProps = buildProps({
  onKeydown: { type: definePropType(Function) }
});
const FIRST_KEYS = [
  EVENT_CODE.down,
  EVENT_CODE.pageDown,
  EVENT_CODE.home
];
const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
const {
  ElCollection,
  ElCollectionItem,
  COLLECTION_INJECTION_KEY,
  COLLECTION_ITEM_INJECTION_KEY
} = createCollectionWithScope("Dropdown");
const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
const { ButtonGroup: ElButtonGroup } = ElButton;
const _sfc_main$z = defineComponent({
  name: "ElDropdown",
  components: {
    ElButton,
    ElButtonGroup,
    ElScrollbar,
    ElDropdownCollection: ElCollection,
    ElTooltip,
    ElRovingFocusGroup,
    ElOnlyChild: OnlyChild,
    ElIcon,
    ArrowDown: arrow_down_default
  },
  props: dropdownProps,
  emits: ["visible-change", "click", "command"],
  setup(props, { emit }) {
    const _instance = getCurrentInstance();
    const ns2 = useNamespace("dropdown");
    const { t } = useLocale();
    const triggeringElementRef = ref();
    const referenceElementRef = ref();
    const popperRef = ref(null);
    const contentRef = ref(null);
    const scrollbar = ref(null);
    const currentTabId = ref(null);
    const isUsingKeyboard = ref(false);
    const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
    const wrapStyle = computed(() => ({
      maxHeight: addUnit(props.maxHeight)
    }));
    const dropdownTriggerKls = computed(() => [ns2.m(dropdownSize.value)]);
    const defaultTriggerId = useId().value;
    const triggerId = computed(() => {
      return props.id || defaultTriggerId;
    });
    function handleClick() {
      handleClose();
    }
    function handleClose() {
      var _a2;
      (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
    }
    function handleOpen() {
      var _a2;
      (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
    }
    const dropdownSize = useSize();
    function commandHandler(...args) {
      emit("command", ...args);
    }
    function onItemEnter() {
    }
    function onItemLeave() {
      const contentEl = unref(contentRef);
      contentEl == null ? void 0 : contentEl.focus();
      currentTabId.value = null;
    }
    function handleCurrentTabIdChange(id) {
      currentTabId.value = id;
    }
    function handleEntryFocus(e) {
      if (!isUsingKeyboard.value) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    }
    function handleShowTooltip(event) {
      if ((event == null ? void 0 : event.type) === "keydown") {
        contentRef.value.focus();
      }
      emit("visible-change", true);
    }
    function handleHideTooltip() {
      emit("visible-change", false);
    }
    provide(DROPDOWN_INJECTION_KEY, {
      contentRef,
      role: computed(() => props.role),
      triggerId,
      isUsingKeyboard,
      onItemEnter,
      onItemLeave
    });
    provide("elDropdown", {
      instance: _instance,
      dropdownSize,
      handleClick,
      commandHandler,
      trigger: toRef(props, "trigger"),
      hideOnClick: toRef(props, "hideOnClick")
    });
    const onFocusAfterTrapped = (e) => {
      var _a2, _b;
      e.preventDefault();
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
        preventScroll: true
      });
    };
    const handlerMainButtonClick = (event) => {
      emit("click", event);
    };
    return {
      t,
      ns: ns2,
      scrollbar,
      wrapStyle,
      dropdownTriggerKls,
      dropdownSize,
      triggerId,
      triggerKeys,
      currentTabId,
      handleCurrentTabIdChange,
      handlerMainButtonClick,
      handleEntryFocus,
      handleClose,
      handleOpen,
      handleShowTooltip,
      handleHideTooltip,
      onFocusAfterTrapped,
      popperRef,
      contentRef,
      triggeringElementRef,
      referenceElementRef
    };
  }
});
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
  const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_only_child = resolveComponent("el-only-child");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_el_button = resolveComponent("el-button");
  const _component_arrow_down = resolveComponent("arrow-down");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_button_group = resolveComponent("el-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
  }, [
    createVNode(_component_el_tooltip, {
      ref: "popperRef",
      role: _ctx.role,
      effect: _ctx.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": _ctx.popperOptions,
      "gpu-acceleration": false,
      "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
      "manual-mode": true,
      placement: _ctx.placement,
      "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
      "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
      trigger: _ctx.trigger,
      "trigger-keys": _ctx.triggerKeys,
      "trigger-target-el": _ctx.contentRef,
      "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
      "stop-popper-mouse-event": false,
      "virtual-ref": _ctx.triggeringElementRef,
      "virtual-triggering": _ctx.splitButton,
      disabled: _ctx.disabled,
      transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
      teleported: "",
      pure: "",
      persistent: "",
      onShow: _ctx.handleShowTooltip,
      onHide: _ctx.handleHideTooltip
    }, createSlots({
      content: withCtx(() => [
        createVNode(_component_el_scrollbar, {
          ref: "scrollbar",
          "wrap-style": _ctx.wrapStyle,
          tag: "div",
          "view-class": _ctx.ns.e("list")
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group, {
              loop: _ctx.loop,
              "current-tab-id": _ctx.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
              onEntryFocus: _ctx.handleEntryFocus
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_collection, null, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      !_ctx.splitButton ? {
        name: "default",
        fn: withCtx(() => [
          createVNode(_component_el_only_child, {
            id: _ctx.triggerId,
            role: "button",
            tabindex: _ctx.tabindex
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      } : void 0
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "onShow", "onHide"]),
    _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
      default: withCtx(() => [
        createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
          size: _ctx.dropdownSize,
          type: _ctx.type,
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          onClick: _ctx.handlerMainButtonClick
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        createVNode(_component_el_button, mergeProps({
          id: _ctx.triggerId,
          ref: "triggeringElementRef"
        }, _ctx.buttonProps, {
          role: "button",
          size: _ctx.dropdownSize,
          type: _ctx.type,
          class: _ctx.ns.e("caret-button"),
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          "aria-label": _ctx.t("el.dropdown.toggleDropdown")
        }), {
          default: withCtx(() => [
            createVNode(_component_el_icon, {
              class: normalizeClass(_ctx.ns.e("icon"))
            }, {
              default: withCtx(() => [
                createVNode(_component_arrow_down)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : createCommentVNode("v-if", true)
  ], 2);
}
var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$r], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
const _sfc_main$y = defineComponent({
  name: "DropdownItemImpl",
  components: {
    ElIcon
  },
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(_, { emit }) {
    const ns2 = useNamespace("dropdown");
    const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
    const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
    const {
      rovingFocusGroupItemRef,
      tabIndex,
      handleFocus,
      handleKeydown: handleItemKeydown,
      handleMousedown
    } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
    const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
    const role = computed(() => {
      if (menuRole.value === "menu") {
        return "menuitem";
      } else if (menuRole.value === "navigation") {
        return "link";
      }
      return "button";
    });
    const handleKeydown = composeEventHandlers((e) => {
      const { code: code2 } = e;
      if (code2 === EVENT_CODE.enter || code2 === EVENT_CODE.space) {
        e.preventDefault();
        e.stopImmediatePropagation();
        emit("clickimpl", e);
        return true;
      }
    }, handleItemKeydown);
    return {
      ns: ns2,
      itemRef,
      dataset: {
        [COLLECTION_ITEM_SIGN]: ""
      },
      role,
      tabIndex,
      handleFocus,
      handleKeydown,
      handleMousedown
    };
  }
});
const _hoisted_1$$ = ["aria-disabled", "tabindex", "role"];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  return openBlock(), createElementBlock(Fragment$6, null, [
    _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
      key: 0,
      role: "separator",
      class: _ctx.ns.bem("menu", "item", "divided")
    }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
    createElementVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
      "aria-disabled": _ctx.disabled,
      class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
      tabindex: _ctx.tabIndex,
      role: _ctx.role,
      onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
      onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
      onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
    }), [
      _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default")
    ], 16, _hoisted_1$$)
  ], 64);
}
var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$q], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
const useDropdown = () => {
  const elDropdown2 = inject("elDropdown", {});
  const _elDropdownSize = computed(() => elDropdown2 == null ? void 0 : elDropdown2.dropdownSize);
  return {
    elDropdown: elDropdown2,
    _elDropdownSize
  };
};
const _sfc_main$x = defineComponent({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: ElCollectionItem,
    ElRovingFocusItem,
    ElDropdownItemImpl
  },
  inheritAttrs: false,
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click"],
  setup(props, { emit, attrs }) {
    const { elDropdown: elDropdown2 } = useDropdown();
    const _instance = getCurrentInstance();
    const itemRef = ref(null);
    const textContent = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
    });
    const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const handlePointerMove = composeEventHandlers((e) => {
      emit("pointermove", e);
      return e.defaultPrevented;
    }, whenMouse((e) => {
      var _a2;
      if (props.disabled) {
        onItemLeave(e);
      } else {
        onItemEnter(e);
        if (!e.defaultPrevented) {
          (_a2 = e.currentTarget) == null ? void 0 : _a2.focus();
        }
      }
    }));
    const handlePointerLeave = composeEventHandlers((e) => {
      emit("pointerleave", e);
      return e.defaultPrevented;
    }, whenMouse((e) => {
      onItemLeave(e);
    }));
    const handleClick = composeEventHandlers((e) => {
      emit("click", e);
      return e.type !== "keydown" && e.defaultPrevented;
    }, (e) => {
      var _a2, _b, _c;
      if (props.disabled) {
        e.stopImmediatePropagation();
        return;
      }
      if ((_a2 = elDropdown2 == null ? void 0 : elDropdown2.hideOnClick) == null ? void 0 : _a2.value) {
        (_b = elDropdown2.handleClick) == null ? void 0 : _b.call(elDropdown2);
      }
      (_c = elDropdown2.commandHandler) == null ? void 0 : _c.call(elDropdown2, props.command, _instance, e);
    });
    const propsAndAttrs = computed(() => {
      return { ...props, ...attrs };
    });
    return {
      handleClick,
      handlePointerMove,
      handlePointerLeave,
      textContent,
      propsAndAttrs
    };
  }
});
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
  const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
  const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
  return openBlock(), createBlock(_component_el_dropdown_collection_item, {
    disabled: _ctx.disabled,
    "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
  }, {
    default: withCtx(() => [
      createVNode(_component_el_roving_focus_item, {
        focusable: !_ctx.disabled
      }, {
        default: withCtx(() => [
          createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
            onPointerleave: _ctx.handlePointerLeave,
            onPointermove: _ctx.handlePointerMove,
            onClickimpl: _ctx.handleClick
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$p], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
const _sfc_main$w = defineComponent({
  name: "ElDropdownMenu",
  props: dropdownMenuProps,
  setup(props) {
    const ns2 = useNamespace("dropdown");
    const { _elDropdownSize } = useDropdown();
    const size = _elDropdownSize.value;
    const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
    const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
    const {
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      tabIndex,
      onBlur,
      onFocus,
      onMousedown
    } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
    const dropdownKls = computed(() => {
      return [ns2.b("menu"), ns2.bm("menu", size == null ? void 0 : size.value)];
    });
    const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
    const composedKeydown = composeEventHandlers((e) => {
      var _a2;
      (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e);
    }, (e) => {
      const { currentTarget, code: code2, target } = e;
      currentTarget.contains(target);
      if (EVENT_CODE.tab === code2) {
        e.stopImmediatePropagation();
      }
      e.preventDefault();
      if (target !== unref(contentRef))
        return;
      if (!FIRST_LAST_KEYS.includes(code2))
        return;
      const items = getItems().filter((item) => !item.disabled);
      const targets = items.map((item) => item.ref);
      if (LAST_KEYS.includes(code2)) {
        targets.reverse();
      }
      focusFirst(targets);
    });
    const handleKeydown = (e) => {
      composedKeydown(e);
      onKeydown(e);
    };
    return {
      size,
      rovingFocusGroupRootStyle,
      tabIndex,
      dropdownKls,
      role,
      triggerId,
      dropdownListWrapperRef,
      handleKeydown,
      onBlur,
      onFocus,
      onMousedown
    };
  }
});
const _hoisted_1$_ = ["role", "aria-labelledby"];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    ref: _ctx.dropdownListWrapperRef,
    class: normalizeClass(_ctx.dropdownKls),
    style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: _ctx.role,
    "aria-labelledby": _ctx.triggerId,
    onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
    onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onMousedown && _ctx.onMousedown(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 46, _hoisted_1$_);
}
var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$o], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
const ElDropdown = withInstall(Dropdown, {
  DropdownItem,
  DropdownMenu
});
const ElDropdownItem = withNoopInstall(DropdownItem);
const ElDropdownMenu = withNoopInstall(DropdownMenu);
const formProps = buildProps({
  model: Object,
  rules: {
    type: definePropType(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  },
  disabled: Boolean,
  validateOnRuleChange: {
    type: Boolean,
    default: true
  },
  hideRequiredAsterisk: {
    type: Boolean,
    default: false
  },
  scrollToError: Boolean
});
const formEmits = {
  validate: (prop, isValid, message) => (isArray(prop) || isString(prop)) && isBoolean(isValid) && isString(message)
};
function useFormLabelWidth() {
  const potentialLabelWidthArr = ref([]);
  const autoLabelWidth = computed(() => {
    if (!potentialLabelWidthArr.value.length)
      return "0";
    const max7 = Math.max(...potentialLabelWidthArr.value);
    return max7 ? `${max7}px` : "";
  });
  function getLabelWidthIndex(width) {
    const index6 = potentialLabelWidthArr.value.indexOf(width);
    return index6;
  }
  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      const index6 = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index6, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }
  function deregisterLabelWidth(val) {
    const index6 = getLabelWidthIndex(val);
    if (index6 > -1) {
      potentialLabelWidthArr.value.splice(index6, 1);
    }
  }
  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
}
const filterFields = (fields, props) => {
  const normalized = castArray(props);
  return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
};
const __default__$7 = {
  name: "ElForm"
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  ...__default__$7,
  props: formProps,
  emits: formEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const fields = [];
    const formSize = useSize();
    const ns2 = useNamespace("form");
    const formClasses = computed(() => {
      const { labelPosition, inline: inline2 } = props;
      return [
        ns2.b(),
        ns2.m(formSize.value || "default"),
        {
          [ns2.m(`label-${labelPosition}`)]: labelPosition,
          [ns2.m("inline")]: inline2
        }
      ];
    });
    const addField = (field) => {
      fields.push(field);
    };
    const removeField = (field) => {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    };
    const resetFields = (properties = []) => {
      if (!props.model) {
        return;
      }
      filterFields(fields, properties).forEach((field) => field.resetField());
    };
    const clearValidate = (props2 = []) => {
      filterFields(fields, props2).forEach((field) => field.clearValidate());
    };
    const isValidatable = computed(() => {
      const hasModel = !!props.model;
      return hasModel;
    });
    const obtainValidateFields = (props2) => {
      if (fields.length === 0)
        return [];
      const filteredFields = filterFields(fields, props2);
      if (!filteredFields.length) {
        return [];
      }
      return filteredFields;
    };
    const validate = async (callback) => validateField(void 0, callback);
    const doValidateField = async (props2 = []) => {
      if (!isValidatable.value)
        return false;
      const fields2 = obtainValidateFields(props2);
      if (fields2.length === 0)
        return true;
      let validationErrors = {};
      for (const field of fields2) {
        try {
          await field.validate("");
        } catch (fields3) {
          validationErrors = {
            ...validationErrors,
            ...fields3
          };
        }
      }
      if (Object.keys(validationErrors).length === 0)
        return true;
      return Promise.reject(validationErrors);
    };
    const validateField = async (modelProps = [], callback) => {
      const shouldThrow = !isFunction(callback);
      try {
        const result2 = await doValidateField(modelProps);
        if (result2 === true) {
          callback == null ? void 0 : callback(result2);
        }
        return result2;
      } catch (e) {
        const invalidFields = e;
        if (props.scrollToError) {
          scrollToField(Object.keys(invalidFields)[0]);
        }
        callback == null ? void 0 : callback(false, invalidFields);
        return shouldThrow && Promise.reject(invalidFields);
      }
    };
    const scrollToField = (prop) => {
      var _a2;
      const field = filterFields(fields, prop)[0];
      if (field) {
        (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView();
      }
    };
    watch(() => props.rules, () => {
      if (props.validateOnRuleChange) {
        validate().catch((err6) => debugWarn());
      }
    }, { deep: true });
    provide(formContextKey, reactive({
      ...toRefs(props),
      emit,
      resetFields,
      clearValidate,
      validateField,
      addField,
      removeField,
      ...useFormLabelWidth()
    }));
    expose({
      validate,
      validateField,
      resetFields,
      clearValidate,
      scrollToField
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("form", {
        class: normalizeClass(unref(formClasses))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
var Form = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn3) {
  return Function.toString.call(fn3).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index6 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index6;
    index6 = index6 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve21, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve21(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve21, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve21(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve21(source);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
  var v = value;
  for (var i = 0; i < path.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path[i]];
  }
  return v;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (typeof value === "object" && typeof target[s] === "object") {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b = function b2(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min7 = typeof rule.min === "number";
  var max7 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key2 = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min7 && !max7 && val < rule.min) {
    errors.push(format(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max7 && !min7 && val > rule.max) {
    errors.push(format(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min7 && max7 && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema2 = /* @__PURE__ */ function() {
  function Schema3(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema3.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;
    if (o === void 0) {
      o = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add2(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add2(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value,
          source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key2, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options.suppressWarning && errorList.length) {
          Schema3.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema3(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb(error.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType2(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema3;
}();
Schema2.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema2.warning = warning;
Schema2.messages = messages;
Schema2.validators = validators;
const formItemValidateStates = [
  "",
  "error",
  "validating",
  "success"
];
const formItemProps = buildProps({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: definePropType([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: definePropType([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: formItemValidateStates
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    values: componentSizes
  }
});
const COMPONENT_NAME = "ElLabelWrap";
var FormLabelWrap = defineComponent({
  name: COMPONENT_NAME,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(props, {
    slots
  }) {
    const formContext = inject(formContextKey, void 0);
    const formItemContext = inject(formItemContextKey);
    if (!formItemContext)
      throwError(COMPONENT_NAME, "usage: <el-form-item><label-wrap /></el-form-item>");
    const ns2 = useNamespace("form");
    const el = ref();
    const computedWidth = ref(0);
    const getLabelWidth = () => {
      var _a2;
      if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
        const width = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(width));
      } else {
        return 0;
      }
    };
    const updateLabelWidth = (action = "update") => {
      nextTick(() => {
        if (slots.default && props.isAutoWidth) {
          if (action === "update") {
            computedWidth.value = getLabelWidth();
          } else if (action === "remove") {
            formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };
    const updateLabelWidthFn = () => updateLabelWidth("update");
    onMounted(() => {
      updateLabelWidthFn();
    });
    onBeforeUnmount(() => {
      updateLabelWidth("remove");
    });
    onUpdated(() => updateLabelWidthFn());
    watch(computedWidth, (val, oldVal) => {
      if (props.updateAll) {
        formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
      }
    });
    useResizeObserver(computed(() => {
      var _a2, _b;
      return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
    }), updateLabelWidthFn);
    return () => {
      var _a2, _b;
      if (!slots)
        return null;
      const {
        isAutoWidth
      } = props;
      if (isAutoWidth) {
        const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
        const style2 = {};
        if (autoLabelWidth && autoLabelWidth !== "auto") {
          const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
          const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
          if (marginWidth) {
            style2[marginPosition] = `${marginWidth}px`;
          }
        }
        return createVNode("div", {
          "ref": el,
          "class": [ns2.be("item", "label-wrap")],
          "style": style2
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      } else {
        return createVNode(Fragment$6, {
          "ref": el
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      }
    };
  }
});
const _hoisted_1$Z = ["role", "aria-labelledby"];
const __default__$6 = {
  name: "ElFormItem"
};
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  ...__default__$6,
  props: formItemProps,
  setup(__props, { expose }) {
    const props = __props;
    const slots = useSlots();
    const formContext = inject(formContextKey, void 0);
    const parentFormItemContext = inject(formItemContextKey, void 0);
    const _size = useSize(void 0, { formItem: false });
    const ns2 = useNamespace("form-item");
    const labelId = useId().value;
    const inputIds = ref([]);
    const validateState = ref("");
    const validateStateDebounced = refDebounced(validateState, 100);
    const validateMessage = ref("");
    const formItemRef = ref();
    let initialValue = void 0;
    let isResettingField = false;
    const labelStyle = computed(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
        return {};
      }
      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
      if (labelWidth)
        return { width: labelWidth };
      return {};
    });
    const contentStyle = computed(() => {
      if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
        return {};
      }
      if (!props.label && !props.labelWidth && isNested) {
        return {};
      }
      const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
      if (!props.label && !slots.label) {
        return { marginLeft: labelWidth };
      }
      return {};
    });
    const formItemClasses = computed(() => [
      ns2.b(),
      ns2.m(_size.value),
      ns2.is("error", validateState.value === "error"),
      ns2.is("validating", validateState.value === "validating"),
      ns2.is("success", validateState.value === "success"),
      ns2.is("required", isRequired.value || props.required),
      ns2.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
      { [ns2.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
    ]);
    const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
    const validateClasses = computed(() => [
      ns2.e("error"),
      { [ns2.em("error", "inline")]: _inlineMessage.value }
    ]);
    const propString = computed(() => {
      if (!props.prop)
        return "";
      return isString(props.prop) ? props.prop : props.prop.join(".");
    });
    const hasLabel = computed(() => {
      return !!(props.label || slots.label);
    });
    const labelFor = computed(() => {
      return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
    });
    const isGroup = computed(() => {
      return !labelFor.value && hasLabel.value;
    });
    const isNested = !!parentFormItemContext;
    const fieldValue = computed(() => {
      const model = formContext == null ? void 0 : formContext.model;
      if (!model || !props.prop) {
        return;
      }
      return getProp(model, props.prop).value;
    });
    const _rules = computed(() => {
      const rules2 = props.rules ? castArray(props.rules) : [];
      const formRules = formContext == null ? void 0 : formContext.rules;
      if (formRules && props.prop) {
        const _rules2 = getProp(formRules, props.prop).value;
        if (_rules2) {
          rules2.push(...castArray(_rules2));
        }
      }
      if (props.required !== void 0) {
        rules2.push({ required: !!props.required });
      }
      return rules2;
    });
    const validateEnabled = computed(() => _rules.value.length > 0);
    const getFilteredRule = (trigger) => {
      const rules2 = _rules.value;
      return rules2.filter((rule) => {
        if (!rule.trigger || !trigger)
          return true;
        if (Array.isArray(rule.trigger)) {
          return rule.trigger.includes(trigger);
        } else {
          return rule.trigger === trigger;
        }
      }).map(({ trigger: trigger2, ...rule }) => rule);
    };
    const isRequired = computed(() => _rules.value.some((rule) => rule.required === true));
    const shouldShowError = computed(() => {
      var _a2;
      return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
    });
    const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
    const setValidationState = (state) => {
      validateState.value = state;
    };
    const onValidationFailed = (error) => {
      var _a2, _b;
      const { errors, fields } = error;
      if (!errors || !fields) {
        console.error(error);
      }
      setValidationState("error");
      validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
      formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
    };
    const onValidationSucceeded = () => {
      setValidationState("success");
      formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
    };
    const doValidate = async (rules2) => {
      const modelName = propString.value;
      const validator = new Schema2({
        [modelName]: rules2
      });
      return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
        onValidationSucceeded();
        return true;
      }).catch((err6) => {
        onValidationFailed(err6);
        return Promise.reject(err6);
      });
    };
    const validate = async (trigger, callback) => {
      if (isResettingField) {
        isResettingField = false;
        return false;
      }
      const hasCallback = isFunction(callback);
      if (!validateEnabled.value) {
        callback == null ? void 0 : callback(false);
        return false;
      }
      const rules2 = getFilteredRule(trigger);
      if (rules2.length === 0) {
        callback == null ? void 0 : callback(true);
        return true;
      }
      setValidationState("validating");
      return doValidate(rules2).then(() => {
        callback == null ? void 0 : callback(true);
        return true;
      }).catch((err6) => {
        const { fields } = err6;
        callback == null ? void 0 : callback(false, fields);
        return hasCallback ? false : Promise.reject(fields);
      });
    };
    const clearValidate = () => {
      setValidationState("");
      validateMessage.value = "";
    };
    const resetField = async () => {
      const model = formContext == null ? void 0 : formContext.model;
      if (!model || !props.prop)
        return;
      const computedValue = getProp(model, props.prop);
      if (!isEqual(computedValue.value, initialValue)) {
        isResettingField = true;
      }
      computedValue.value = clone(initialValue);
      await nextTick();
      clearValidate();
    };
    const addInputId = (id) => {
      if (!inputIds.value.includes(id)) {
        inputIds.value.push(id);
      }
    };
    const removeInputId = (id) => {
      inputIds.value = inputIds.value.filter((listId) => listId !== id);
    };
    watch(() => props.error, (val) => {
      validateMessage.value = val || "";
      setValidationState(val ? "error" : "");
    }, { immediate: true });
    watch(() => props.validateStatus, (val) => setValidationState(val || ""));
    const context = reactive({
      ...toRefs(props),
      $el: formItemRef,
      size: _size,
      validateState,
      labelId,
      inputIds,
      isGroup,
      addInputId,
      removeInputId,
      resetField,
      clearValidate,
      validate
    });
    provide(formItemContextKey, context);
    onMounted(() => {
      if (props.prop) {
        formContext == null ? void 0 : formContext.addField(context);
        initialValue = clone(fieldValue.value);
      }
    });
    onBeforeUnmount(() => {
      formContext == null ? void 0 : formContext.removeField(context);
    });
    expose({
      size: _size,
      validateMessage,
      validateState,
      validate,
      clearValidate,
      resetField
    });
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createElementBlock("div", {
        ref_key: "formItemRef",
        ref: formItemRef,
        class: normalizeClass(unref(formItemClasses)),
        role: unref(isGroup) ? "group" : void 0,
        "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
      }, [
        createVNode(unref(FormLabelWrap), {
          "is-auto-width": unref(labelStyle).width === "auto",
          "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
        }, {
          default: withCtx(() => [
            unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
              key: 0,
              id: unref(labelId),
              for: unref(labelFor),
              class: normalizeClass(unref(ns2).e("label")),
              style: normalizeStyle(unref(labelStyle))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                  createTextVNode(toDisplayString(unref(currentLabel)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        createElementVNode("div", {
          class: normalizeClass(unref(ns2).e("content")),
          style: normalizeStyle(unref(contentStyle))
        }, [
          renderSlot(_ctx.$slots, "default"),
          createVNode(Transition, {
            name: `${unref(ns2).namespace.value}-zoom-in-top`
          }, {
            default: withCtx(() => [
              unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                key: 0,
                error: validateMessage.value
              }, () => [
                createElementVNode("div", {
                  class: normalizeClass(unref(validateClasses))
                }, toDisplayString(validateMessage.value), 3)
              ]) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, _hoisted_1$Z);
    };
  }
});
var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
const ElForm = withInstall(Form, {
  FormItem
});
const ElFormItem = withNoopInstall(FormItem);
const popoverProps = buildProps({
  trigger: useTooltipTriggerProps.trigger,
  placement: dropdownProps.placement,
  disabled: useTooltipTriggerProps.disabled,
  visible: useTooltipContentProps.visible,
  transition: useTooltipContentProps.transition,
  popperOptions: dropdownProps.popperOptions,
  tabindex: dropdownProps.tabindex,
  content: useTooltipContentProps.content,
  popperStyle: useTooltipContentProps.popperStyle,
  popperClass: useTooltipContentProps.popperClass,
  enterable: {
    ...useTooltipContentProps.enterable,
    default: true
  },
  effect: {
    ...useTooltipContentProps.effect,
    default: "light"
  },
  teleported: useTooltipContentProps.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  persistent: {
    type: Boolean,
    default: true
  }
});
const popoverEmits = {
  "update:visible": (value) => isBoolean(value),
  "before-enter": () => true,
  "before-leave": () => true,
  "after-enter": () => true,
  "after-leave": () => true
};
const __default__$5 = {
  name: "ElPopover"
};
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  ...__default__$5,
  props: popoverProps,
  emits: popoverEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("popover");
    const tooltipRef = ref();
    const popperRef = computed(() => {
      var _a2;
      return (_a2 = unref(tooltipRef)) == null ? void 0 : _a2.popperRef;
    });
    const style2 = computed(() => {
      return [
        {
          width: addUnit(props.width)
        },
        props.popperStyle
      ];
    });
    const kls = computed(() => {
      return [ns2.b(), props.popperClass, { [ns2.m("plain")]: !!props.content }];
    });
    const gpuAcceleration = computed(() => {
      return props.transition === "el-fade-in-linear";
    });
    const hide2 = () => {
      var _a2;
      (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
    };
    const beforeEnter = () => {
      emit("before-enter");
    };
    const beforeLeave = () => {
      emit("before-leave");
    };
    const afterEnter = () => {
      emit("after-enter");
    };
    const afterLeave = () => {
      emit("update:visible", false);
      emit("after-leave");
    };
    expose({
      popperRef,
      hide: hide2
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(ElTooltip), mergeProps({
        ref_key: "tooltipRef",
        ref: tooltipRef
      }, _ctx.$attrs, {
        trigger: _ctx.trigger,
        placement: _ctx.placement,
        disabled: _ctx.disabled,
        visible: _ctx.visible,
        transition: _ctx.transition,
        "popper-options": _ctx.popperOptions,
        tabindex: _ctx.tabindex,
        content: _ctx.content,
        offset: _ctx.offset,
        "show-after": _ctx.showAfter,
        "hide-after": _ctx.hideAfter,
        "auto-close": _ctx.autoClose,
        "show-arrow": _ctx.showArrow,
        "aria-label": _ctx.title,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "popper-class": unref(kls),
        "popper-style": unref(style2),
        teleported: _ctx.teleported,
        persistent: _ctx.persistent,
        "gpu-acceleration": unref(gpuAcceleration),
        onBeforeShow: beforeEnter,
        onBeforeHide: beforeLeave,
        onShow: afterEnter,
        onHide: afterLeave
      }), {
        content: withCtx(() => [
          _ctx.title ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ns2).e("title")),
            role: "title"
          }, toDisplayString(_ctx.title), 3)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.content), 1)
          ])
        ]),
        default: withCtx(() => [
          _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration"]);
    };
  }
});
var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const attachEvents = (el, binding) => {
  const popperComponent = binding.arg || binding.value;
  const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
  if (popover) {
    popover.triggerRef = el;
  }
};
var PopoverDirective = {
  mounted(el, binding) {
    attachEvents(el, binding);
  },
  updated(el, binding) {
    attachEvents(el, binding);
  }
};
const VPopover = "popover";
const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
const ElPopover = withInstall(Popover, {
  directive: ElPopoverDirective
});
const progressProps = buildProps({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (val) => val >= 0 && val <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: definePropType(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: true
  },
  color: {
    type: definePropType([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  format: {
    type: definePropType(Function),
    default: (percentage) => `${percentage}%`
  }
});
const _hoisted_1$Y = ["aria-valuenow"];
const _hoisted_2$U = { viewBox: "0 0 100 100" };
const _hoisted_3$N = ["d", "stroke", "stroke-width"];
const _hoisted_4$6 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
const _hoisted_5$5 = { key: 0 };
const __default__$4 = {
  name: "ElProgress"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  ...__default__$4,
  props: progressProps,
  setup(__props) {
    const props = __props;
    const STATUS_COLOR_MAP = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    };
    const ns2 = useNamespace("progress");
    const barStyle = computed(() => ({
      width: `${props.percentage}%`,
      animationDuration: `${props.duration}s`,
      backgroundColor: getCurrentColor(props.percentage)
    }));
    const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
    const radius = computed(() => {
      if (["circle", "dashboard"].includes(props.type)) {
        return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
      }
      return 0;
    });
    const trackPath = computed(() => {
      const r = radius.value;
      const isDashboard = props.type === "dashboard";
      return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
    });
    const perimeter = computed(() => 2 * Math.PI * radius.value);
    const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
    const strokeDashoffset = computed(() => {
      const offset6 = -1 * perimeter.value * (1 - rate.value) / 2;
      return `${offset6}px`;
    });
    const trailPathStyle = computed(() => ({
      strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value
    }));
    const circlePathStyle = computed(() => ({
      strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    }));
    const stroke = computed(() => {
      let ret;
      if (props.color) {
        ret = getCurrentColor(props.percentage);
      } else {
        ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
      }
      return ret;
    });
    const statusIcon = computed(() => {
      if (props.status === "warning") {
        return warning_filled_default;
      }
      if (props.type === "line") {
        return props.status === "success" ? circle_check_default : circle_close_default;
      } else {
        return props.status === "success" ? check_default : close_default;
      }
    });
    const progressTextSize = computed(() => {
      return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
    });
    const content4 = computed(() => props.format(props.percentage));
    function getColors(color) {
      const span = 100 / color.length;
      const seriesColors = color.map((seriesColor, index6) => {
        if (isString(seriesColor)) {
          return {
            color: seriesColor,
            percentage: (index6 + 1) * span
          };
        }
        return seriesColor;
      });
      return seriesColors.sort((a, b) => a.percentage - b.percentage);
    }
    const getCurrentColor = (percentage) => {
      var _a2;
      const { color } = props;
      if (isFunction(color)) {
        return color(percentage);
      } else if (isString(color)) {
        return color;
      } else {
        const colors = getColors(color);
        for (const color2 of colors) {
          if (color2.percentage > percentage)
            return color2.color;
        }
        return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          unref(ns2).b(),
          unref(ns2).m(_ctx.type),
          unref(ns2).is(_ctx.status),
          {
            [unref(ns2).m("without-text")]: !_ctx.showText,
            [unref(ns2).m("text-inside")]: _ctx.textInside
          }
        ]),
        role: "progressbar",
        "aria-valuenow": _ctx.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, [
        _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(ns2).b("bar"))
        }, [
          createElementVNode("div", {
            class: normalizeClass(unref(ns2).be("bar", "outer")),
            style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
          }, [
            createElementVNode("div", {
              class: normalizeClass([
                unref(ns2).be("bar", "inner"),
                { [unref(ns2).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate }
              ]),
              style: normalizeStyle(unref(barStyle))
            }, [
              (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).be("bar", "innerText"))
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  createElementVNode("span", null, toDisplayString(unref(content4)), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true)
            ], 6)
          ], 6)
        ], 2)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(unref(ns2).b("circle")),
          style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
        }, [
          (openBlock(), createElementBlock("svg", _hoisted_2$U, [
            createElementVNode("path", {
              class: normalizeClass(unref(ns2).be("circle", "track")),
              d: unref(trackPath),
              stroke: `var(${unref(ns2).cssVarName("fill-color-light")}, #e5e9f2)`,
              "stroke-width": unref(relativeStrokeWidth),
              fill: "none",
              style: normalizeStyle(unref(trailPathStyle))
            }, null, 14, _hoisted_3$N),
            createElementVNode("path", {
              class: normalizeClass(unref(ns2).be("circle", "path")),
              d: unref(trackPath),
              stroke: unref(stroke),
              fill: "none",
              opacity: _ctx.percentage ? 1 : 0,
              "stroke-linecap": _ctx.strokeLinecap,
              "stroke-width": unref(relativeStrokeWidth),
              style: normalizeStyle(unref(circlePathStyle))
            }, null, 14, _hoisted_4$6)
          ]))
        ], 6)),
        (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(unref(ns2).e("text")),
          style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
        }, [
          renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
            !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(unref(content4)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
              ]),
              _: 1
            }))
          ])
        ], 6)) : createCommentVNode("v-if", true)
      ], 10, _hoisted_1$Y);
    };
  }
});
var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const ElProgress = withInstall(Progress);
const SCOPE$1 = "ElUpload";
class UploadAjaxError extends Error {
  constructor(message, status, method4, url2) {
    super(message);
    this.name = "UploadAjaxError";
    this.status = status;
    this.method = method4;
    this.url = url2;
  }
}
function getError(action, option, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to ${option.method} ${action} ${xhr.status}`;
  }
  return new UploadAjaxError(msg, xhr.status, option.method, action);
}
function getBody(xhr) {
  const text3 = xhr.responseText || xhr.response;
  if (!text3) {
    return text3;
  }
  try {
    return JSON.parse(text3);
  } catch (e) {
    return text3;
  }
}
const ajaxUpload = (option) => {
  if (typeof XMLHttpRequest === "undefined")
    throwError(SCOPE$1, "XMLHttpRequest is undefined");
  const xhr = new XMLHttpRequest();
  const action = option.action;
  if (xhr.upload) {
    xhr.upload.addEventListener("progress", (evt) => {
      const progressEvt = evt;
      progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
      option.onProgress(progressEvt);
    });
  }
  const formData = new FormData();
  if (option.data) {
    for (const [key2, value] of Object.entries(option.data)) {
      if (Array.isArray(value))
        formData.append(key2, ...value);
      else
        formData.append(key2, value);
    }
  }
  formData.append(option.filename, option.file, option.file.name);
  xhr.addEventListener("error", () => {
    option.onError(getError(action, option, xhr));
  });
  xhr.addEventListener("load", () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr));
    }
    option.onSuccess(getBody(xhr));
  });
  xhr.open(option.method, action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers instanceof Headers) {
    headers.forEach((value, key2) => xhr.setRequestHeader(key2, value));
  } else {
    for (const [key2, value] of Object.entries(headers)) {
      if (isNil(value))
        continue;
      xhr.setRequestHeader(key2, String(value));
    }
  }
  xhr.send(formData);
  return xhr;
};
const uploadListTypes = ["text", "picture", "picture-card"];
let fileId = 1;
const genFileId = () => Date.now() + fileId++;
const uploadBaseProps = buildProps({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: definePropType(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Object,
    default: () => mutable({})
  },
  multiple: {
    type: Boolean,
    default: false
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: false
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: true
  },
  accept: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "select"
  },
  fileList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  },
  httpRequest: {
    type: definePropType(Function),
    default: ajaxUpload
  },
  disabled: Boolean,
  limit: Number
});
const uploadProps = buildProps({
  ...uploadBaseProps,
  beforeUpload: {
    type: definePropType(Function),
    default: NOOP
  },
  beforeRemove: {
    type: definePropType(Function)
  },
  onRemove: {
    type: definePropType(Function),
    default: NOOP
  },
  onChange: {
    type: definePropType(Function),
    default: NOOP
  },
  onPreview: {
    type: definePropType(Function),
    default: NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: NOOP
  },
  onError: {
    type: definePropType(Function),
    default: NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: NOOP
  }
});
const uploadListProps = buildProps({
  files: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  disabled: {
    type: Boolean,
    default: false
  },
  handlePreview: {
    type: definePropType(Function),
    default: NOOP
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  }
});
const uploadListEmits = {
  remove: (file) => !!file
};
const _hoisted_1$X = ["onKeydown"];
const _hoisted_2$T = ["src"];
const _hoisted_3$M = ["onClick"];
const _hoisted_4$5 = ["onClick"];
const _hoisted_5$4 = ["onClick"];
const __default__$3 = {
  name: "ElUploadList"
};
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: uploadListProps,
  emits: uploadListEmits,
  setup(__props, { emit }) {
    const props = __props;
    const { t } = useLocale();
    const nsUpload = useNamespace("upload");
    const nsIcon = useNamespace("icon");
    const nsList = useNamespace("list");
    const focusing = ref(false);
    const handleClick = (file) => {
      props.handlePreview(file);
    };
    const handleRemove = (file) => {
      emit("remove", file);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TransitionGroup, {
        tag: "ul",
        class: normalizeClass([
          unref(nsUpload).b("list"),
          unref(nsUpload).bm("list", _ctx.listType),
          unref(nsUpload).is("disabled", _ctx.disabled)
        ]),
        name: unref(nsList).b()
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.files, (file) => {
            return openBlock(), createElementBlock("li", {
              key: file.uid || file.name,
              class: normalizeClass([
                unref(nsUpload).be("list", "item"),
                unref(nsUpload).is(file.status),
                { focusing: focusing.value }
              ]),
              tabindex: "0",
              onKeydown: withKeys(($event) => !_ctx.disabled && handleRemove(file), ["delete"]),
              onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
              onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
              onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
            }, [
              renderSlot(_ctx.$slots, "default", { file }, () => [
                _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                  src: file.url,
                  alt: ""
                }, null, 10, _hoisted_2$T)) : createCommentVNode("v-if", true),
                _ctx.listType !== "picture" && (file.status === "uploading" || _ctx.listType !== "picture-card") ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                }, [
                  createElementVNode("a", {
                    class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                    onClick: withModifiers(($event) => handleClick(file), ["prevent"])
                  }, [
                    createVNode(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("document"))
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(document_default))
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsUpload).be("list", "item-file-name"))
                    }, toDisplayString(file.name), 3)
                  ], 10, _hoisted_3$M),
                  file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                    key: 0,
                    type: _ctx.listType === "picture-card" ? "circle" : "line",
                    "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                    percentage: Number(file.percentage),
                    style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                  }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("label", {
                  class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                }, [
                  _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(circle_check_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(check_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2),
                !_ctx.disabled ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass(unref(nsIcon).m("close")),
                  onClick: ($event) => handleRemove(file)
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                createCommentVNode(" This is a bug which needs to be fixed "),
                createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                !_ctx.disabled ? (openBlock(), createElementBlock("i", {
                  key: 3,
                  class: normalizeClass(unref(nsIcon).m("close-tip"))
                }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                  key: 4,
                  class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                    onClick: ($event) => _ctx.handlePreview(file)
                  }, [
                    createVNode(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("zoom-in"))
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(zoom_in_default))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_4$5),
                  !_ctx.disabled ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                    onClick: ($event) => handleRemove(file)
                  }, [
                    createVNode(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("delete"))
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(delete_default))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true)
              ])
            ], 42, _hoisted_1$X);
          }), 128)),
          renderSlot(_ctx.$slots, "append")
        ]),
        _: 3
      }, 8, ["class", "name"]);
    };
  }
});
var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const uploadDraggerProps = buildProps({
  disabled: {
    type: Boolean,
    default: false
  }
});
const uploadDraggerEmits = {
  file: (file) => isArray(file)
};
const _hoisted_1$W = ["onDrop", "onDragover"];
const __default__$2 = {
  name: "ElUploadDrag"
};
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  props: uploadDraggerProps,
  emits: uploadDraggerEmits,
  setup(__props, { emit }) {
    const props = __props;
    const COMPONENT_NAME2 = "ElUploadDrag";
    const uploaderContext = inject(uploadContextKey);
    if (!uploaderContext) {
      throwError(COMPONENT_NAME2, "usage: <el-upload><el-upload-dragger /></el-upload>");
    }
    const ns2 = useNamespace("upload");
    const dragover = ref(false);
    const onDrop = (e) => {
      if (props.disabled)
        return;
      dragover.value = false;
      const files = Array.from(e.dataTransfer.files);
      const accept = uploaderContext.accept.value;
      if (!accept) {
        emit("file", files);
        return;
      }
      const filesFiltered = files.filter((file) => {
        const { type: type4, name } = file;
        const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
        const baseType = type4.replace(/\/.*$/, "");
        return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
          if (acceptedType.startsWith(".")) {
            return extension === acceptedType;
          }
          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, "");
          }
          if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
            return type4 === acceptedType;
          }
          return false;
        });
      });
      emit("file", filesFiltered);
    };
    const onDragover = () => {
      if (!props.disabled)
        dragover.value = true;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([unref(ns2).b("dragger"), unref(ns2).is("dragover", dragover.value)]),
        onDrop: withModifiers(onDrop, ["prevent"]),
        onDragover: withModifiers(onDragover, ["prevent"]),
        onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 42, _hoisted_1$W);
    };
  }
});
var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const uploadContentProps = buildProps({
  ...uploadBaseProps,
  beforeUpload: {
    type: definePropType(Function),
    default: NOOP
  },
  onRemove: {
    type: definePropType(Function),
    default: NOOP
  },
  onStart: {
    type: definePropType(Function),
    default: NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: NOOP
  },
  onError: {
    type: definePropType(Function),
    default: NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: NOOP
  }
});
const _hoisted_1$V = ["onKeydown"];
const _hoisted_2$S = ["name", "multiple", "accept"];
const __default__$1 = {
  name: "ElUploadContent",
  inheritAttrs: false
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: uploadContentProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("upload");
    const requests = shallowRef({});
    const inputRef = shallowRef();
    const uploadFiles = (files) => {
      if (files.length === 0)
        return;
      const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
      if (limit && fileList.length + files.length > limit) {
        onExceed(files, fileList);
        return;
      }
      if (!multiple) {
        files = files.slice(0, 1);
      }
      for (const file of files) {
        const rawFile = file;
        rawFile.uid = genFileId();
        onStart(rawFile);
        if (autoUpload)
          upload(rawFile);
      }
    };
    const upload = async (rawFile) => {
      inputRef.value.value = "";
      if (!props.beforeUpload) {
        return doUpload(rawFile);
      }
      let hookResult;
      try {
        hookResult = await props.beforeUpload(rawFile);
      } catch (e) {
        hookResult = false;
      }
      if (hookResult === false) {
        props.onRemove(rawFile);
        return;
      }
      let file = rawFile;
      if (hookResult instanceof Blob) {
        if (hookResult instanceof File) {
          file = hookResult;
        } else {
          file = new File([hookResult], rawFile.name, {
            type: rawFile.type
          });
        }
      }
      doUpload(Object.assign(file, {
        uid: rawFile.uid
      }));
    };
    const doUpload = (rawFile) => {
      const {
        headers,
        data,
        method: method4,
        withCredentials,
        name: filename,
        action,
        onProgress,
        onSuccess,
        onError,
        httpRequest
      } = props;
      const { uid } = rawFile;
      const options = {
        headers: headers || {},
        withCredentials,
        file: rawFile,
        data,
        method: method4,
        filename,
        action,
        onProgress: (evt) => {
          onProgress(evt, rawFile);
        },
        onSuccess: (res) => {
          onSuccess(res, rawFile);
          delete requests.value[uid];
        },
        onError: (err6) => {
          onError(err6, rawFile);
          delete requests.value[uid];
        }
      };
      const request = httpRequest(options);
      requests.value[uid] = request;
      if (request instanceof Promise) {
        request.then(options.onSuccess, options.onError);
      }
    };
    const handleChange = (e) => {
      const files = e.target.files;
      if (!files)
        return;
      uploadFiles(Array.from(files));
    };
    const handleClick = () => {
      if (!props.disabled) {
        inputRef.value.value = "";
        inputRef.value.click();
      }
    };
    const handleKeydown = () => {
      handleClick();
    };
    const abort = (file) => {
      const _reqs = entriesOf(requests.value).filter(file ? ([uid]) => String(file.uid) === uid : () => true);
      _reqs.forEach(([uid, req]) => {
        if (req instanceof XMLHttpRequest)
          req.abort();
        delete requests.value[uid];
      });
    };
    expose({
      abort,
      upload
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([unref(ns2).b(), unref(ns2).m(_ctx.listType), unref(ns2).is("drag", _ctx.drag)]),
        tabindex: "0",
        onClick: handleClick,
        onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
      }, [
        _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
          key: 0,
          disabled: _ctx.disabled,
          onFile: uploadFiles
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
        createElementVNode("input", {
          ref_key: "inputRef",
          ref: inputRef,
          class: normalizeClass(unref(ns2).e("input")),
          name: _ctx.name,
          multiple: _ctx.multiple,
          accept: _ctx.accept,
          type: "file",
          onChange: handleChange,
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop"]))
        }, null, 42, _hoisted_2$S)
      ], 42, _hoisted_1$V);
    };
  }
});
var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const SCOPE = "ElUpload";
const revokeObjectURL = (file) => {
  var _a2;
  if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
    URL.revokeObjectURL(file.url);
  }
};
const useHandlers = (props, uploadRef) => {
  const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
  const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
  function abort(file) {
    var _a2;
    (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
  }
  function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
    uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
  }
  const handleError = (err6, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    console.error(err6);
    file.status = "fail";
    uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
    props.onError(err6, file, uploadFiles.value);
    props.onChange(file, uploadFiles.value);
  };
  const handleProgress = (evt, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    props.onProgress(evt, file, uploadFiles.value);
    file.status = "uploading";
    file.percentage = Math.round(evt.percent);
  };
  const handleSuccess = (response, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    file.status = "success";
    file.response = response;
    props.onSuccess(response, file, uploadFiles.value);
    props.onChange(file, uploadFiles.value);
  };
  const handleStart = (file) => {
    const uploadFile = {
      name: file.name,
      percentage: 0,
      status: "ready",
      size: file.size,
      raw: file,
      uid: file.uid
    };
    if (props.listType === "picture-card" || props.listType === "picture") {
      try {
        uploadFile.url = URL.createObjectURL(file);
      } catch (err6) {
        debugWarn(SCOPE, err6.message);
        props.onError(err6, uploadFile, uploadFiles.value);
      }
    }
    uploadFiles.value.push(uploadFile);
    props.onChange(uploadFile, uploadFiles.value);
  };
  const handleRemove = async (file) => {
    const uploadFile = file instanceof File ? getFile(file) : file;
    if (!uploadFile)
      throwError(SCOPE, "file to be removed not found");
    const doRemove = (file2) => {
      abort(file2);
      const fileList = uploadFiles.value;
      fileList.splice(fileList.indexOf(file2), 1);
      props.onRemove(file2, fileList);
      revokeObjectURL(file2);
    };
    if (props.beforeRemove) {
      const before6 = await props.beforeRemove(uploadFile, uploadFiles.value);
      if (before6 !== false)
        doRemove(uploadFile);
    } else {
      doRemove(uploadFile);
    }
  };
  function submit() {
    uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
      var _a2;
      return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
    });
  }
  watch(() => props.listType, (val) => {
    if (val !== "picture-card" && val !== "picture") {
      return;
    }
    uploadFiles.value = uploadFiles.value.map((file) => {
      const { raw, url: url2 } = file;
      if (!url2 && raw) {
        try {
          file.url = URL.createObjectURL(raw);
        } catch (err6) {
          props.onError(err6, file, uploadFiles.value);
        }
      }
      return file;
    });
  });
  watch(uploadFiles, (files) => {
    for (const file of files) {
      file.uid || (file.uid = genFileId());
      file.status || (file.status = "success");
    }
  }, { immediate: true, deep: true });
  return {
    uploadFiles,
    abort,
    clearFiles,
    handleError,
    handleProgress,
    handleStart,
    handleSuccess,
    handleRemove,
    submit
  };
};
const __default__ = {
  name: "ElUpload"
};
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: uploadProps,
  setup(__props, { expose }) {
    const props = __props;
    const slots = useSlots();
    const disabled = useDisabled$1();
    const uploadRef = shallowRef();
    const {
      abort,
      submit,
      clearFiles,
      uploadFiles,
      handleStart,
      handleError,
      handleRemove,
      handleSuccess,
      handleProgress
    } = useHandlers(props, uploadRef);
    const isPictureCard = computed(() => props.listType === "picture-card");
    const uploadContentProps2 = computed(() => ({
      ...props,
      onStart: handleStart,
      onProgress: handleProgress,
      onSuccess: handleSuccess,
      onError: handleError,
      onRemove: handleRemove
    }));
    onBeforeUnmount(() => {
      uploadFiles.value.forEach(({ url: url2 }) => {
        if (url2 == null ? void 0 : url2.startsWith("blob:"))
          URL.revokeObjectURL(url2);
      });
    });
    provide(uploadContextKey, {
      accept: toRef(props, "accept")
    });
    expose({
      abort,
      submit,
      clearFiles,
      handleStart,
      handleRemove
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
          key: 0,
          disabled: unref(disabled),
          "list-type": _ctx.listType,
          files: unref(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: unref(handleRemove)
        }, createSlots({
          append: withCtx(() => [
            _ctx.listType === "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
              key: 0,
              ref_key: "uploadRef",
              ref: uploadRef
            }, unref(uploadContentProps2)), {
              default: withCtx(() => [
                unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16)) : createCommentVNode("v-if", true)
          ]),
          _: 2
        }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: withCtx(({ file }) => [
              renderSlot(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
        _ctx.listType !== "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
          key: 1,
          ref_key: "uploadRef",
          ref: uploadRef
        }, unref(uploadContentProps2)), {
          default: withCtx(() => [
            unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
            !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16)) : createCommentVNode("v-if", true),
        _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "tip"),
        !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
          key: 3,
          disabled: unref(disabled),
          "list-type": _ctx.listType,
          files: unref(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: unref(handleRemove)
        }, createSlots({ _: 2 }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: withCtx(({ file }) => [
              renderSlot(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
var Upload = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const ElUpload = withInstall(Upload);
function createLoadingComponent(options) {
  let afterLeaveTimer;
  const ns2 = useNamespace("loading");
  const afterLeaveFlag = ref(false);
  const data = reactive({
    ...options,
    originalPosition: "",
    originalOverflow: "",
    visible: false
  });
  function setText(text3) {
    data.text = text3;
  }
  function destroySelf() {
    const target = data.parent;
    if (!target.vLoadingAddClassList) {
      let loadingNumber = target.getAttribute("loading-number");
      loadingNumber = Number.parseInt(loadingNumber) - 1;
      if (!loadingNumber) {
        removeClass(target, ns2.bm("parent", "relative"));
        target.removeAttribute("loading-number");
      } else {
        target.setAttribute("loading-number", loadingNumber.toString());
      }
      removeClass(target, ns2.bm("parent", "hidden"));
    }
    removeElLoadingChild();
    loadingInstance.unmount();
  }
  function removeElLoadingChild() {
    var _a2, _b;
    (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
  }
  function close6() {
    var _a2;
    if (options.beforeClose && !options.beforeClose())
      return;
    const target = data.parent;
    target.vLoadingAddClassList = void 0;
    afterLeaveFlag.value = true;
    clearTimeout(afterLeaveTimer);
    afterLeaveTimer = window.setTimeout(() => {
      if (afterLeaveFlag.value) {
        afterLeaveFlag.value = false;
        destroySelf();
      }
    }, 400);
    data.visible = false;
    (_a2 = options.closed) == null ? void 0 : _a2.call(options);
  }
  function handleAfterLeave() {
    if (!afterLeaveFlag.value)
      return;
    afterLeaveFlag.value = false;
    destroySelf();
  }
  const elLoadingComponent = {
    name: "ElLoading",
    setup() {
      return () => {
        const svg = data.spinner || data.svg;
        const spinner = h("svg", {
          class: "circular",
          viewBox: data.svgViewBox ? data.svgViewBox : "25 25 50 50",
          ...svg ? { innerHTML: svg } : {}
        }, [
          h("circle", {
            class: "path",
            cx: "50",
            cy: "50",
            r: "20",
            fill: "none"
          })
        ]);
        const spinnerText = data.text ? h("p", { class: ns2.b("text") }, [data.text]) : void 0;
        return h(Transition, {
          name: ns2.b("fade"),
          onAfterLeave: handleAfterLeave
        }, {
          default: withCtx(() => [
            withDirectives(createVNode("div", {
              style: {
                backgroundColor: data.background || ""
              },
              class: [
                ns2.b("mask"),
                data.customClass,
                data.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              h("div", {
                class: ns2.b("spinner")
              }, [spinner, spinnerText])
            ]), [[vShow, data.visible]])
          ])
        });
      };
    }
  };
  const loadingInstance = createApp(elLoadingComponent);
  const vm = loadingInstance.mount(document.createElement("div"));
  return {
    ...toRefs(data),
    setText,
    removeElLoadingChild,
    close: close6,
    handleAfterLeave,
    vm,
    get $el() {
      return vm.$el;
    }
  };
}
let fullscreenInstance = void 0;
const Loading = function(options = {}) {
  if (!isClient)
    return void 0;
  const resolved = resolveOptions(options);
  if (resolved.fullscreen && fullscreenInstance) {
    return fullscreenInstance;
  }
  const instance = createLoadingComponent({
    ...resolved,
    closed: () => {
      var _a2;
      (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
      if (resolved.fullscreen)
        fullscreenInstance = void 0;
    }
  });
  addStyle(resolved, resolved.parent, instance);
  addClassList(resolved, resolved.parent, instance);
  resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
  let loadingNumber = resolved.parent.getAttribute("loading-number");
  if (!loadingNumber) {
    loadingNumber = "1";
  } else {
    loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
  }
  resolved.parent.setAttribute("loading-number", loadingNumber);
  resolved.parent.appendChild(instance.$el);
  nextTick(() => instance.visible.value = resolved.visible);
  if (resolved.fullscreen) {
    fullscreenInstance = instance;
  }
  return instance;
};
const resolveOptions = (options) => {
  var _a2, _b, _c, _d;
  let target;
  if (isString(options.target)) {
    target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
  } else {
    target = options.target || document.body;
  }
  return {
    parent: target === document.body || options.body ? document.body : target,
    background: options.background || "",
    svg: options.svg || "",
    svgViewBox: options.svgViewBox || "",
    spinner: options.spinner || false,
    text: options.text || "",
    fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
    lock: (_c = options.lock) != null ? _c : false,
    customClass: options.customClass || "",
    visible: (_d = options.visible) != null ? _d : true,
    target
  };
};
const addStyle = async (options, parent, instance) => {
  const { nextZIndex } = useZIndex();
  const maskStyle = {};
  if (options.fullscreen) {
    instance.originalPosition.value = getStyle(document.body, "position");
    instance.originalOverflow.value = getStyle(document.body, "overflow");
    maskStyle.zIndex = nextZIndex();
  } else if (options.parent === document.body) {
    instance.originalPosition.value = getStyle(document.body, "position");
    await nextTick();
    for (const property of ["top", "left"]) {
      const scroll = property === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property}`), 10)}px`;
    }
    for (const property of ["height", "width"]) {
      maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
    }
  } else {
    instance.originalPosition.value = getStyle(parent, "position");
  }
  for (const [key2, value] of Object.entries(maskStyle)) {
    instance.$el.style[key2] = value;
  }
};
const addClassList = (options, parent, instance) => {
  const ns2 = useNamespace("loading");
  if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") {
    addClass(parent, ns2.bm("parent", "relative"));
  } else {
    removeClass(parent, ns2.bm("parent", "relative"));
  }
  if (options.fullscreen && options.lock) {
    addClass(parent, ns2.bm("parent", "hidden"));
  } else {
    removeClass(parent, ns2.bm("parent", "hidden"));
  }
};
const INSTANCE_KEY = Symbol("ElLoading");
const createInstance = (el, binding) => {
  var _a2, _b, _c, _d;
  const vm = binding.instance;
  const getBindingProp = (key2) => isObject(binding.value) ? binding.value[key2] : void 0;
  const resolveExpression = (key2) => {
    const data = isString(key2) && (vm == null ? void 0 : vm[key2]) || key2;
    if (data)
      return ref(data);
    else
      return data;
  };
  const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
  const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
  const options = {
    text: getProp2("text"),
    svg: getProp2("svg"),
    svgViewBox: getProp2("svgViewBox"),
    spinner: getProp2("spinner"),
    background: getProp2("background"),
    customClass: getProp2("customClass"),
    fullscreen,
    target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
    body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
    lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
  };
  el[INSTANCE_KEY] = {
    options,
    instance: Loading(options)
  };
};
const updateOptions = (newOptions, originalOptions) => {
  for (const key2 of Object.keys(originalOptions)) {
    if (isRef(originalOptions[key2]))
      originalOptions[key2].value = newOptions[key2];
  }
};
const vLoading = {
  mounted(el, binding) {
    if (binding.value) {
      createInstance(el, binding);
    }
  },
  updated(el, binding) {
    const instance = el[INSTANCE_KEY];
    if (binding.oldValue !== binding.value) {
      if (binding.value && !binding.oldValue) {
        createInstance(el, binding);
      } else if (binding.value && binding.oldValue) {
        if (isObject(binding.value))
          updateOptions(binding.value, instance.options);
      } else {
        instance == null ? void 0 : instance.instance.close();
      }
    }
  },
  unmounted(el) {
    var _a2;
    (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
  }
};
const ElLoading = {
  install(app) {
    app.directive("loading", vLoading);
    app.config.globalProperties.$loading = Loading;
  },
  directive: vLoading,
  service: Loading
};
const _sfc_main$n = defineComponent({
  name: "ElMessageBox",
  directives: {
    TrapFocus
  },
  components: {
    ElButton,
    ElFocusTrap,
    ElInput,
    ElOverlay,
    ElIcon,
    ...TypeComponents
  },
  inheritAttrs: false,
  props: {
    buttonSize: {
      type: String,
      validator: isValidComponentSize
    },
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    draggable: Boolean,
    roundButton: {
      default: false,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(props, { emit }) {
    const { t } = useLocale();
    const ns2 = useNamespace("message-box");
    const visible = ref(false);
    const { nextZIndex } = useZIndex();
    const state = reactive({
      autofocus: true,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: false,
      distinguishCancelAndClose: false,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: true,
      modalClass: "",
      showCancelButton: false,
      showConfirmButton: true,
      type: "",
      title: void 0,
      showInput: false,
      action: "",
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonDisabled: false,
      editorErrorMessage: "",
      validateError: false,
      zIndex: nextZIndex()
    });
    const typeClass = computed(() => {
      const type4 = state.type;
      return { [ns2.bm("icon", type4)]: type4 && TypeComponentsMap[type4] };
    });
    const contentId = useId();
    const inputId = useId();
    const btnSize = useSize(computed(() => props.buttonSize), { prop: true, form: true, formItem: true });
    const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
    const hasMessage = computed(() => !!state.message);
    const rootRef = ref();
    const headerRef = ref();
    const focusStartRef = ref();
    const inputRef = ref();
    const confirmRef = ref();
    const confirmButtonClasses = computed(() => state.confirmButtonClass);
    watch(() => state.inputValue, async (val) => {
      await nextTick();
      if (props.boxType === "prompt" && val !== null) {
        validate();
      }
    }, { immediate: true });
    watch(() => visible.value, (val) => {
      var _a2, _b;
      if (val) {
        if (props.boxType !== "prompt") {
          if (state.autofocus) {
            focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
          } else {
            focusStartRef.value = rootRef.value;
          }
        }
        state.zIndex = nextZIndex();
      }
      if (props.boxType !== "prompt")
        return;
      if (val) {
        nextTick().then(() => {
          var _a22;
          if (inputRef.value && inputRef.value.$el) {
            if (state.autofocus) {
              focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
            } else {
              focusStartRef.value = rootRef.value;
            }
          }
        });
      } else {
        state.editorErrorMessage = "";
        state.validateError = false;
      }
    });
    const draggable = computed(() => props.draggable);
    useDraggable(rootRef, headerRef, draggable);
    onMounted(async () => {
      await nextTick();
      if (props.closeOnHashChange) {
        on$1(window, "hashchange", doClose);
      }
    });
    onBeforeUnmount(() => {
      if (props.closeOnHashChange) {
        off(window, "hashchange", doClose);
      }
    });
    function doClose() {
      if (!visible.value)
        return;
      visible.value = false;
      nextTick(() => {
        if (state.action)
          emit("action", state.action);
      });
    }
    const handleWrapperClick = () => {
      if (props.closeOnClickModal) {
        handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
      }
    };
    const overlayEvent = useSameTarget(handleWrapperClick);
    const handleInputEnter = (e) => {
      if (state.inputType !== "textarea") {
        e.preventDefault();
        return handleAction("confirm");
      }
    };
    const handleAction = (action) => {
      var _a2;
      if (props.boxType === "prompt" && action === "confirm" && !validate()) {
        return;
      }
      state.action = action;
      if (state.beforeClose) {
        (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
      } else {
        doClose();
      }
    };
    const validate = () => {
      if (props.boxType === "prompt") {
        const inputPattern = state.inputPattern;
        if (inputPattern && !inputPattern.test(state.inputValue || "")) {
          state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
          state.validateError = true;
          return false;
        }
        const inputValidator = state.inputValidator;
        if (typeof inputValidator === "function") {
          const validateResult = inputValidator(state.inputValue);
          if (validateResult === false) {
            state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
            state.validateError = true;
            return false;
          }
          if (typeof validateResult === "string") {
            state.editorErrorMessage = validateResult;
            state.validateError = true;
            return false;
          }
        }
      }
      state.editorErrorMessage = "";
      state.validateError = false;
      return true;
    };
    const getInputElement = () => {
      const inputRefs = inputRef.value.$refs;
      return inputRefs.input || inputRefs.textarea;
    };
    const handleClose = () => {
      handleAction("close");
    };
    const onCloseRequested = () => {
      if (props.closeOnPressEscape) {
        handleClose();
      }
    };
    if (props.lockScroll) {
      useLockscreen(visible);
    }
    useRestoreActive(visible);
    return {
      ...toRefs(state),
      ns: ns2,
      overlayEvent,
      visible,
      hasMessage,
      typeClass,
      contentId,
      inputId,
      btnSize,
      iconComponent,
      confirmButtonClasses,
      rootRef,
      focusStartRef,
      headerRef,
      inputRef,
      confirmRef,
      doClose,
      handleClose,
      onCloseRequested,
      handleWrapperClick,
      handleInputEnter,
      handleAction,
      t
    };
  }
});
const _hoisted_1$U = ["aria-label", "aria-describedby"];
const _hoisted_2$R = ["aria-label"];
const _hoisted_3$L = ["id"];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  const _component_close = resolveComponent("close");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_focus_trap = resolveComponent("el-focus-trap");
  const _component_el_overlay = resolveComponent("el-overlay");
  return openBlock(), createBlock(Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createVNode(_component_el_overlay, {
        "z-index": _ctx.zIndex,
        "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
        mask: _ctx.modal
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            role: "dialog",
            "aria-label": _ctx.title,
            "aria-modal": "true",
            "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
            class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
            onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
            onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
            onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
          }, [
            createVNode(_component_el_focus_trap, {
              loop: "",
              trapped: _ctx.visible,
              "focus-trap-el": _ctx.rootRef,
              "focus-start-el": _ctx.focusStartRef,
              onReleaseRequested: _ctx.onCloseRequested
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  ref: "rootRef",
                  class: normalizeClass([
                    _ctx.ns.b(),
                    _ctx.customClass,
                    _ctx.ns.is("draggable", _ctx.draggable),
                    { [_ctx.ns.m("center")]: _ctx.center }
                  ]),
                  style: normalizeStyle(_ctx.customStyle),
                  tabindex: "-1",
                  onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "headerRef",
                    class: normalizeClass(_ctx.ns.e("header"))
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.ns.e("title"))
                    }, [
                      _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                        key: 0,
                        class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      createElementVNode("span", null, toDisplayString(_ctx.title), 1)
                    ], 2),
                    _ctx.showClose ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      type: "button",
                      class: normalizeClass(_ctx.ns.e("headerbtn")),
                      "aria-label": _ctx.t("el.messagebox.close"),
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      createVNode(_component_el_icon, {
                        class: normalizeClass(_ctx.ns.e("close"))
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_close)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, _hoisted_2$R)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    id: _ctx.contentId,
                    class: normalizeClass(_ctx.ns.e("content"))
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.ns.e("container"))
                    }, [
                      _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                        key: 0,
                        class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass(_ctx.ns.e("message"))
                      }, [
                        renderSlot(_ctx.$slots, "default", {}, () => [
                          !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                            key: 0,
                            for: _ctx.showInput ? _ctx.inputId : void 0
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                            ]),
                            _: 1
                          }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                            key: 1,
                            for: _ctx.showInput ? _ctx.inputId : void 0,
                            innerHTML: _ctx.message
                          }, null, 8, ["for", "innerHTML"]))
                        ])
                      ], 2)) : createCommentVNode("v-if", true)
                    ], 2),
                    withDirectives(createElementVNode("div", {
                      class: normalizeClass(_ctx.ns.e("input"))
                    }, [
                      createVNode(_component_el_input, {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        modelValue: _ctx.inputValue,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                        type: _ctx.inputType,
                        placeholder: _ctx.inputPlaceholder,
                        "aria-invalid": _ctx.validateError,
                        class: normalizeClass({ invalid: _ctx.validateError }),
                        onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      createElementVNode("div", {
                        class: normalizeClass(_ctx.ns.e("errormsg")),
                        style: normalizeStyle({
                          visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, toDisplayString(_ctx.editorErrorMessage), 7)
                    ], 2), [
                      [vShow, _ctx.showInput]
                    ])
                  ], 10, _hoisted_3$L),
                  createElementVNode("div", {
                    class: normalizeClass(_ctx.ns.e("btns"))
                  }, [
                    _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                      key: 0,
                      loading: _ctx.cancelButtonLoading,
                      class: normalizeClass([_ctx.cancelButtonClass]),
                      round: _ctx.roundButton,
                      size: _ctx.btnSize,
                      onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                      onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                    withDirectives(createVNode(_component_el_button, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: _ctx.confirmButtonLoading,
                      class: normalizeClass([_ctx.confirmButtonClasses]),
                      round: _ctx.roundButton,
                      disabled: _ctx.confirmButtonDisabled,
                      size: _ctx.btnSize,
                      onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                      onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [vShow, _ctx.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, _hoisted_1$U)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
const messageInstance = /* @__PURE__ */ new Map();
const initInstance = (props, container, appContext = null) => {
  const vnode = h(MessageBoxConstructor, props);
  vnode.appContext = appContext;
  render$H(vnode, container);
  document.body.appendChild(container.firstElementChild);
  return vnode.component;
};
const genContainer = () => {
  return document.createElement("div");
};
const showMessage = (options, appContext) => {
  const container = genContainer();
  options.onVanish = () => {
    render$H(null, container);
    messageInstance.delete(vm);
  };
  options.onAction = (action) => {
    const currentMsg = messageInstance.get(vm);
    let resolve21;
    if (options.showInput) {
      resolve21 = { value: vm.inputValue, action };
    } else {
      resolve21 = action;
    }
    if (options.callback) {
      options.callback(resolve21, instance.proxy);
    } else {
      if (action === "cancel" || action === "close") {
        if (options.distinguishCancelAndClose && action !== "cancel") {
          currentMsg.reject("close");
        } else {
          currentMsg.reject("cancel");
        }
      } else {
        currentMsg.resolve(resolve21);
      }
    }
  };
  const instance = initInstance(options, container, appContext);
  const vm = instance.proxy;
  for (const prop in options) {
    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
      vm[prop] = options[prop];
    }
  }
  watch(() => vm.message, (newVal, oldVal) => {
    if (isVNode(newVal)) {
      instance.slots.default = () => [newVal];
    } else if (isVNode(oldVal) && !isVNode(newVal)) {
      delete instance.slots.default;
    }
  }, {
    immediate: true
  });
  vm.visible = true;
  return vm;
};
function MessageBox(options, appContext = null) {
  if (!isClient)
    return Promise.reject();
  let callback;
  if (isString(options) || isVNode(options)) {
    options = {
      message: options
    };
  } else {
    callback = options.callback;
  }
  return new Promise((resolve21, reject) => {
    const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
    messageInstance.set(vm, {
      options,
      callback,
      resolve: resolve21,
      reject
    });
  });
}
const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
const MESSAGE_BOX_DEFAULT_OPTS = {
  alert: { closeOnPressEscape: false, closeOnClickModal: false },
  confirm: { showCancelButton: true },
  prompt: { showCancelButton: true, showInput: true }
};
MESSAGE_BOX_VARIANTS.forEach((boxType) => {
  MessageBox[boxType] = messageBoxFactory(boxType);
});
function messageBoxFactory(boxType) {
  return (message, titleOrOpts, options, appContext) => {
    let title;
    if (isObject(titleOrOpts)) {
      options = titleOrOpts;
      title = "";
    } else if (isUndefined(titleOrOpts)) {
      title = "";
    } else {
      title = titleOrOpts;
    }
    return MessageBox(Object.assign({
      title,
      message,
      type: "",
      ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
    }, options, {
      boxType
    }), appContext);
  };
}
MessageBox.close = () => {
  messageInstance.forEach((_, vm) => {
    vm.doClose();
  });
  messageInstance.clear();
};
MessageBox._context = null;
const _MessageBox = MessageBox;
_MessageBox.install = (app) => {
  _MessageBox._context = app._context;
  app.config.globalProperties.$msgbox = _MessageBox;
  app.config.globalProperties.$messageBox = _MessageBox;
  app.config.globalProperties.$alert = _MessageBox.alert;
  app.config.globalProperties.$confirm = _MessageBox.confirm;
  app.config.globalProperties.$prompt = _MessageBox.prompt;
};
const ElMessageBox = _MessageBox;
var base = /* @__PURE__ */ (() => '@charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\\5fae\\8f6f\\96c5\\9ed1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}\n')();
var elTooltip = /* @__PURE__ */ (() => "")();
var elPopper = /* @__PURE__ */ (() => '.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}\n')();
function noop$1() {
}
function clamp(val, min7, max7) {
  if (val < min7) {
    return min7;
  }
  if (val > max7) {
    return max7;
  }
  return val;
}
function readFileDataUrl(file) {
  const reader = new FileReader();
  return new Promise((resolve21, reject) => {
    reader.onload = (readerEvent) => resolve21(readerEvent.target.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
const _sfc_main$m = defineComponent({
  components: {
    ElTooltip,
    VIcon
  },
  props: {
    icon: {
      type: String,
      required: true
    },
    isActive: {
      type: Boolean,
      default: false
    },
    tooltip: {
      type: String,
      required: true
    },
    enableTooltip: {
      type: Boolean,
      required: true
    },
    command: {
      type: Function,
      default: noop$1
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    commandButtonClass() {
      return {
        "el-tiptap-editor__command-button": true,
        "el-tiptap-editor__command-button--active": this.isActive,
        "el-tiptap-editor__command-button--readonly": this.readonly
      };
    }
  },
  methods: {
    onClick() {
      if (!this.readonly)
        this.command();
    }
  }
});
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_icon = resolveComponent("v-icon");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createBlock(_component_el_tooltip, {
    content: _ctx.tooltip,
    "show-after": 350,
    disabled: !_ctx.enableTooltip || _ctx.readonly,
    effect: "dark",
    placement: "top"
  }, {
    default: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass(_ctx.commandButtonClass),
        onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }, [
        createVNode(_component_v_icon, { name: _ctx.icon }, null, 8, ["name"])
      ], 34)
    ]),
    _: 1
  }, 8, ["content", "disabled"]);
}
var CommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$m]]);
const _sfc_main$l = defineComponent({
  name: "OpenLinkCommandButton",
  components: {
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    },
    url: {
      type: String,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    return { t, enableTooltip };
  },
  methods: {
    openLink() {
      if (this.url) {
        const newTab = window.open();
        if (newTab) {
          newTab.opener = null;
          newTab.location.href = this.url;
        }
      }
    }
  }
});
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  return openBlock(), createBlock(_component_command_button, {
    command: _ctx.openLink,
    "enable-tooltip": _ctx.enableTooltip,
    tooltip: _ctx.t("editor.extensions.Link.open.tooltip"),
    icon: "external-link"
  }, null, 8, ["command", "enable-tooltip", "tooltip"]);
}
var OpenLinkCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$l]]);
var elDialog = /* @__PURE__ */ (() => ":root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px;word-break:break-all}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size);word-break:break-all}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}\n")();
var elOverlay = /* @__PURE__ */ (() => ".el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}\n")();
var elForm = /* @__PURE__ */ (() => '.el-form{--el-form-label-font-size:var(--el-font-size-base)}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk)>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk)>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}\n')();
var elFormItem = /* @__PURE__ */ (() => "")();
var elInput = /* @__PURE__ */ (() => ".el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{border-color:var(--el-color-danger)}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:100%;line-height:var(--el-input-height);box-sizing:border-box}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}\n")();
var elCheckbox = /* @__PURE__ */ (() => '.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;user-select:none;margin-right:30px;height:32px}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled .el-checkbox__inner+.el-checkbox__label{cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{box-sizing:content-box;content:"";border:1px solid var(--el-checkbox-checked-icon-color);border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}\n')();
var elButton = /* @__PURE__ */ (() => '.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}\n')();
const _sfc_main$k = defineComponent({
  name: "EditLinkCommandButton",
  components: {
    ElDialog,
    ElForm,
    ElFormItem,
    ElInput,
    ElCheckbox,
    ElButton,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    },
    initLinkAttrs: {
      type: Object,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    return { t, enableTooltip };
  },
  data() {
    return {
      linkAttrs: this.initLinkAttrs,
      editLinkDialogVisible: false
    };
  },
  methods: {
    updateLinkAttrs() {
      this.editor.commands.setLink(this.linkAttrs);
      this.closeEditLinkDialog();
    },
    openEditLinkDialog() {
      this.editLinkDialogVisible = true;
    },
    closeEditLinkDialog() {
      this.editLinkDialogVisible = false;
    }
  }
});
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_form_item = resolveComponent("el-form-item");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_form = resolveComponent("el-form");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_command_button, {
      command: _ctx.openEditLinkDialog,
      "enable-tooltip": _ctx.enableTooltip,
      tooltip: _ctx.t("editor.extensions.Link.edit.tooltip"),
      icon: "edit"
    }, null, 8, ["command", "enable-tooltip", "tooltip"]),
    createVNode(_component_el_dialog, {
      title: _ctx.t("editor.extensions.Link.edit.control.title"),
      visible: _ctx.editLinkDialogVisible,
      "append-to-body": true,
      width: "400px",
      "custom-class": "el-tiptap-edit-link-dialog"
    }, {
      footer: withCtx(() => [
        createVNode(_component_el_button, {
          size: "small",
          round: "",
          onClick: _ctx.closeEditLinkDialog
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.edit.control.cancel")), 1)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_el_button, {
          type: "primary",
          size: "small",
          round: "",
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onClick: _ctx.updateLinkAttrs
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.edit.control.confirm")), 1)
          ]),
          _: 1
        }, 8, ["onClick"])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_form, {
          model: _ctx.linkAttrs,
          "label-position": "right",
          size: "small"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_form_item, {
              label: _ctx.t("editor.extensions.Link.edit.control.href"),
              prop: "href"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: _ctx.linkAttrs.href,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.linkAttrs.href = $event),
                  autocomplete: "off"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }, 8, ["label"]),
            createVNode(_component_el_form_item, { prop: "openInNewTab" }, {
              default: withCtx(() => [
                createVNode(_component_el_checkbox, {
                  modelValue: _ctx.linkAttrs.openInNewTab,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.linkAttrs.openInNewTab = $event)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.edit.control.open_in_new_tab")), 1)
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model"])
      ]),
      _: 1
    }, 8, ["title", "visible"])
  ]);
}
var EditLinkCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$k]]);
const _sfc_main$j = defineComponent({
  name: "UnlinkCommandButton",
  components: {
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    return { t, enableTooltip };
  }
});
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  return openBlock(), createBlock(_component_command_button, {
    command: () => _ctx.editor.commands.unsetLink(),
    "enable-tooltip": _ctx.enableTooltip,
    tooltip: _ctx.t("editor.extensions.Link.unlink.tooltip"),
    icon: "unlink"
  }, null, 8, ["command", "enable-tooltip", "tooltip"]);
}
var UnlinkCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$j]]);
var LinkBubbleMenu_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".link-bubble-menu{display:-webkit-box;display:-ms-flexbox;display:flex}\n")();
const _sfc_main$i = defineComponent({
  name: "LinkBubbleMenu",
  components: {
    OpenLinkCommandButton,
    EditLinkCommandButton,
    UnlinkCommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  computed: {
    linkAttrs() {
      return this.editor.getAttributes("link");
    }
  }
});
const _hoisted_1$T = { class: "link-bubble-menu" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_open_link_command_button = resolveComponent("open-link-command-button");
  const _component_edit_link_command_button = resolveComponent("edit-link-command-button");
  const _component_unlink_command_button = resolveComponent("unlink-command-button");
  return openBlock(), createElementBlock("div", _hoisted_1$T, [
    renderSlot(_ctx.$slots, "prepend"),
    createVNode(_component_open_link_command_button, {
      url: _ctx.linkAttrs.href
    }, null, 8, ["url"]),
    createVNode(_component_edit_link_command_button, {
      editor: _ctx.editor,
      "init-link-attrs": _ctx.linkAttrs
    }, null, 8, ["editor", "init-link-attrs"]),
    createVNode(_component_unlink_command_button, { editor: _ctx.editor }, null, 8, ["editor"])
  ]);
}
var LinkBubbleMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$i]]);
const _sfc_main$h = defineComponent({
  name: "MenuBubble",
  components: {
    BubbleMenu,
    LinkBubbleMenu,
    VIcon
  },
  props: {
    editor: {
      type: Editor,
      required: true
    },
    menuBubbleOptions: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      activeMenu: "none",
      isLinkBack: false
    };
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  computed: {
    bubbleMenuEnable() {
      return this.linkMenuEnable || this.textMenuEnable;
    },
    linkMenuEnable() {
      const { schema } = this.editor;
      return !!schema.marks.link;
    },
    textMenuEnable() {
      const extensionManager = this.editor.extensionManager;
      return extensionManager.extensions.some((extension) => {
        return extension.options.bubble;
      });
    },
    isLinkSelection() {
      const { state } = this.editor;
      const { tr } = state;
      const { selection } = tr;
      return this.$_isLinkSelection(selection);
    }
  },
  watch: {
    "editor.state.selection": function(selection) {
      if (this.$_isLinkSelection(selection)) {
        if (!this.isLinkBack) {
          this.setMenuType("link");
        }
      } else {
        this.activeMenu = this.$_getCurrentMenuType();
        this.isLinkBack = false;
      }
    }
  },
  methods: {
    generateCommandButtonComponentSpecs() {
      const extensionManager = this.editor.extensionManager;
      return extensionManager.extensions.reduce((acc, extension) => {
        if (!extension.options.bubble)
          return acc;
        const { button } = extension.options;
        if (!button || typeof button !== "function")
          return acc;
        const menuBtnComponentSpec = button({
          editor: this.editor,
          t: this.t,
          extension
        });
        if (Array.isArray(menuBtnComponentSpec)) {
          return [...acc, ...menuBtnComponentSpec];
        }
        return [...acc, menuBtnComponentSpec];
      }, []);
    },
    linkBack() {
      this.setMenuType("default");
      this.isLinkBack = true;
    },
    setMenuType(type4) {
      this.activeMenu = type4;
    },
    $_isLinkSelection(selection) {
      const { schema } = this.editor;
      const linkType = schema.marks.link;
      if (!linkType)
        return false;
      if (!selection)
        return false;
      const { $from, $to } = selection;
      const range3 = getMarkRange($from, linkType);
      if (!range3)
        return false;
      return range3.to === $to.pos;
    },
    $_getCurrentMenuType() {
      if (this.isLinkSelection)
        return "link";
      if (this.editor.state.selection instanceof TextSelection$3 || this.editor.state.selection instanceof AllSelection$3) {
        return "default";
      }
      return "none";
    }
  }
});
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_icon = resolveComponent("v-icon");
  const _component_link_bubble_menu = resolveComponent("link-bubble-menu");
  const _component_bubble_menu = resolveComponent("bubble-menu");
  return _ctx.editor ? (openBlock(), createBlock(_component_bubble_menu, {
    key: 0,
    editor: _ctx.editor
  }, {
    default: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass([{
          "el-tiptap-editor__menu-bubble--active": _ctx.bubbleMenuEnable
        }, "el-tiptap-editor__menu-bubble"])
      }, [
        _ctx.activeMenu === "link" ? (openBlock(), createBlock(_component_link_bubble_menu, {
          key: 0,
          editor: _ctx.editor
        }, {
          prepend: withCtx(() => [
            _ctx.textMenuEnable ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "el-tiptap-editor__command-button",
              onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"])),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.linkBack && _ctx.linkBack(...args))
            }, [
              createVNode(_component_v_icon, { name: "arrow-left" })
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["editor"])) : _ctx.activeMenu === "default" ? (openBlock(true), createElementBlock(Fragment$6, { key: 1 }, renderList(_ctx.generateCommandButtonComponentSpecs(), (spec, i) => {
          return openBlock(), createBlock(resolveDynamicComponent(spec.component), mergeProps({
            key: "command-button" + i,
            "enable-tooltip": _ctx.enableTooltip
          }, spec.componentProps, { readonly: _ctx.isCodeViewMode }, toHandlers(spec.componentEvents || {})), null, 16, ["enable-tooltip", "readonly"]);
        }), 128)) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 1
  }, 8, ["editor"])) : createCommentVNode("", true);
}
var MenuBubble = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$h]]);
var ElementTiptap_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => '@charset "UTF-8";.el-tiptap-editor{-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:8px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;max-height:100%;position:relative;width:100%}.el-tiptap-editor *[class^=el-tiptap-editor]{-webkit-box-sizing:border-box;box-sizing:border-box}.el-tiptap-editor__codemirror{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;font-size:16px;line-height:24px;overflow:scroll}.el-tiptap-editor__codemirror .CodeMirror{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;height:auto}.el-tiptap-editor>.el-tiptap-editor__content{background-color:#fff;border:1px solid #ebeef5;border-top:0;border-bottom-left-radius:8px;border-bottom-right-radius:8px;color:#000;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;padding:30px 20px}.el-tiptap-editor--fullscreen{border-radius:0!important;bottom:0!important;height:100%!important;left:0!important;margin:0!important;position:fixed!important;right:0!important;top:0!important;width:100%!important;z-index:500}.el-tiptap-editor--fullscreen .el-tiptap-editor__menu-bar,.el-tiptap-editor--fullscreen .el-tiptap-editor__content,.el-tiptap-editor--fullscreen .el-tiptap-editor__footer{border-radius:0!important}.el-tiptap-editor--with-footer>.el-tiptap-editor__content{border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:0}.el-tiptap-editor__menu-bar{background-color:#fff;border:1px solid #ebeef5;border-bottom:0;border-top-left-radius:8px;border-top-right-radius:8px;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-negative:0;flex-shrink:0;-ms-flex-wrap:wrap;flex-wrap:wrap;padding:5px;position:relative}.el-tiptap-editor__menu-bar:before{bottom:0;background-color:#ebeef5;content:"";height:1px;left:0;margin:0 10px;right:0;position:absolute}.el-tiptap-editor__menu-bubble{background-color:#fff;border-radius:8px;-webkit-box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f;display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px;opacity:0;-webkit-transition:opacity .3s ease-in-out;transition:opacity .3s ease-in-out;visibility:hidden;z-index:50}.el-tiptap-editor__menu-bubble--active{opacity:1;visibility:visible}.el-tiptap-editor__content{-webkit-box-sizing:border-box;box-sizing:border-box;font-family:sans-serif;line-height:1.7;overflow-x:auto;text-align:left}.el-tiptap-editor__content>*{-webkit-box-sizing:border-box;box-sizing:border-box}.el-tiptap-editor__content p{margin-bottom:0;margin-top:0;outline:none}.el-tiptap-editor__content h1,.el-tiptap-editor__content h2,.el-tiptap-editor__content h3,.el-tiptap-editor__content h4,.el-tiptap-editor__content h5{margin-top:20px;margin-bottom:20px}.el-tiptap-editor__content h1:first-child,.el-tiptap-editor__content h2:first-child,.el-tiptap-editor__content h3:first-child,.el-tiptap-editor__content h4:first-child,.el-tiptap-editor__content h5:first-child{margin-top:0}.el-tiptap-editor__content h1:last-child,.el-tiptap-editor__content h2:last-child,.el-tiptap-editor__content h3:last-child,.el-tiptap-editor__content h4:last-child,.el-tiptap-editor__content h5:last-child{margin-bottom:0}.el-tiptap-editor__content ul,.el-tiptap-editor__content ol{counter-reset:none;list-style-type:none;margin-bottom:0;margin-left:24px;margin-top:0;padding-bottom:5px;padding-left:0;padding-top:5px}.el-tiptap-editor__content li>p{margin:0}.el-tiptap-editor__content li>p:first-child:before{content:counter(el-tiptap-counter) ".";display:inline-block;left:-5px;line-height:1;margin-left:-24px;position:relative;text-align:right;top:0;width:24px}.el-tiptap-editor__content ul li>p:first-child:before{content:"\\2022";text-align:center}.el-tiptap-editor__content ol{counter-reset:el-tiptap-counter}.el-tiptap-editor__content ol li>p:first-child:before{counter-increment:el-tiptap-counter}.el-tiptap-editor__content a{color:#409eff;cursor:pointer}.el-tiptap-editor__content blockquote{border-left:5px solid #edf2fc;border-radius:2px;color:#606266;margin:10px 0;padding-left:1em}.el-tiptap-editor__content code{background-color:#d9ecff;border-radius:4px;color:#409eff;display:inline-block;font-size:14px;font-weight:700;padding:0 8px}.el-tiptap-editor__content pre{background-color:#303133;color:#d9ecff;font-size:16px;overflow-x:auto;padding:14px 20px;margin:10px 0;border-radius:5px}.el-tiptap-editor__content pre code{background-color:transparent;border-radius:0;color:inherit;display:block;font-family:"Menlo,Monaco,Consolas,Courier,monospace";font-size:inherit;font-weight:400;padding:0}.el-tiptap-editor__content img{display:inline-block;float:none;margin:12px 0;max-width:100%}.el-tiptap-editor__content img[data-display=inline]{margin-left:12px;margin-right:12px}.el-tiptap-editor__content img[data-display=block]{display:block}.el-tiptap-editor__content img[data-display=left]{float:left;margin-left:0;margin-right:12px}.el-tiptap-editor__content img[data-display=right]{float:right;margin-left:12px;margin-right:0}.el-tiptap-editor__content .image-view{display:inline-block;float:none;line-height:0;margin:12px 0;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:baseline}.el-tiptap-editor__content .image-view--inline{margin-left:12px;margin-right:12px}.el-tiptap-editor__content .image-view--block{display:block}.el-tiptap-editor__content .image-view--left{float:left;margin-left:0;margin-right:12px}.el-tiptap-editor__content .image-view--right{float:right;margin-left:12px;margin-right:0}.el-tiptap-editor__content .image-view__body{clear:both;display:inline-block;max-width:100%;outline-color:transparent;outline-style:solid;outline-width:2px;-webkit-transition:all .2s ease-in;transition:all .2s ease-in;position:relative}.el-tiptap-editor__content .image-view__body:hover{outline-color:#ffc83d}.el-tiptap-editor__content .image-view__body--focused:hover,.el-tiptap-editor__content .image-view__body--resizing:hover{outline-color:transparent}.el-tiptap-editor__content .image-view__body__placeholder{height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.el-tiptap-editor__content .image-view__body__image{cursor:pointer;margin:0}.el-tiptap-editor__content .image-resizer{border:1px solid #409eff;height:100%;left:0;position:absolute;top:0;width:100%;z-index:1}.el-tiptap-editor__content .image-resizer__handler{background-color:#409eff;border:1px solid #fff;border-radius:2px;-webkit-box-sizing:border-box;box-sizing:border-box;display:block;height:12px;position:absolute;width:12px;z-index:2}.el-tiptap-editor__content .image-resizer__handler--tl{cursor:nw-resize;left:-6px;top:-6px}.el-tiptap-editor__content .image-resizer__handler--tr{cursor:ne-resize;right:-6px;top:-6px}.el-tiptap-editor__content .image-resizer__handler--bl{bottom:-6px;cursor:sw-resize;left:-6px}.el-tiptap-editor__content .image-resizer__handler--br{bottom:-6px;cursor:se-resize;right:-6px}.el-tiptap-editor__content ul[data-type=taskList]{margin-left:5px}.el-tiptap-editor__content ul[data-type=taskList] .task-item-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;margin-bottom:0;width:100%}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem][data-text-align=right]{-webkit-box-pack:end!important;-ms-flex-pack:end!important;justify-content:flex-end!important}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem][data-text-align=center]{-webkit-box-pack:center!important;-ms-flex-pack:center!important;justify-content:center!important}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem][data-text-align=justify]{text-align:space-between!important}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem] .todo-content{padding-left:10px;width:100%}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem] .todo-content>p{font-size:16px}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem] .todo-content>p:last-of-type{margin-bottom:0}.el-tiptap-editor__content ul[data-type=taskList] li[data-type=taskItem][data-done=done]>.todo-content>p{color:#409eff;text-decoration:line-through}.el-tiptap-editor__content hr{margin-top:20px;margin-bottom:20px}.el-tiptap-editor__content *[data-indent="1"]{margin-left:30px!important}.el-tiptap-editor__content *[data-indent="2"]{margin-left:60px!important}.el-tiptap-editor__content *[data-indent="3"]{margin-left:90px!important}.el-tiptap-editor__content *[data-indent="4"]{margin-left:120px!important}.el-tiptap-editor__content *[data-indent="5"]{margin-left:150px!important}.el-tiptap-editor__content *[data-indent="6"]{margin-left:180px!important}.el-tiptap-editor__content *[data-indent="7"]{margin-left:210px!important}.el-tiptap-editor__content .tableWrapper{margin:1em 0;overflow-x:auto}.el-tiptap-editor__content table{border-collapse:collapse;table-layout:fixed;width:100%;margin:0;overflow:hidden}.el-tiptap-editor__content th,.el-tiptap-editor__content td{border:2px solid #ebeef5;-webkit-box-sizing:border-box;box-sizing:border-box;min-width:1em;padding:3px 5px;position:relative;vertical-align:top}.el-tiptap-editor__content th.selectedCell,.el-tiptap-editor__content td.selectedCell{background-color:#ecf5ff}.el-tiptap-editor__content th{font-weight:500;text-align:left}.el-tiptap-editor__content .column-resize-handle{background-color:#b3d8ff;bottom:0;pointer-events:none;position:absolute;right:-2px;top:0;width:4px;z-index:20}.el-tiptap-editor__content .iframe{height:0;padding-bottom:56.25%;position:relative;width:100%}.el-tiptap-editor__content .iframe__embed{border:0;height:100%;left:0;position:absolute;top:0;width:100%}.el-tiptap-editor__content .resize-cursor{cursor:ew-resize;cursor:col-resize}.el-tiptap-editor__footer{-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:#fff;border:1px solid #ebeef5;border-bottom-left-radius:8px;border-bottom-right-radius:8px;display:-webkit-box;display:-ms-flexbox;display:flex;font-family:sans-serif;font-size:14px;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;padding:10px}.el-tiptap-editor .ProseMirror{outline:0}.el-tiptap-editor__placeholder.el-tiptap-editor--empty:first-child:before{color:#c0c4cc;content:attr(data-placeholder);float:left;height:0;pointer-events:none}.el-tiptap-editor__with-title-placeholder:nth-child(1):before,.el-tiptap-editor__with-title-placeholder:nth-child(2):before{color:#c0c4cc;content:attr(data-placeholder);float:left;height:0;pointer-events:none}.el-tiptap-editor__characters{color:#939599}.el-tiptap-editor__command-button{border:1px solid transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:50%;color:#303133;cursor:pointer;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;height:40px;margin:2px;outline:0;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;width:40px}.el-tiptap-editor__command-button:hover{background-color:#e4e9f2}.el-tiptap-editor__command-button--active{background-color:#ecf5ff;color:#409eff}.el-tiptap-editor__command-button--readonly{cursor:default;opacity:.3;pointer-events:none}.el-tiptap-editor__command-button--readonly:hover{background-color:transparent}.el-tiptap-dropdown-popper .el-dropdown-menu__item{padding:0}.el-tiptap-dropdown-menu .el-tiptap-dropdown-menu__item{color:#303133;line-height:1.5;padding:5px 20px;width:100%}.el-tiptap-dropdown-menu .el-tiptap-dropdown-menu__item [data-item-type=heading]{margin-bottom:0;margin-top:0}.el-tiptap-dropdown-menu .el-tiptap-dropdown-menu__item--active{background-color:#ecf5ff;color:#409eff}.el-tiptap-popper{width:auto!important}.el-tiptap-popper.el-popper{min-width:0}.el-tiptap-popper__menu__item{color:#303133;cursor:pointer;padding:8px 0}.el-tiptap-popper__menu__item:hover,.el-tiptap-popper__menu__item--active{color:#409eff}.el-tiptap-popper__menu__item--disabled{cursor:default;opacity:.2}.el-tiptap-popper__menu__item--disabled:hover{color:inherit}.el-tiptap-popper__menu__item__separator{border-top:1px solid #dcdfe6;height:0;margin:5px 0;width:100%}.el-tiptap-upload{display:-webkit-box;display:-ms-flexbox;display:flex}.el-tiptap-upload .el-upload{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1}.el-tiptap-upload .el-upload-dragger{-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;height:300px;width:100%}.el-tiptap-upload .el-upload-dragger .el-tiptap-upload__icon{font-size:50px;margin-bottom:10px}.el-tiptap-upload .el-upload-dragger:hover .el-tiptap-upload__icon{color:#409eff}.color-set{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;width:240px}.color-set .color{border-radius:50%;-webkit-box-shadow:rgba(0,0,0,.2) 0px 3px 3px -2px,rgba(0,0,0,.14) 0px 3px 4px 0px,rgba(0,0,0,.12) 0px 1px 8px 0px;box-shadow:#0003 0 3px 3px -2px,#00000024 0 3px 4px,#0000001f 0 1px 8px;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:30px;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;width:30px}.color-set .color__wrapper{-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-sizing:border-box;box-sizing:border-box;cursor:pointer;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 0 12.5%;flex:0 0 12.5%;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:5px}.color-set .color:hover,.color-set .color--selected{border:2px solid #fff;-webkit-transform:scale(1.3);transform:scale(1.3)}.color-set .color--remove{position:relative}.color-set .color--remove:hover:before{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.color-set .color--remove:hover:after{-webkit-transform:rotate(45deg);transform:rotate(45deg)}.color-set .color--remove:before,.color-set .color--remove:after{background-color:#f56c6c;bottom:0;content:"";left:50%;position:absolute;margin:2px 0;top:0;-webkit-transform:translateX(-50%);transform:translate(-50%);-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;width:2px}.color-hex{-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-top:10px}.color-hex .color-hex__button{margin-left:10px;padding-left:15px;padding-right:15px}.table-grid-size-editor__body{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.table-grid-size-editor__row{display:-webkit-box;display:-ms-flexbox;display:flex}.table-grid-size-editor__cell{background-color:#fff;padding:5px}.table-grid-size-editor__cell__inner{border:1px solid #dcdfe6;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:2px;height:16px;padding:4px;width:16px}.table-grid-size-editor__cell--selected .table-grid-size-editor__cell__inner{background-color:#ecf5ff;border-color:#409eff}.table-grid-size-editor__footer{margin-top:5px;text-align:center}.el-tiptap-edit-image-dialog .el-form-item:last-child{margin-bottom:0}.el-tiptap-edit-image-dialog input[type=number]::-webkit-inner-spin-button,.el-tiptap-edit-image-dialog input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none}.el-tiptap-edit-link-dialog .el-form-item:last-child{margin-bottom:0}.el-popper.el-tiptap-image-popper{background-color:#fff;border-radius:8px;-webkit-box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f;min-width:0;padding:5px}.el-popper.el-tiptap-image-popper .image-bubble-menu{-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}\n')();
const _sfc_main$g = defineComponent({
  name: "ElementTiptap",
  components: {
    EditorContent,
    MenuBar,
    MenuBubble
  },
  props: {
    content: {
      type: String,
      default: ""
    },
    extensions: {
      type: Array,
      default: []
    },
    placeholder: {
      type: String,
      default: ""
    },
    lang: {
      type: String,
      default: "en"
    },
    width: {
      type: [String, Number],
      default: void 0
    },
    height: {
      type: [String, Number],
      default: void 0
    },
    output: {
      type: String,
      default: "html",
      validator(output) {
        return ["html", "json"].includes(output);
      }
    },
    spellcheck: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    tooltip: {
      type: Boolean,
      default: true
    },
    enableCharCount: {
      type: Boolean,
      default: true
    },
    charCountMax: {
      type: Number,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    editorClass: {
      type: [String, Array, Object],
      default: void 0
    },
    editorContentClass: {
      type: [String, Array, Object],
      default: void 0
    },
    editorMenubarClass: {
      type: [String, Array, Object],
      default: void 0
    },
    editorBubbleMenuClass: {
      type: [String, Array, Object],
      default: void 0
    },
    editorFooterClass: {
      type: [String, Array, Object],
      default: void 0
    }
  },
  setup(props, { emit }) {
    const extensions2 = props.extensions.concat([
      Placeholder.configure({
        emptyEditorClass: "el-tiptap-editor--empty",
        emptyNodeClass: "el-tiptap-editor__placeholder",
        showOnlyCurrent: false,
        placeholder: ({ node: node8 }) => {
          return props.placeholder;
        }
      }),
      props.enableCharCount ? CharacterCount.configure({
        limit: props.charCountMax
      }) : null
    ]).filter(Boolean);
    const onUpdate = ({ editor: editor2 }) => {
      let output;
      if (props.output === "html") {
        output = editor2.getHTML();
      } else {
        output = editor2.getJSON();
      }
      emit("update:content", output);
      emit("onUpdate", output, editor2);
    };
    const editor = useEditor({
      content: props.content,
      extensions: extensions2,
      editable: !props.readonly,
      onCreate: (options) => {
        emit("onCreate", options);
      },
      onTransaction: (options) => {
        emit("onTransaction", options);
      },
      onFocus: (options) => {
        emit("onFocus", options);
      },
      onBlur: (options) => {
        emit("onBlur", options);
      },
      onDestroy: (options) => {
        emit("onDestroy", options);
      },
      onUpdate
    });
    watchEffect(() => {
      var _a2;
      (_a2 = unref(editor)) == null ? void 0 : _a2.setOptions({
        editorProps: {
          attributes: {
            spellcheck: String(props.spellcheck)
          }
        }
      });
    });
    const i18nHandler = Trans.buildI18nHandler(toRaw(props.locale));
    const t = (...args) => {
      return i18nHandler.apply(Trans, args);
    };
    const isFullscreen = ref(false);
    const toggleFullscreen = (val) => {
      isFullscreen.value = val;
    };
    provide("isFullscreen", isFullscreen);
    provide("toggleFullscreen", toggleFullscreen);
    provide("enableTooltip", props.tooltip);
    const { isCodeViewMode, cmTextAreaRef } = useCodeView(editor);
    provide("isCodeViewMode", isCodeViewMode);
    const { characters } = useCharacterCount(editor);
    const showFooter = computed(() => {
      return props.enableCharCount && !unref(isCodeViewMode);
    });
    const editorStyle = useEditorStyle({
      width: props.width,
      height: props.height
    });
    provide("t", t);
    provide("et", this);
    return {
      t,
      editor,
      characters,
      showFooter,
      isFullscreen,
      isCodeViewMode,
      cmTextAreaRef,
      editorStyle
    };
  }
});
const _hoisted_1$S = { ref: "cmTextAreaRef" };
const _hoisted_2$Q = { class: "el-tiptap-editor__characters" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_menu_bubble = resolveComponent("menu-bubble");
  const _component_menu_bar = resolveComponent("menu-bar");
  const _component_editor_content = resolveComponent("editor-content");
  return _ctx.editor ? (openBlock(), createElementBlock("div", {
    key: 0,
    style: normalizeStyle(_ctx.editorStyle),
    class: normalizeClass([
      {
        "el-tiptap-editor": true,
        "el-tiptap-editor--fullscreen": _ctx.isFullscreen,
        "el-tiptap-editor--with-footer": _ctx.showFooter
      },
      _ctx.editorClass
    ])
  }, [
    createVNode(_component_menu_bubble, {
      editor: _ctx.editor,
      class: normalizeClass(_ctx.editorBubbleMenuClass)
    }, null, 8, ["editor", "class"]),
    createVNode(_component_menu_bar, {
      editor: _ctx.editor,
      class: normalizeClass(_ctx.editorMenubarClass)
    }, null, 8, ["editor", "class"]),
    _ctx.isCodeViewMode ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass({
        "el-tiptap-editor__codemirror": true,
        "border-bottom-radius": _ctx.isCodeViewMode
      })
    }, [
      createElementVNode("textarea", _hoisted_1$S, null, 512)
    ], 2)) : createCommentVNode("", true),
    withDirectives(createVNode(_component_editor_content, {
      editor: _ctx.editor,
      class: normalizeClass([
        {
          "el-tiptap-editor__content": true
        },
        _ctx.editorContentClass
      ])
    }, null, 8, ["editor", "class"]), [
      [vShow, !_ctx.isCodeViewMode]
    ]),
    _ctx.showFooter ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass([
        {
          "el-tiptap-editor__footer": true
        },
        _ctx.editorFooterClass
      ])
    }, [
      createElementVNode("span", _hoisted_2$Q, toDisplayString(_ctx.t("editor.characters")) + ": " + toDisplayString(_ctx.characters), 1)
    ], 2)) : createCommentVNode("", true)
  ], 6)) : createCommentVNode("", true);
}
var ElementTiptap = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$g]]);
const Text$1 = Node$4.create({
  name: "text",
  group: "inline"
});
const Document$1 = Node$4.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
const Title = Node$4.create({
  name: "title",
  content: "inline*",
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      placeholder: ""
    };
  },
  parseHTML() {
    return [{ tag: "h1" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["h1", mergeAttributes(HTMLAttributes), 0];
  }
});
const Document = Document$1.extend({
  addOptions() {
    return {
      title: false
    };
  },
  content() {
    return !!this.options.title ? "title block+" : "block+";
  },
  addExtensions() {
    if (this.options.title) {
      return [Title];
    }
    return [];
  }
});
const Paragraph = Node$4.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const Heading$1 = Node$4.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node: node8, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node8.attrs.level);
    const level = hasLevel ? node8.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var elDropdown = /* @__PURE__ */ (() => '.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}\n')();
var elDropdownItem = /* @__PURE__ */ (() => "")();
var elDropdownMenu = /* @__PURE__ */ (() => "")();
const _sfc_main$f = defineComponent({
  name: "HeadingDropdown",
  components: {
    ElDropdown,
    ElDropdownMenu,
    ElDropdownItem,
    CommandButton
  },
  props: {
    editor: {
      type: Editor$1,
      required: true
    },
    levels: {
      type: Array,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  methods: {
    toggleHeading(level) {
      if (level > 0) {
        this.editor.commands.toggleHeading({ level });
      } else {
        this.editor.commands.setParagraph();
      }
    }
  }
});
const _hoisted_1$R = { class: "el-dropdown-link" };
const _hoisted_2$P = { key: 1 };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_dropdown_item = resolveComponent("el-dropdown-item");
  const _component_el_dropdown_menu = resolveComponent("el-dropdown-menu");
  const _component_el_dropdown = resolveComponent("el-dropdown");
  return openBlock(), createBlock(_component_el_dropdown, {
    placement: "bottom",
    trigger: "click",
    "popper-class": "el-tiptap-dropdown-popper",
    onCommand: _ctx.toggleHeading
  }, {
    dropdown: withCtx(() => [
      createVNode(_component_el_dropdown_menu, { class: "el-tiptap-dropdown-menu" }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment$6, null, renderList([0, ..._ctx.levels], (level) => {
            return openBlock(), createBlock(_component_el_dropdown_item, {
              key: level,
              command: level
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass([
                    {
                      "el-tiptap-dropdown-menu__item--active": level > 0 ? _ctx.editor.isActive("heading", {
                        level
                      }) : _ctx.editor.isActive("paragraph")
                    },
                    "el-tiptap-dropdown-menu__item"
                  ])
                }, [
                  level > 0 ? (openBlock(), createBlock(resolveDynamicComponent("h" + level), {
                    key: 0,
                    "data-item-type": "heading"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.t("editor.extensions.Heading.buttons.heading")) + " " + toDisplayString(level), 1)
                    ]),
                    _: 2
                  }, 1024)) : (openBlock(), createElementBlock("span", _hoisted_2$P, toDisplayString(_ctx.t("editor.extensions.Heading.buttons.paragraph")), 1))
                ], 2)
              ]),
              _: 2
            }, 1032, ["command"]);
          }), 128))
        ]),
        _: 1
      })
    ]),
    default: withCtx(() => [
      createElementVNode("span", _hoisted_1$R, [
        createVNode(_component_command_button, {
          "enable-tooltip": _ctx.enableTooltip,
          "is-active": _ctx.editor.isActive("heading"),
          tooltip: _ctx.t("editor.extensions.Heading.tooltip"),
          disabled: _ctx.isCodeViewMode,
          icon: "heading"
        }, null, 8, ["enable-tooltip", "is-active", "tooltip", "disabled"])
      ])
    ]),
    _: 1
  }, 8, ["onCommand"]);
}
var HeadingDropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$f]]);
const Heading = Heading$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({
        editor,
        extension
      }) {
        console.log("Heading==========", extension.options);
        return {
          component: HeadingDropdown,
          componentProps: {
            levels: extension.options.levels,
            editor
          }
        };
      }
    };
  }
});
const inputRegex$7 = /^\s*>\s$/;
const Blockquote$1 = Node$4.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$7,
        type: this.type
      })
    ];
  }
});
const Blockquote = Blockquote$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleBlockquote();
            },
            isActive: editor.isActive("blockquote"),
            icon: "quote-right",
            tooltip: t("editor.extensions.Blockquote.tooltip")
          }
        };
      }
    };
  }
});
const backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock$1 = Node$4.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (element) => {
          var _a2;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a2 = element.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: node8, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node8.attrs.language ? this.options.languageClassPrefix + node8.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands }) => {
        return commands.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands }) => {
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr }) => {
          tr.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after6 = $from.after();
        if (after6 === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after6);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        key: new PluginKey$1("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text3 = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text3 || !language) {
              return false;
            }
            const { tr } = view.state;
            tr.replaceSelectionWith(this.type.create({ language }));
            tr.setSelection(TextSelection$3.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
            tr.insertText(text3.replace(/\r\n?/g, "\n"));
            tr.setMeta("paste", true);
            view.dispatch(tr);
            return true;
          }
        }
      })
    ];
  }
});
const CodeBlock = CodeBlock$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleCodeBlock();
            },
            isActive: editor.isActive("codeBlock"),
            icon: "code",
            tooltip: t("editor.extensions.CodeBlock.tooltip")
          }
        };
      }
    };
  }
});
const inputRegex$6 = /^\s*([-+*])\s$/;
const BulletList$1 = Node$4.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$6,
        type: this.type
      })
    ];
  }
});
const ListItem = Node$4.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const BulletList = BulletList$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleBulletList();
            },
            isActive: editor.isActive("bulletList"),
            icon: "list-ul",
            tooltip: t("editor.extensions.BulletList.tooltip")
          }
        };
      }
    };
  },
  addExtensions() {
    return [ListItem];
  }
});
const inputRegex$5 = /^(\d+)\.\s$/;
const OrderedList$1 = Node$4.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start8, ...attributesWithoutStart } = HTMLAttributes;
    return start8 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$5,
        type: this.type,
        getAttributes: (match) => ({ start: +match[1] }),
        joinPredicate: (match, node8) => node8.childCount + node8.attrs.start === +match[1]
      })
    ];
  }
});
const OrderedList = OrderedList$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleOrderedList();
            },
            isActive: editor.isActive("orderedList"),
            icon: "list-ol",
            tooltip: t("editor.extensions.OrderedList.tooltip")
          }
        };
      }
    };
  },
  addExtensions() {
    return [ListItem];
  }
});
const inputRegex$4 = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))/;
const Image$1 = Node$4.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands }) => {
        return commands.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex$4,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});
var elUpload = /* @__PURE__ */ (() => '@charset "UTF-8";.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px}.el-upload{display:inline-flex;justify-content:center;align-items:center;cursor:pointer;outline:0}.el-upload__input{display:none}.el-upload__tip{font-size:12px;color:var(--el-text-color-regular);margin-top:7px}.el-upload iframe{position:absolute;z-index:-1;top:0;left:0;opacity:0}.el-upload--picture-card{--el-upload-picture-card-size:148px;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;width:var(--el-upload-picture-card-size);height:var(--el-upload-picture-card-size);cursor:pointer;vertical-align:top;display:inline-flex;justify-content:center;align-items:center}.el-upload--picture-card i{font-size:28px;color:var(--el-text-color-secondary)}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;text-align:center;cursor:pointer;position:relative;overflow:hidden}.el-upload-dragger .el-icon--upload{font-size:67px;color:var(--el-text-color-placeholder);margin-bottom:16px;line-height:50px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px);background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary)}.el-upload-list{margin:10px 0 0;padding:0;list-style:none;position:relative}.el-upload-list__item{transition:all .5s cubic-bezier(.55,0,.1,1);font-size:14px;color:var(--el-text-color-regular);margin-bottom:5px;position:relative;box-sizing:border-box;border-radius:4px;width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{display:none;position:absolute;right:5px;top:50%;cursor:pointer;opacity:.75;color:var(--el-text-color-regular);transition:opacity var(--el-transition-duration);transform:translateY(-50%)}.el-upload-list__item .el-icon--close:hover{opacity:1;color:var(--el-color-primary)}.el-upload-list__item .el-icon--close-tip{display:none;position:absolute;top:1px;right:5px;font-size:12px;cursor:pointer;opacity:1;color:var(--el-color-primary);font-style:normal}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;justify-content:center;flex-direction:column;width:calc(100% - 30px);margin-left:4px}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list.is-disabled .el-upload-list__item-status-label,.el-upload-list.is-disabled .el-upload-list__item:hover{display:block}.el-upload-list__item-name{color:var(--el-text-color-regular);display:inline-flex;text-align:center;align-items:center;padding:0 4px;transition:color var(--el-transition-duration);font-size:var(--el-font-size-base)}.el-upload-list__item-name .el-icon{margin-right:6px;color:var(--el-text-color-secondary)}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{position:absolute;right:5px;top:0;line-height:inherit;display:none;height:100%;justify-content:center;align-items:center;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{position:absolute;right:10px;top:0;font-size:12px;color:var(--el-text-color-regular);display:none}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{overflow:hidden;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;width:var(--el-upload-list-picture-card-size);height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;padding:0;display:inline-flex}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{width:100%;height:100%;object-fit:contain}.el-upload-list--picture-card .el-upload-list__item-status-label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{position:absolute;width:100%;height:100%;left:0;top:0;cursor:default;display:inline-flex;justify-content:center;align-items:center;color:#fff;opacity:0;font-size:20px;background-color:var(--el-overlay-color-lighter);transition:opacity var(--el-transition-duration)}.el-upload-list--picture-card .el-upload-list__item-actions span{display:none;cursor:pointer}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:1rem}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{position:static;font-size:inherit;color:inherit}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{top:50%;left:50%;transform:translate(-50%,-50%);bottom:auto;width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{overflow:hidden;z-index:0;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;margin-top:10px;padding:10px}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{display:inline-flex;justify-content:center;align-items:center;width:70px;height:70px;object-fit:contain;position:relative;z-index:1;background-color:var(--el-color-white)}.el-upload-list--picture .el-upload-list__item-status-label{position:absolute;right:-17px;top:-7px;width:46px;height:26px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{position:absolute;left:0;top:0;width:100%;height:100%;overflow:hidden;z-index:10;cursor:default}.el-upload-cover:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-upload-cover img{display:block;width:100%;height:100%}.el-upload-cover__label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-cover__label i{font-size:12px;margin-top:11px;transform:rotate(-45deg);color:#fff}.el-upload-cover__progress{display:inline-block;vertical-align:middle;position:static;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{position:absolute;top:0;left:0;width:100%;height:100%}.el-upload-cover__interact{position:absolute;bottom:0;left:0;width:100%;height:100%;background-color:var(--el-overlay-color-light);text-align:center}.el-upload-cover__interact .btn{display:inline-block;color:#fff;font-size:14px;cursor:pointer;vertical-align:middle;transition:var(--el-transition-md-fade);margin-top:60px}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{position:absolute;bottom:0;left:0;background-color:#fff;height:36px;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:400;text-align:left;padding:0 10px;margin:0;line-height:36px;font-size:14px;color:var(--el-text-color-primary)}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}\n')();
var elProgress = /* @__PURE__ */ (() => '.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translateY(-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);animation:indeterminate 3s infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}\n')();
var elMessageBox = /* @__PURE__ */ (() => ':root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;width:var(--el-messagebox-width);padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status:before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}\n')();
var elPopover = /* @__PURE__ */ (() => ".el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;text-align:justify;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);word-break:break-all}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}\n")();
var elLoading = /* @__PURE__ */ (() => ":root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{position:absolute;z-index:2000;background-color:var(--el-mask-color);margin:0;top:0;right:0;bottom:0;left:0;transition:opacity var(--el-transition-duration)}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/ 2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{top:50%;margin-top:calc((0px - var(--el-loading-spinner-size))/ 2);width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);margin:3px 0;font-size:14px}.el-loading-spinner .circular{display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size);animation:loading-rotate 2s linear infinite}.el-loading-spinner .path{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@keyframes loading-rotate{to{transform:rotate(360deg)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}\n")();
var ImageDisplay = /* @__PURE__ */ ((ImageDisplay2) => {
  ImageDisplay2["INLINE"] = "inline";
  ImageDisplay2["BREAK_TEXT"] = "block";
  ImageDisplay2["FLOAT_LEFT"] = "left";
  ImageDisplay2["FLOAT_RIGHT"] = "right";
  return ImageDisplay2;
})(ImageDisplay || {});
const ELEMENT_TIPTAP_TIP = "[Element-Tiptap Tip]";
const DEFAULT_IMAGE_URL_REGEX = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/;
const DEFAULT_IMAGE_DISPLAY = ImageDisplay.INLINE;
const LINE_HEIGHT_100 = 1.7;
const DEFAULT_LINE_HEIGHT = "100%";
class Logger {
  static warn(msg) {
    console.warn(`${ELEMENT_TIPTAP_TIP} ${msg}`);
  }
  static error(msg) {
    console.error(`${ELEMENT_TIPTAP_TIP} ${msg}`);
  }
}
const _sfc_main$e = defineComponent({
  name: "ImageCommandButton",
  components: {
    ElDialog,
    ElUpload,
    ElPopover,
    CommandButton
  },
  props: {
    editor: {
      type: Editor$1,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  data() {
    return {
      imageUploadDialogVisible: false,
      uploading: false
    };
  },
  computed: {
    imageNodeOptions() {
      return this.editor.extensionManager.extensions.find((e) => e.name === "image").options;
    }
  },
  methods: {
    openUrlPrompt() {
      ElMessageBox.prompt("", this.t("editor.extensions.Image.control.insert_by_url.title"), {
        confirmButtonText: this.t("editor.extensions.Image.control.insert_by_url.confirm"),
        cancelButtonText: this.t("editor.extensions.Image.control.insert_by_url.cancel"),
        inputPlaceholder: this.t("editor.extensions.Image.control.insert_by_url.placeholder"),
        inputPattern: this.imageNodeOptions.urlPattern,
        inputErrorMessage: this.t("editor.extensions.Image.control.insert_by_url.invalid_url"),
        roundButton: true
      }).then(({ value: url2 }) => {
        this.editor.commands.setImage({ src: url2 });
      }).catch((e) => {
        Logger.error(String(e));
      });
    },
    async uploadImage(requestOptions) {
      const { file } = requestOptions;
      const uploadRequest = this.imageNodeOptions.uploadRequest;
      const loadingInstance = ElLoading.service({
        target: ".el-tiptap-upload"
      });
      try {
        const url2 = await (uploadRequest ? uploadRequest(file) : readFileDataUrl(file));
        this.editor.commands.setImage({ src: url2 });
        this.imageUploadDialogVisible = false;
      } catch (e) {
        Logger.error(String(e));
      } finally {
        this.$nextTick(() => {
          loadingInstance.close();
        });
      }
    }
  }
});
const _hoisted_1$Q = { class: "el-tiptap-popper__menu" };
const _hoisted_2$O = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-upload__icon" }, [
  /* @__PURE__ */ createElementVNode("i", { class: "fa fa-upload" })
], -1);
const _hoisted_3$K = { class: "el-tiptap-upload__text" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_popover = resolveComponent("el-popover");
  const _component_el_upload = resolveComponent("el-upload");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock(Fragment$6, null, [
    createVNode(_component_el_popover, {
      disabled: _ctx.isCodeViewMode,
      placement: "bottom",
      trigger: "click",
      "popper-class": "el-tiptap-popper"
    }, {
      reference: withCtx(() => [
        createElementVNode("span", null, [
          createVNode(_component_command_button, {
            "enable-tooltip": _ctx.enableTooltip,
            tooltip: _ctx.t("editor.extensions.Image.buttons.insert_image.tooltip"),
            readonly: _ctx.isCodeViewMode,
            icon: "image"
          }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$Q, [
          createElementVNode("div", {
            class: "el-tiptap-popper__menu__item",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openUrlPrompt && _ctx.openUrlPrompt(...args))
          }, [
            createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Image.buttons.insert_image.external")), 1)
          ]),
          createElementVNode("div", {
            class: "el-tiptap-popper__menu__item",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.imageUploadDialogVisible = true)
          }, [
            createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Image.buttons.insert_image.upload")), 1)
          ])
        ])
      ]),
      _: 1
    }, 8, ["disabled"]),
    createVNode(_component_el_dialog, {
      modelValue: _ctx.imageUploadDialogVisible,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.imageUploadDialogVisible = $event),
      title: _ctx.t("editor.extensions.Image.control.upload_image.title"),
      "append-to-body": true
    }, {
      default: withCtx(() => [
        createVNode(_component_el_upload, {
          "http-request": _ctx.uploadImage,
          "show-file-list": false,
          class: "el-tiptap-upload",
          action: "#",
          drag: "",
          accept: "image/*"
        }, {
          default: withCtx(() => [
            _hoisted_2$O,
            createElementVNode("div", _hoisted_3$K, toDisplayString(_ctx.t("editor.extensions.Image.control.upload_image.button")), 1)
          ]),
          _: 1
        }, 8, ["http-request"])
      ]),
      _: 1
    }, 8, ["modelValue", "title"])
  ], 64);
}
var InsertImageCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$e]]);
const Image = Image$1.extend({
  inline() {
    return true;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      display: {
        default: DEFAULT_IMAGE_DISPLAY,
        parseHTML: (element) => {
          const { cssFloat, display } = element.style;
          let dp = element.getAttribute("data-display") || element.getAttribute("display");
          if (dp) {
            dp = /(inline|block|left|right)/.test(dp) ? dp : ImageDisplay.INLINE;
          } else if (cssFloat === "left" && !display) {
            dp = ImageDisplay.FLOAT_LEFT;
          } else if (cssFloat === "right" && !display) {
            dp = ImageDisplay.FLOAT_RIGHT;
          } else if (!cssFloat && display === "block") {
            dp = ImageDisplay.BREAK_TEXT;
          } else {
            dp = ImageDisplay.INLINE;
          }
          return dp;
        },
        renderHTML: (attributes) => {
          return {
            "data-display": attributes.display
          };
        }
      }
    };
  },
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      inline: true,
      uploadRequest: null,
      urlPattern: DEFAULT_IMAGE_URL_REGEX,
      button({ editor }) {
        return {
          component: InsertImageCommandButton,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "img[src]"
      }
    ];
  }
});
const TaskList$1 = Node$4.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
const inputRegex$3 = /^\s*(\[([ |x])\])\s$/;
const TaskItem$1 = Node$4.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {}
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => element.getAttribute("data-checked") === "true",
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: node8, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node8.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      [
        "div",
        0
      ]
    ];
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node: node8, HTMLAttributes, getPos, editor }) => {
      const listItem = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content4 = document.createElement("div");
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {
            const position = getPos();
            const currentNode = tr.doc.nodeAt(position);
            tr.setNodeMarkup(position, void 0, {
              ...currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key2, value]) => {
        listItem.setAttribute(key2, value);
      });
      listItem.dataset.checked = node8.attrs.checked;
      if (node8.attrs.checked) {
        checkbox.setAttribute("checked", "checked");
      }
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem.append(checkboxWrapper, content4);
      Object.entries(HTMLAttributes).forEach(([key2, value]) => {
        listItem.setAttribute(key2, value);
      });
      return {
        dom: listItem,
        contentDOM: content4,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem.dataset.checked = updatedNode.attrs.checked;
          if (updatedNode.attrs.checked) {
            checkbox.setAttribute("checked", "checked");
          } else {
            checkbox.removeAttribute("checked");
          }
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$3,
        type: this.type,
        getAttributes: (match) => ({
          checked: match[match.length - 1] === "x"
        })
      })
    ];
  }
});
const _sfc_main$d = defineComponent({
  name: "TaskItemView",
  components: {
    NodeViewWrapper,
    NodeViewContent,
    ElCheckbox
  },
  props: nodeViewProps,
  computed: {
    done: {
      get() {
        var _a2;
        return (_a2 = this.node) == null ? void 0 : _a2.attrs.done;
      },
      set(done2) {
        var _a2;
        (_a2 = this.updateAttributes) == null ? void 0 : _a2.call(this, {
          done: done2
        });
      }
    }
  }
});
const _hoisted_1$P = ["data-type", "data-done"];
const _hoisted_2$N = { contenteditable: "false" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_node_view_content = resolveComponent("node-view-content");
  const _component_node_view_wrapper = resolveComponent("node-view-wrapper");
  return openBlock(), createBlock(_component_node_view_wrapper, { class: "task-item-wrapper" }, {
    default: withCtx(() => {
      var _a2;
      return [
        createElementVNode("li", {
          "data-type": (_a2 = _ctx.node) == null ? void 0 : _a2.type.name,
          "data-done": _ctx.done.toString(),
          "data-drag-handle": ""
        }, [
          createElementVNode("span", _hoisted_2$N, [
            createVNode(_component_el_checkbox, {
              modelValue: _ctx.done,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.done = $event)
            }, null, 8, ["modelValue"])
          ]),
          createVNode(_component_node_view_content, { class: "todo-content" })
        ], 8, _hoisted_1$P)
      ];
    }),
    _: 1
  });
}
var TaskItemView = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$d]]);
const TaskItem = TaskItem$1.extend({
  addAttributes() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      done: {
        default: false,
        parseHTML: (element) => element.getAttribute("data-done") === "true"
      }
    };
  },
  renderHTML({ node: node8, HTMLAttributes }) {
    const { done: done2 } = node8.attrs;
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "span",
        {
          contenteditable: "false"
        },
        [
          "span",
          {
            class: `el-checkbox ${done2 ? "is-checked" : ""}`,
            style: "pointer-events: none;"
          },
          [
            "span",
            { class: `el-checkbox__input ${done2 ? "is-checked" : ""}` },
            ["span", { class: "el-checkbox__inner" }]
          ]
        ]
      ],
      ["div", { class: "todo-content" }, 0]
    ];
  },
  addNodeView() {
    return VueNodeViewRenderer(TaskItemView);
  }
});
const TaskList = TaskList$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleTaskList();
            },
            isActive: editor.isActive("taskList"),
            icon: "tasks",
            tooltip: t("editor.extensions.TodoList.tooltip")
          }
        };
      }
    };
  },
  addExtensions() {
    return [TaskItem];
  }
});
function findDiffStart$4(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$4(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$4(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$4(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$4 = function Fragment2(content4, size) {
  this.content = content4;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content4.length; i++) {
      this.size += content4[i].nodeSize;
    }
  }
};
var prototypeAccessors$e = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment$4.prototype.nodesBetween = function nodesBetween3(from8, to, f, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child11 = this.content[i], end7 = pos + child11.nodeSize;
    if (end7 > from8 && f(child11, nodeStart + pos, parent, i) !== false && child11.content.size) {
      var start8 = pos + 1;
      child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
    }
    pos = end7;
  }
};
Fragment$4.prototype.descendants = function descendants3(f) {
  this.nodesBetween(0, this.size, f);
};
Fragment$4.prototype.textBetween = function textBetween3(from8, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isText) {
      text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node8.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node8) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node8.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment$4.prototype.append = function append2(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content4[content4.length - 1] = last.withText(last.text + first2.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content4.push(other.content[i]);
  }
  return new Fragment$4(content4, this.size + other.size);
};
Fragment$4.prototype.cut = function cut3(from8, to) {
  if (to == null) {
    to = this.size;
  }
  if (from8 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from8) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8) {
        if (pos < from8 || end7 > to) {
          if (child11.isText) {
            child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
          } else {
            child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
        }
        result2.push(child11);
        size += child11.nodeSize;
      }
      pos = end7;
    }
  }
  return new Fragment$4(result2, size);
};
Fragment$4.prototype.cutByIndex = function cutByIndex2(from8, to) {
  if (from8 == to) {
    return Fragment$4.empty;
  }
  if (from8 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$4(this.content.slice(from8, to));
};
Fragment$4.prototype.replaceChild = function replaceChild2(index6, node8) {
  var current = this.content[index6];
  if (current == node8) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node8.nodeSize - current.nodeSize;
  copy12[index6] = node8;
  return new Fragment$4(copy12, size);
};
Fragment$4.prototype.addToStart = function addToStart2(node8) {
  return new Fragment$4([node8].concat(this.content), this.size + node8.nodeSize);
};
Fragment$4.prototype.addToEnd = function addToEnd2(node8) {
  return new Fragment$4(this.content.concat(node8), this.size + node8.nodeSize);
};
Fragment$4.prototype.eq = function eq13(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$e.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$e.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$e.childCount.get = function() {
  return this.content.length;
};
Fragment$4.prototype.child = function child3(index6) {
  var found2 = this.content[index6];
  if (!found2) {
    throw new RangeError("Index " + index6 + " out of range for " + this);
  }
  return found2;
};
Fragment$4.prototype.maybeChild = function maybeChild3(index6) {
  return this.content[index6];
};
Fragment$4.prototype.forEach = function forEach5(f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child11 = this.content[i];
    f(child11, p, i);
    p += child11.nodeSize;
  }
};
Fragment$4.prototype.findDiffStart = function findDiffStart$12(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$4(this, other, pos);
};
Fragment$4.prototype.findDiffEnd = function findDiffEnd$12(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$4(this, other, pos, otherPos);
};
Fragment$4.prototype.findIndex = function findIndex2(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex$4(0, pos);
  }
  if (pos == this.size) {
    return retIndex$4(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this.child(i), end7 = curPos + cur.nodeSize;
    if (end7 >= pos) {
      if (end7 == pos || round2 > 0) {
        return retIndex$4(i + 1, end7);
      }
      return retIndex$4(i, curPos);
    }
    curPos = end7;
  }
};
Fragment$4.prototype.toString = function toString8() {
  return "<" + this.toStringInner() + ">";
};
Fragment$4.prototype.toStringInner = function toStringInner2() {
  return this.content.join(", ");
};
Fragment$4.prototype.toJSON = function toJSON7() {
  return this.content.length ? this.content.map(function(n) {
    return n.toJSON();
  }) : null;
};
Fragment$4.fromJSON = function fromJSON8(schema, value) {
  if (!value) {
    return Fragment$4.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$4(value.map(schema.nodeFromJSON));
};
Fragment$4.fromArray = function fromArray2(array4) {
  if (!array4.length) {
    return Fragment$4.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array4.length; i++) {
    var node8 = array4[i];
    size += node8.nodeSize;
    if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
      if (!joined) {
        joined = array4.slice(0, i);
      }
      joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
    } else if (joined) {
      joined.push(node8);
    }
  }
  return new Fragment$4(joined || array4, size);
};
Fragment$4.from = function from3(nodes) {
  if (!nodes) {
    return Fragment$4.empty;
  }
  if (nodes instanceof Fragment$4) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment$4([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment$4.prototype, prototypeAccessors$e);
var found$4 = { index: 0, offset: 0 };
function retIndex$4(index6, offset6) {
  found$4.index = index6;
  found$4.offset = offset6;
  return found$4;
}
Fragment$4.empty = new Fragment$4([], 0);
function compareDeep$3(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array4 = Array.isArray(a);
  if (Array.isArray(b) != array4) {
    return false;
  }
  if (array4) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$3(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep$3(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$3 = function Mark2(type4, attrs) {
  this.type = type4;
  this.attrs = attrs;
};
Mark$3.prototype.addToSet = function addToSet2(set3) {
  var copy12, placed = false;
  for (var i = 0; i < set3.length; i++) {
    var other = set3[i];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set3.slice(0, i);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy12) {
          copy12 = set3.slice(0, i);
        }
        copy12.push(this);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set3.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$3.prototype.removeFromSet = function removeFromSet3(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return set3.slice(0, i).concat(set3.slice(i + 1));
    }
  }
  return set3;
};
Mark$3.prototype.isInSet = function isInSet3(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return true;
    }
  }
  return false;
};
Mark$3.prototype.eq = function eq14(other) {
  return this == other || this.type == other.type && compareDeep$3(this.attrs, other.attrs);
};
Mark$3.prototype.toJSON = function toJSON8() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark$3.fromJSON = function fromJSON9(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type4 = schema.marks[json.type];
  if (!type4) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type4.create(json.attrs);
};
Mark$3.sameSet = function sameSet2(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$3.setFrom = function setFrom2(marks6) {
  if (!marks6 || marks6.length == 0) {
    return Mark$3.none;
  }
  if (marks6 instanceof Mark$3) {
    return [marks6];
  }
  var copy12 = marks6.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$3.none = [];
function ReplaceError$3(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = ReplaceError$3.prototype;
  return err6;
}
ReplaceError$3.prototype = Object.create(Error.prototype);
ReplaceError$3.prototype.constructor = ReplaceError$3;
ReplaceError$3.prototype.name = "ReplaceError";
var Slice$4 = function Slice2(content4, openStart, openEnd) {
  this.content = content4;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$b = { size: { configurable: true } };
prototypeAccessors$1$b.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$4.prototype.insertAt = function insertAt2(pos, fragment) {
  var content4 = insertInto$4(this.content, pos + this.openStart, fragment, null);
  return content4 && new Slice$4(content4, this.openStart, this.openEnd);
};
Slice$4.prototype.removeBetween = function removeBetween2(from8, to) {
  return new Slice$4(removeRange$4(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$4.prototype.eq = function eq15(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$4.prototype.toString = function toString9() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$4.prototype.toJSON = function toJSON9() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$4.fromJSON = function fromJSON10(schema, json) {
  if (!json) {
    return Slice$4.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$4(Fragment$4.fromJSON(schema, json.content), openStart, openEnd);
};
Slice$4.maxOpen = function maxOpen2(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
    openStart++;
  }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
    openEnd++;
  }
  return new Slice$4(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$4.prototype, prototypeAccessors$1$b);
function removeRange$4(content4, from8, to) {
  var ref2 = content4.findIndex(from8);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  var ref$1 = content4.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content4.replaceChild(index6, child11.copy(removeRange$4(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto$4(content4, dist, insert, parent) {
  var ref2 = content4.findIndex(dist);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert)) {
      return null;
    }
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  var inner = insertInto$4(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
Slice$4.empty = new Slice$4(Fragment$4.empty, 0, 0);
function replace$3($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$3("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$3("Inconsistent open depths");
  }
  return replaceOuter$3($from, $to, slice11, 0);
}
function replaceOuter$3($from, $to, slice11, depth) {
  var index6 = $from.index(depth), node8 = $from.node(depth);
  if (index6 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$3($from, $to, slice11, depth + 1);
    return node8.copy(node8.content.replaceChild(index6, inner));
  } else if (!slice11.content.size) {
    return close$3(node8, replaceTwoWay$3($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content4 = parent.content;
    return close$3(parent, content4.cut(0, $from.parentOffset).append(slice11.content).append(content4.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace$3(slice11, $from);
    var start8 = ref2.start;
    var end7 = ref2.end;
    return close$3(node8, replaceThreeWay$3($from, start8, end7, $to, depth));
  }
}
function checkJoin$3(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError$3("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$3($before, $after, depth) {
  var node8 = $before.node(depth);
  checkJoin$3(node8, $after.node(depth));
  return node8;
}
function addNode$3(child11, target) {
  var last = target.length - 1;
  if (last >= 0 && child11.isText && child11.sameMarkup(target[last])) {
    target[last] = child11.withText(target[last].text + child11.text);
  } else {
    target.push(child11);
  }
}
function addRange$3($start, $end, depth, target) {
  var node8 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node8.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode$3($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i = startIndex2; i < endIndex2; i++) {
    addNode$3(node8.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$3($end.nodeBefore, target);
  }
}
function close$3(node8, content4) {
  if (!node8.type.validContent(content4)) {
    throw new ReplaceError$3("Invalid content for node " + node8.type.name);
  }
  return node8.copy(content4);
}
function replaceThreeWay$3($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$3($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$3($end, $to, depth + 1);
  var content4 = [];
  addRange$3(null, $from, depth, content4);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$3(openStart, openEnd);
    addNode$3(close$3(openStart, replaceThreeWay$3($from, $start, $end, $to, depth + 1)), content4);
  } else {
    if (openStart) {
      addNode$3(close$3(openStart, replaceTwoWay$3($from, $start, depth + 1)), content4);
    }
    addRange$3($start, $end, depth, content4);
    if (openEnd) {
      addNode$3(close$3(openEnd, replaceTwoWay$3($end, $to, depth + 1)), content4);
    }
  }
  addRange$3($to, null, depth, content4);
  return new Fragment$4(content4);
}
function replaceTwoWay$3($from, $to, depth) {
  var content4 = [];
  addRange$3(null, $from, depth, content4);
  if ($from.depth > depth) {
    var type4 = joinable$3($from, $to, depth + 1);
    addNode$3(close$3(type4, replaceTwoWay$3($from, $to, depth + 1)), content4);
  }
  addRange$3($to, null, depth, content4);
  return new Fragment$4(content4);
}
function prepareSliceForReplace$3(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node8 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node8 = $along.node(i).copy(Fragment$4.from(node8));
  }
  return {
    start: node8.resolveNoCache(slice11.openStart + extra),
    end: node8.resolveNoCache(node8.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$3 = function ResolvedPos2(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$3 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos$3.prototype.resolveDepth = function resolveDepth2(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$3.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$3.doc.get = function() {
  return this.node(0);
};
ResolvedPos$3.prototype.node = function node4(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$3.prototype.index = function index2(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$3.prototype.indexAfter = function indexAfter2(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$3.prototype.start = function start4(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$3.prototype.end = function end3(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$3.prototype.before = function before2(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$3.prototype.after = function after2(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$3.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$3.nodeAfter.get = function() {
  var parent = this.parent, index6 = this.index(this.depth);
  if (index6 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child11 = parent.child(index6);
  return dOff ? parent.child(index6).cut(dOff) : child11;
};
prototypeAccessors$2$3.nodeBefore.get = function() {
  var index6 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index6).cut(0, dOff);
  }
  return index6 == 0 ? null : this.parent.child(index6 - 1);
};
ResolvedPos$3.prototype.posAtIndex = function posAtIndex2(index6, depth) {
  depth = this.resolveDepth(depth);
  var node8 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index6; i++) {
    pos += node8.child(i).nodeSize;
  }
  return pos;
};
ResolvedPos$3.prototype.marks = function marks2() {
  var parent = this.parent, index6 = this.index();
  if (parent.content.size == 0) {
    return Mark$3.none;
  }
  if (this.textOffset) {
    return parent.child(index6).marks;
  }
  var main2 = parent.maybeChild(index6 - 1), other = parent.maybeChild(index6);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks6 = main2.marks;
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!other || !marks6[i].isInSet(other.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$3.prototype.marksAcross = function marksAcross2($end) {
  var after6 = this.parent.maybeChild(this.index());
  if (!after6 || !after6.isInline) {
    return null;
  }
  var marks6 = after6.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!next || !marks6[i].isInSet(next.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$3.prototype.sharedDepth = function sharedDepth2(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$3.prototype.blockRange = function blockRange2(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
      return new NodeRange$3(this, other, d);
    }
  }
};
ResolvedPos$3.prototype.sameParent = function sameParent2(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$3.prototype.max = function max3(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$3.prototype.min = function min3(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$3.prototype.toString = function toString10() {
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$3.resolve = function resolve6(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start8 = 0, parentOffset = pos;
  for (var node8 = doc2; ; ) {
    var ref2 = node8.content.findIndex(parentOffset);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    var rem = parentOffset - offset6;
    path.push(node8, index6, start8 + offset6);
    if (!rem) {
      break;
    }
    node8 = node8.child(index6);
    if (node8.isText) {
      break;
    }
    parentOffset = rem - 1;
    start8 += offset6 + 1;
  }
  return new ResolvedPos$3(pos, path, parentOffset);
};
ResolvedPos$3.resolveCached = function resolveCached2(doc2, pos) {
  for (var i = 0; i < resolveCache$3.length; i++) {
    var cached = resolveCache$3[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$3[resolveCachePos$3] = ResolvedPos$3.resolve(doc2, pos);
  resolveCachePos$3 = (resolveCachePos$3 + 1) % resolveCacheSize$3;
  return result2;
};
Object.defineProperties(ResolvedPos$3.prototype, prototypeAccessors$2$3);
var resolveCache$3 = [], resolveCachePos$3 = 0, resolveCacheSize$3 = 12;
var NodeRange$3 = function NodeRange2($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$3 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$3.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$3.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$3.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$3.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$3.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$3.prototype, prototypeAccessors$1$1$3);
var emptyAttrs$3 = /* @__PURE__ */ Object.create(null);
var Node$3 = function Node2(type4, attrs, content4, marks6) {
  this.type = type4;
  this.attrs = attrs;
  this.content = content4 || Fragment$4.empty;
  this.marks = marks6 || Mark$3.none;
};
var prototypeAccessors$3$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$3.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$3.childCount.get = function() {
  return this.content.childCount;
};
Node$3.prototype.child = function child4(index6) {
  return this.content.child(index6);
};
Node$3.prototype.maybeChild = function maybeChild4(index6) {
  return this.content.maybeChild(index6);
};
Node$3.prototype.forEach = function forEach6(f) {
  this.content.forEach(f);
};
Node$3.prototype.nodesBetween = function nodesBetween4(from8, to, f, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from8, to, f, startPos, this);
};
Node$3.prototype.descendants = function descendants4(f) {
  this.nodesBetween(0, this.content.size, f);
};
prototypeAccessors$3$3.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$3.prototype.textBetween = function textBetween4(from8, to, blockSeparator, leafText) {
  return this.content.textBetween(from8, to, blockSeparator, leafText);
};
prototypeAccessors$3$3.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$3.lastChild.get = function() {
  return this.content.lastChild;
};
Node$3.prototype.eq = function eq16(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$3.prototype.sameMarkup = function sameMarkup2(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$3.prototype.hasMarkup = function hasMarkup2(type4, attrs, marks6) {
  return this.type == type4 && compareDeep$3(this.attrs, attrs || type4.defaultAttrs || emptyAttrs$3) && Mark$3.sameSet(this.marks, marks6 || Mark$3.none);
};
Node$3.prototype.copy = function copy4(content4) {
  if (content4 === void 0)
    content4 = null;
  if (content4 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content4, this.marks);
};
Node$3.prototype.mark = function mark3(marks6) {
  return marks6 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks6);
};
Node$3.prototype.cut = function cut4(from8, to) {
  if (from8 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from8, to));
};
Node$3.prototype.slice = function slice3(from8, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from8 == to) {
    return Slice$4.empty;
  }
  var $from = this.resolve(from8), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start8 = $from.start(depth), node8 = $from.node(depth);
  var content4 = node8.content.cut($from.pos - start8, $to.pos - start8);
  return new Slice$4(content4, $from.depth - depth, $to.depth - depth);
};
Node$3.prototype.replace = function replace$12(from8, to, slice11) {
  return replace$3(this.resolve(from8), this.resolve(to), slice11);
};
Node$3.prototype.nodeAt = function nodeAt2(pos) {
  for (var node8 = this; ; ) {
    var ref2 = node8.content.findIndex(pos);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    node8 = node8.maybeChild(index6);
    if (!node8) {
      return null;
    }
    if (offset6 == pos || node8.isText) {
      return node8;
    }
    pos -= offset6 + 1;
  }
};
Node$3.prototype.childAfter = function childAfter2(pos) {
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  return { node: this.content.maybeChild(index6), index: index6, offset: offset6 };
};
Node$3.prototype.childBefore = function childBefore2(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  if (offset6 < pos) {
    return { node: this.content.child(index6), index: index6, offset: offset6 };
  }
  var node8 = this.content.child(index6 - 1);
  return { node: node8, index: index6 - 1, offset: offset6 - node8.nodeSize };
};
Node$3.prototype.resolve = function resolve7(pos) {
  return ResolvedPos$3.resolveCached(this, pos);
};
Node$3.prototype.resolveNoCache = function resolveNoCache2(pos) {
  return ResolvedPos$3.resolve(this, pos);
};
Node$3.prototype.rangeHasMark = function rangeHasMark2(from8, to, type4) {
  var found2 = false;
  if (to > from8) {
    this.nodesBetween(from8, to, function(node8) {
      if (type4.isInSet(node8.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$3.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$3.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$3.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$3.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$3.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$3.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$3.isAtom.get = function() {
  return this.type.isAtom;
};
Node$3.prototype.toString = function toString11() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$3(this.marks, name);
};
Node$3.prototype.contentMatchAt = function contentMatchAt2(index6) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index6);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node$3.prototype.canReplace = function canReplace2(from8, to, replacement, start8, end7) {
  if (replacement === void 0)
    replacement = Fragment$4.empty;
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = replacement.childCount;
  var one = this.contentMatchAt(from8).matchFragment(replacement, start8, end7);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start8; i < end7; i++) {
    if (!this.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$3.prototype.canReplaceWith = function canReplaceWith2(from8, to, type4, marks6) {
  if (marks6 && !this.type.allowsMarks(marks6)) {
    return false;
  }
  var start8 = this.contentMatchAt(from8).matchType(type4);
  var end7 = start8 && start8.matchFragment(this.content, to);
  return end7 ? end7.validEnd : false;
};
Node$3.prototype.canAppend = function canAppend2(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$3.prototype.check = function check2() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy12 = Mark$3.none;
  for (var i = 0; i < this.marks.length; i++) {
    copy12 = this.marks[i].addToSet(copy12);
  }
  if (!Mark$3.sameSet(copy12, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
      return m.type.name;
    }));
  }
  this.content.forEach(function(node8) {
    return node8.check();
  });
};
Node$3.prototype.toJSON = function toJSON10() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n) {
      return n.toJSON();
    });
  }
  return obj;
};
Node$3.fromJSON = function fromJSON11(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks6 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks6 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks6);
  }
  var content4 = Fragment$4.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content4, marks6);
};
Object.defineProperties(Node$3.prototype, prototypeAccessors$3$3);
function wrapMarks$3(marks6, str) {
  for (var i = marks6.length - 1; i >= 0; i--) {
    str = marks6[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$3 = function ContentMatch2(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$3 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch$3.parse = function parse3(string3, nodeTypes) {
  var stream = new TokenStream$3(string3, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$3.empty;
  }
  var expr = parseExpr$3(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa$3(nfa$3(expr));
  checkForDeadEnds$3(match, stream);
  return match;
};
ContentMatch$3.prototype.matchType = function matchType2(type4) {
  for (var i = 0; i < this.next.length; i += 2) {
    if (this.next[i] == type4) {
      return this.next[i + 1];
    }
  }
  return null;
};
ContentMatch$3.prototype.matchFragment = function matchFragment2(frag, start8, end7) {
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = frag.childCount;
  var cur = this;
  for (var i = start8; cur && i < end7; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$4$3.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4$3.defaultType.get = function() {
  for (var i = 0; i < this.next.length; i += 2) {
    var type4 = this.next[i];
    if (!(type4.isText || type4.hasRequiredAttrs())) {
      return type4;
    }
  }
};
ContentMatch$3.prototype.compatible = function compatible2(other) {
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$3.prototype.fillBefore = function fillBefore2(after6, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match, types2) {
    var finished = match.matchFragment(after6, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$4.from(types2.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i], next = match.next[i + 1];
      if (!(type4.isText || type4.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types2.concat(type4));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$3.prototype.findWrapping = function findWrapping4(target) {
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this.wrapCache[i] == target) {
      return this.wrapCache[i + 1];
    }
  }
  var computed2 = this.computeWrapping(target);
  this.wrapCache.push(target, computed2);
  return computed2;
};
ContentMatch$3.prototype.computeWrapping = function computeWrapping2(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i];
      if (!type4.isLeaf && !type4.hasRequiredAttrs() && !(type4.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({ match: type4.contentMatch, type: type4, via: current });
        seen[type4.name] = true;
      }
    }
  }
};
prototypeAccessors$4$3.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$3.prototype.edge = function edge2(n) {
  var i = n << 1;
  if (i >= this.next.length) {
    throw new RangeError("There's no " + n + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$3.prototype.toString = function toString12() {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2) {
      if (seen.indexOf(m.next[i]) == -1) {
        scan(m.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$3.prototype, prototypeAccessors$4$3);
ContentMatch$3.empty = new ContentMatch$3(true);
var TokenStream$3 = function TokenStream2(string3, nodeTypes) {
  this.string = string3;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string3.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$3 = { next: { configurable: true } };
prototypeAccessors$1$2$3.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$3.prototype.eat = function eat2(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$3.prototype.err = function err2(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$3.prototype, prototypeAccessors$1$2$3);
function parseExpr$3(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$3(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$3(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$3(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$3(stream) {
  var expr = parseExprAtom$3(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$3(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$3(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$3(stream, expr) {
  var min7 = parseNum$3(stream), max7 = min7;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max7 = parseNum$3(stream);
    } else {
      max7 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min7, max: max7, expr };
}
function resolveName$3(stream, name) {
  var types2 = stream.nodeTypes, type4 = types2[name];
  if (type4) {
    return [type4];
  }
  var result2 = [];
  for (var typeName in types2) {
    var type$12 = types2[typeName];
    if (type$12.groups.indexOf(name) > -1) {
      result2.push(type$12);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$3(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$3(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$3(stream, stream.next).map(function(type4) {
      if (stream.inline == null) {
        stream.inline = type4.isInline;
      } else if (stream.inline != type4.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type4 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$3(expr) {
  var nfa2 = [[]];
  connect(compile11(expr, 0), node8());
  return nfa2;
  function node8() {
    return nfa2.push([]) - 1;
  }
  function edge6(from8, to, term) {
    var edge7 = { term, to };
    nfa2[from8].push(edge7);
    return edge7;
  }
  function connect(edges, to) {
    edges.forEach(function(edge7) {
      return edge7.to = to;
    });
  }
  function compile11(expr2, from8) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile11(expr3, from8));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile11(expr2.exprs[i], from8);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from8 = node8());
      }
    } else if (expr2.type == "star") {
      var loop = node8();
      edge6(from8, loop);
      connect(compile11(expr2.expr, loop), loop);
      return [edge6(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node8();
      connect(compile11(expr2.expr, from8), loop$1);
      connect(compile11(expr2.expr, loop$1), loop$1);
      return [edge6(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge6(from8)].concat(compile11(expr2.expr, from8));
    } else if (expr2.type == "range") {
      var cur = from8;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node8();
        connect(compile11(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile11(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node8();
          edge6(cur, next$2);
          connect(compile11(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge6(cur)];
    } else if (expr2.type == "name") {
      return [edge6(from8, null, expr2.value)];
    }
  }
}
function cmp$3(a, b) {
  return b - a;
}
function nullFrom$3(nfa2, node8) {
  var result2 = [];
  scan(node8);
  return result2.sort(cmp$3);
  function scan(node9) {
    var edges = nfa2[node9];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node9);
    for (var i = 0; i < edges.length; i++) {
      var ref2 = edges[i];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$3(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$3(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node8) {
      nfa2[node8].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom$3(nfa2, to).forEach(function(node9) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node9) == -1) {
            set3.push(node9);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$3(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$3);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$3(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node8 = state.next[j], next = state.next[j + 1];
      nodes.push(node8.name);
      if (dead && !(node8.isText || node8.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs$3(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs$3(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$3(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$3(attrs[name]);
    }
  }
  return result2;
}
var NodeType$4 = function NodeType3(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$3(spec.attrs);
  this.defaultAttrs = defaultAttrs$3(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$3 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$3.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$3.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$3.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$3.empty;
};
prototypeAccessors$5$3.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$3.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$4.prototype.hasRequiredAttrs = function hasRequiredAttrs2() {
  for (var n in this.attrs) {
    if (this.attrs[n].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$4.prototype.compatibleContent = function compatibleContent2(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$4.prototype.computeAttrs = function computeAttrs$12(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$3(this.attrs, attrs);
  }
};
NodeType$4.prototype.create = function create5(attrs, content4, marks6) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$3(this, this.computeAttrs(attrs), Fragment$4.from(content4), Mark$3.setFrom(marks6));
};
NodeType$4.prototype.createChecked = function createChecked2(attrs, content4, marks6) {
  content4 = Fragment$4.from(content4);
  if (!this.validContent(content4)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$3(this, this.computeAttrs(attrs), content4, Mark$3.setFrom(marks6));
};
NodeType$4.prototype.createAndFill = function createAndFill2(attrs, content4, marks6) {
  attrs = this.computeAttrs(attrs);
  content4 = Fragment$4.from(content4);
  if (content4.size) {
    var before6 = this.contentMatch.fillBefore(content4);
    if (!before6) {
      return null;
    }
    content4 = before6.append(content4);
  }
  var after6 = this.contentMatch.matchFragment(content4).fillBefore(Fragment$4.empty, true);
  if (!after6) {
    return null;
  }
  return new Node$3(this, attrs, content4.append(after6), Mark$3.setFrom(marks6));
};
NodeType$4.prototype.validContent = function validContent2(content4) {
  var result2 = this.contentMatch.matchFragment(content4);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content4.childCount; i++) {
    if (!this.allowsMarks(content4.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$4.prototype.allowsMarkType = function allowsMarkType2(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$4.prototype.allowsMarks = function allowsMarks2(marks6) {
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$4.prototype.allowedMarks = function allowedMarks2(marks6) {
  if (this.markSet == null) {
    return marks6;
  }
  var copy12;
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      if (!copy12) {
        copy12 = marks6.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks6[i]);
    }
  }
  return !copy12 ? marks6 : copy12.length ? copy12 : Mark$3.empty;
};
NodeType$4.compile = function compile3(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$4(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$4.prototype, prototypeAccessors$5$3);
var Attribute$3 = function Attribute2(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$3 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$3.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$3.prototype, prototypeAccessors$1$3$3);
var MarkType$3 = function MarkType2(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs$3(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs$3(this.attrs);
  this.instance = defaults2 && new Mark$3(this, defaults2);
};
MarkType$3.prototype.create = function create6(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$3(this, computeAttrs$3(this.attrs, attrs));
};
MarkType$3.compile = function compile4(marks6, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks6.forEach(function(name, spec) {
    return result2[name] = new MarkType$3(name, rank++, schema, spec);
  });
  return result2;
};
MarkType$3.prototype.removeFromSet = function removeFromSet4(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      set3 = set3.slice(0, i).concat(set3.slice(i + 1));
      i--;
    }
  }
  return set3;
};
MarkType$3.prototype.isInSet = function isInSet4(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      return set3[i];
    }
  }
};
MarkType$3.prototype.excludes = function excludes2(other) {
  return this.excluded.indexOf(other) > -1;
};
var blockTags$3 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$3 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$3 = { ol: true, ul: true };
var OPT_PRESERVE_WS$3 = 1, OPT_PRESERVE_WS_FULL$3 = 2, OPT_OPEN_LEFT$3 = 4;
function wsOptionsFor$3(type4, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS$3 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$3 : 0);
  }
  return type4 && type4.whitespace == "pre" ? OPT_PRESERVE_WS$3 | OPT_PRESERVE_WS_FULL$3 : base2 & ~OPT_OPEN_LEFT$3;
}
var NodeContext$3 = function NodeContext2(type4, attrs, marks6, pendingMarks, solid, match, options) {
  this.type = type4;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT$3 ? null : type4.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks6;
  this.activeMarks = Mark$3.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext$3.prototype.findWrapping = function findWrapping5(node8) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$4.from(node8));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start8 = this.type.contentMatch, wrap2;
      if (wrap2 = start8.findWrapping(node8.type)) {
        this.match = start8;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node8.type);
};
NodeContext$3.prototype.finish = function finish3(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$3)) {
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
  }
  var content4 = Fragment$4.from(this.content);
  if (!openEnd && this.match) {
    content4 = content4.append(this.match.fillBefore(Fragment$4.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content4, this.marks) : content4;
};
NodeContext$3.prototype.popFromStashMark = function popFromStashMark2(mark7) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--) {
    if (mark7.eq(this.stashMarks[i])) {
      return this.stashMarks.splice(i, 1)[0];
    }
  }
};
NodeContext$3.prototype.applyPending = function applyPending2(nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark7 = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark7.type) : markMayApply$3(mark7.type, nextType)) && !mark7.isInSet(this.activeMarks)) {
      this.activeMarks = mark7.addToSet(this.activeMarks);
      this.pendingMarks = mark7.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext$3.prototype.inlineContext = function inlineContext2(node8) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node8.parentNode && !blockTags$3.hasOwnProperty(node8.parentNode.nodeName.toLowerCase());
};
var ParseContext$3 = function ParseContext2(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$3(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT$3 : 0);
  if (topNode) {
    topContext = new NodeContext$3(topNode.type, topNode.attrs, Mark$3.none, Mark$3.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext$3(null, null, Mark$3.none, Mark$3.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$3(parser.schema.topNodeType, null, Mark$3.none, Mark$3.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$3 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6$3.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$3.prototype.addDOM = function addDOM2(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks6 = style2 ? this.readStyles(parseStyles$3(style2)) : null, top2 = this.top;
    if (marks6 != null) {
      for (var i = 0; i < marks6.length; i++) {
        this.addPendingMark(marks6[i]);
      }
    }
    this.addElement(dom);
    if (marks6 != null) {
      for (var i$1 = 0; i$1 < marks6.length; i$1++) {
        this.removePendingMark(marks6[i$1], top2);
      }
    }
  }
};
ParseContext$3.prototype.addTextNode = function addTextNode2(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL$3 || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS$3)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL$3)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$3.prototype.addElement = function addElement2(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags$3.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList$3(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags$3.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync6, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$3.hasOwnProperty(name)) {
      sync6 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync6) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext$3.prototype.leafFallback = function leafFallback2(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext$3.prototype.ignoreFallback = function ignoreFallback2(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext$3.prototype.readStyles = function readStyles2(styles) {
  var marks6 = Mark$3.none;
  style:
    for (var i = 0; i < styles.length; i += 2) {
      for (var after6 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after6);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks6 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks6);
        if (rule.consuming === false) {
          after6 = rule;
        } else {
          break;
        }
      }
    }
  return marks6;
};
ParseContext$3.prototype.addElementByRule = function addElementByRule2(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync6, nodeType2, markType, mark7;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync6 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark7 = markType.create(rule.attrs);
    this.addPendingMark(mark7);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node8) {
      return this$1$1.insertNode(node8);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync6);
  }
  if (sync6) {
    this.sync(startIn);
    this.open--;
  }
  if (mark7) {
    this.removePendingMark(mark7, startIn);
  }
};
ParseContext$3.prototype.addAll = function addAll2(parent, sync6, startIndex2, endIndex2) {
  var index6 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end7 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end7; dom = dom.nextSibling, ++index6) {
    this.findAtPoint(parent, index6);
    this.addDOM(dom);
    if (sync6 && blockTags$3.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync6);
    }
  }
  this.findAtPoint(parent, index6);
};
ParseContext$3.prototype.findPlace = function findPlace2(node8) {
  var route, sync6;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node8);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync6 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync6);
  for (var i = 0; i < route.length; i++) {
    this.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$3.prototype.insertNode = function insertNode2(node8) {
  if (node8.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node8)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node8.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node8.type);
    }
    var marks6 = top2.activeMarks;
    for (var i = 0; i < node8.marks.length; i++) {
      if (!top2.type || top2.type.allowsMarkType(node8.marks[i].type)) {
        marks6 = node8.marks[i].addToSet(marks6);
      }
    }
    top2.content.push(node8.mark(marks6));
    return true;
  }
  return false;
};
ParseContext$3.prototype.enter = function enter3(type4, attrs, preserveWS) {
  var ok5 = this.findPlace(type4.create(attrs));
  if (ok5) {
    this.enterInner(type4, attrs, true, preserveWS);
  }
  return ok5;
};
ParseContext$3.prototype.enterInner = function enterInner2(type4, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type4);
  top2.match = top2.match && top2.match.matchType(type4, attrs);
  var options = wsOptionsFor$3(type4, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT$3 && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT$3;
  }
  this.nodes.push(new NodeContext$3(type4, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext$3.prototype.closeExtra = function closeExtra2(openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$3.prototype.finish = function finish4() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$3.prototype.sync = function sync2(to) {
  for (var i = this.open; i >= 0; i--) {
    if (this.nodes[i] == to) {
      this.open = i;
      return;
    }
  }
};
prototypeAccessors$6$3.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content4 = this.nodes[i].content;
    for (var j = content4.length - 1; j >= 0; j--) {
      pos += content4[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$3.prototype.findAtPoint = function findAtPoint2(parent, offset6) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset6) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$3.prototype.findInside = function findInside2(parent) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$3.prototype.findAround = function findAround2(parent, content4, before6) {
  if (parent != content4 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        var pos = content4.compareDocumentPosition(this.find[i].node);
        if (pos & (before6 ? 2 : 4)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext$3.prototype.findInText = function findInText2(textNode) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode) {
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }
};
ParseContext$3.prototype.matchesContext = function matchesContext2(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext$3.prototype.textblockFromContext = function textblockFromContext2() {
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type4 = this.parser.schema.nodes[name];
    if (type4.isTextblock && type4.defaultAttrs) {
      return type4;
    }
  }
};
ParseContext$3.prototype.addPendingMark = function addPendingMark2(mark7) {
  var found2 = findSameMarkInSet$3(mark7, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark7.addToSet(this.top.pendingMarks);
};
ParseContext$3.prototype.removePendingMark = function removePendingMark2(mark7, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark7);
    if (found2 > -1) {
      level.pendingMarks = mark7.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark7.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark7);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext$3.prototype, prototypeAccessors$6$3);
function normalizeList$3(dom) {
  for (var child11 = dom.firstChild, prevItem = null; child11; child11 = child11.nextSibling) {
    var name = child11.nodeType == 1 ? child11.nodeName.toLowerCase() : null;
    if (name && listTags$3.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child11);
      child11 = prevItem;
    } else if (name == "li") {
      prevItem = child11;
    } else if (name) {
      prevItem = null;
    }
  }
}
function parseStyles$3(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style2)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function markMayApply$3(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref2 = match.edge(i);
        var type4 = ref2.type;
        var next = ref2.next;
        if (type4 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet$3(mark7, set3) {
  for (var i = 0; i < set3.length; i++) {
    if (mark7.eq(set3[i])) {
      return set3[i];
    }
  }
}
var lower16$3 = 65535;
var factor16$3 = Math.pow(2, 16);
function makeRecover$3(index6, offset6) {
  return index6 + offset6 * factor16$3;
}
function recoverIndex$3(value) {
  return value & lower16$3;
}
function recoverOffset$3(value) {
  return (value - (value & lower16$3)) / factor16$3;
}
var MapResult$3 = function MapResult2(pos, deleted, recover5) {
  if (deleted === void 0)
    deleted = false;
  if (recover5 === void 0)
    recover5 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover5;
};
var StepMap$3 = function StepMap2(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap$3.prototype.recover = function recover2(value) {
  var diff = 0, index6 = recoverIndex$3(value);
  if (!this.inverted) {
    for (var i = 0; i < index6; i++) {
      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    }
  }
  return this.ranges[index6 * 3] + diff + recoverOffset$3(value);
};
StepMap$3.prototype.mapResult = function mapResult3(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap$3.prototype.map = function map13(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap$3.prototype._map = function _map3(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end7 = start8 + oldSize;
    if (pos <= end7) {
      var side = !oldSize ? assoc : pos == start8 ? -1 : pos == end7 ? 1 : assoc;
      var result2 = start8 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover5 = pos == (assoc < 0 ? start8 : end7) ? null : makeRecover$3(i / 3, pos - start8);
      return new MapResult$3(result2, assoc < 0 ? pos != start8 : pos != end7, recover5);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult$3(pos + diff);
};
StepMap$3.prototype.touches = function touches2(pos, recover5) {
  var diff = 0, index6 = recoverIndex$3(recover5);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], end7 = start8 + oldSize;
    if (pos <= end7 && i == index6 * 3) {
      return true;
    }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false;
};
StepMap$3.prototype.forEach = function forEach7(f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i], oldStart = start8 - (this.inverted ? diff : 0), newStart = start8 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap$3.prototype.invert = function invert4() {
  return new StepMap$3(this.ranges, !this.inverted);
};
StepMap$3.prototype.toString = function toString13() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap$3.offset = function offset3(n) {
  return n == 0 ? StepMap$3.empty : new StepMap$3(n < 0 ? [0, -n, 0] : [0, 0, n]);
};
StepMap$3.empty = new StepMap$3([]);
var Mapping$3 = function Mapping2(maps, mirror, from8, to) {
  this.maps = maps || [];
  this.from = from8 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping$3.prototype.slice = function slice4(from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping$3(this.maps, this.mirror, from8, to);
};
Mapping$3.prototype.copy = function copy5() {
  return new Mapping$3(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping$3.prototype.appendMap = function appendMap2(map30, mirrors) {
  this.to = this.maps.push(map30);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping$3.prototype.appendMapping = function appendMapping2(mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};
Mapping$3.prototype.getMirror = function getMirror2(n) {
  if (this.mirror) {
    for (var i = 0; i < this.mirror.length; i++) {
      if (this.mirror[i] == n) {
        return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping$3.prototype.setMirror = function setMirror2(n, m) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n, m);
};
Mapping$3.prototype.appendMappingInverted = function appendMappingInverted2(mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};
Mapping$3.prototype.invert = function invert5() {
  var inverse = new Mapping$3();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping$3.prototype.map = function map14(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i = this.from; i < this.to; i++) {
    pos = this.maps[i].map(pos, assoc);
  }
  return pos;
};
Mapping$3.prototype.mapResult = function mapResult4(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping$3.prototype._map = function _map4(pos, assoc, simple) {
  var deleted = false;
  for (var i = this.from; i < this.to; i++) {
    var map30 = this.maps[i], result2 = map30.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult$3(pos, deleted);
};
function TransformError$3(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = TransformError$3.prototype;
  return err6;
}
TransformError$3.prototype = Object.create(Error.prototype);
TransformError$3.prototype.constructor = TransformError$3;
TransformError$3.prototype.name = "TransformError";
var Transform$3 = function Transform2(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping$3();
};
var prototypeAccessors$d = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$d.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform$3.prototype.step = function step2(object4) {
  var result2 = this.maybeStep(object4);
  if (result2.failed) {
    throw new TransformError$3(result2.failed);
  }
  return this;
};
Transform$3.prototype.maybeStep = function maybeStep2(step5) {
  var result2 = step5.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step5, result2.doc);
  }
  return result2;
};
prototypeAccessors$d.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform$3.prototype.addStep = function addStep2(step5, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step5);
  this.mapping.appendMap(step5.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform$3.prototype, prototypeAccessors$d);
function mustOverride$2() {
  throw new Error("Override me");
}
var stepsByID$3 = /* @__PURE__ */ Object.create(null);
var Step$3 = function Step2() {
};
Step$3.prototype.apply = function apply7(_doc) {
  return mustOverride$2();
};
Step$3.prototype.getMap = function getMap2() {
  return StepMap$3.empty;
};
Step$3.prototype.invert = function invert6(_doc) {
  return mustOverride$2();
};
Step$3.prototype.map = function map15(_mapping) {
  return mustOverride$2();
};
Step$3.prototype.merge = function merge2(_other) {
  return null;
};
Step$3.prototype.toJSON = function toJSON11() {
  return mustOverride$2();
};
Step$3.fromJSON = function fromJSON12(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type4 = stepsByID$3[json.stepType];
  if (!type4) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type4.fromJSON(schema, json);
};
Step$3.jsonID = function jsonID3(id, stepClass) {
  if (id in stepsByID$3) {
    throw new RangeError("Duplicate use of step JSON ID " + id);
  }
  stepsByID$3[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass;
};
var StepResult$3 = function StepResult2(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult$3.ok = function ok2(doc2) {
  return new StepResult$3(doc2, null);
};
StepResult$3.fail = function fail2(message) {
  return new StepResult$3(null, message);
};
StepResult$3.fromReplace = function fromReplace2(doc2, from8, to, slice11) {
  try {
    return StepResult$3.ok(doc2.replace(from8, to, slice11));
  } catch (e) {
    if (e instanceof ReplaceError$3) {
      return StepResult$3.fail(e.message);
    }
    throw e;
  }
};
var ReplaceStep$3 = /* @__PURE__ */ function(Step6) {
  function ReplaceStep2(from8, to, slice11, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.slice = slice11;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceStep2.__proto__ = Step6;
  ReplaceStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && contentBetween$3(doc2, this.from, this.to)) {
      return StepResult$3.fail("Structure replace would overwrite content");
    }
    return StepResult$3.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap5() {
    return new StepMap$3([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert13(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from8.pos, Math.max(from8.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge6(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice11 = this.slice.size + other.slice.size == 0 ? Slice$4.empty : new Slice$4(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice$4.empty : new Slice$4(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON28() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice$4.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step$3);
Step$3.jsonID("replace", ReplaceStep$3);
var ReplaceAroundStep$3 = /* @__PURE__ */ function(Step6) {
  function ReplaceAroundStep2(from8, to, gapFrom, gapTo, slice11, insert, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceAroundStep2.__proto__ = Step6;
  ReplaceAroundStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && (contentBetween$3(doc2, this.from, this.gapFrom) || contentBetween$3(doc2, this.gapTo, this.to))) {
      return StepResult$3.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult$3.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult$3.fail("Content does not fit in gap");
    }
    return StepResult$3.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap5() {
    return new StepMap$3([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert13(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from8.deleted && to.deleted || gapFrom < from8.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from8.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON28() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice$4.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step$3);
Step$3.jsonID("replaceAround", ReplaceAroundStep$3);
function contentBetween$3(doc2, from8, to) {
  var $from = doc2.resolve(from8), dist = to - from8, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
Transform$3.prototype.lift = function(range3, target) {
  var $from = range3.$from;
  var $to = range3.$to;
  var depth = range3.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start8 = gapStart, end7 = gapEnd;
  var before6 = Fragment$4.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before6 = Fragment$4.from($from.node(d).copy(before6));
      openStart++;
    } else {
      start8--;
    }
  }
  var after6 = Fragment$4.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after6 = Fragment$4.from($to.node(d$1).copy(after6));
      openEnd++;
    } else {
      end7++;
    }
  }
  return this.step(new ReplaceAroundStep$3(start8, end7, gapStart, gapEnd, new Slice$4(before6.append(after6), openStart, openEnd), before6.size - openStart, true));
};
Transform$3.prototype.wrap = function(range3, wrappers) {
  var content4 = Fragment$4.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content4 = Fragment$4.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  var start8 = range3.start, end7 = range3.end;
  return this.step(new ReplaceAroundStep$3(start8, end7, start8, end7, new Slice$4(content4, 0, 0), wrappers.length, true));
};
Transform$3.prototype.setBlockType = function(from8, to, type4, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from8;
  if (!type4.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isTextblock && !node8.hasMarkup(type4, attrs) && canChangeType$3(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type4)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type4);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node8.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep$3(startM, endM, startM + 1, endM - 1, new Slice$4(Fragment$4.from(type4.create(attrs, null, node8.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType$3(doc2, pos, type4) {
  var $pos = doc2.resolve(pos), index6 = $pos.index();
  return $pos.parent.canReplaceWith(index6, index6 + 1, type4);
}
Transform$3.prototype.setNodeMarkup = function(pos, type4, attrs, marks6) {
  var node8 = this.doc.nodeAt(pos);
  if (!node8) {
    throw new RangeError("No node at given position");
  }
  if (!type4) {
    type4 = node8.type;
  }
  var newNode = type4.create(attrs, null, marks6 || node8.marks);
  if (node8.isLeaf) {
    return this.replaceWith(pos, pos + node8.nodeSize, newNode);
  }
  if (!type4.validContent(node8.content)) {
    throw new RangeError("Invalid content for node type " + type4.name);
  }
  return this.step(new ReplaceAroundStep$3(pos, pos + node8.nodeSize, pos + 1, pos + node8.nodeSize - 1, new Slice$4(Fragment$4.from(newNode), 0, 0), 1, true));
};
Transform$3.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before6 = Fragment$4.empty, after6 = Fragment$4.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before6 = Fragment$4.from($pos.node(d).copy(before6));
    var typeAfter = typesAfter && typesAfter[i];
    after6 = Fragment$4.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after6) : $pos.node(d).copy(after6));
  }
  return this.step(new ReplaceStep$3(pos, pos, new Slice$4(before6.append(after6), depth, depth), true));
};
Transform$3.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step5 = new ReplaceStep$3(pos - depth, pos + depth, Slice$4.empty, true);
  return this.step(step5);
};
function insertPoint$3(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index6 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2)) {
        return $pos.before(d + 1);
      }
      if (index6 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function mapFragment$3(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child11 = fragment.child(i);
    if (child11.content.size) {
      child11 = child11.copy(mapFragment$3(child11.content, f, child11));
    }
    if (child11.isInline) {
      child11 = f(child11, parent, i);
    }
    mapped.push(child11);
  }
  return Fragment$4.fromArray(mapped);
}
var AddMarkStep$3 = /* @__PURE__ */ function(Step6) {
  function AddMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    AddMarkStep2.__proto__ = Step6;
  AddMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice11 = new Slice$4(mapFragment$3(oldSlice.content, function(node8, parent2) {
      if (!node8.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node8;
      }
      return node8.mark(this$1$1.mark.addToSet(node8.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$3.fromReplace(doc2, this.from, this.to, slice11);
  };
  AddMarkStep2.prototype.invert = function invert13() {
    return new RemoveMarkStep$3(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from8.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step$3);
Step$3.jsonID("addMark", AddMarkStep$3);
var RemoveMarkStep$3 = /* @__PURE__ */ function(Step6) {
  function RemoveMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    RemoveMarkStep2.__proto__ = Step6;
  RemoveMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice11 = new Slice$4(mapFragment$3(oldSlice.content, function(node8) {
      return node8.mark(this$1$1.mark.removeFromSet(node8.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$3.fromReplace(doc2, this.from, this.to, slice11);
  };
  RemoveMarkStep2.prototype.invert = function invert13() {
    return new AddMarkStep$3(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from8.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step$3);
Step$3.jsonID("removeMark", RemoveMarkStep$3);
Transform$3.prototype.addMark = function(from8, to, mark7) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from8, to, function(node8, pos, parent) {
    if (!node8.isInline) {
      return;
    }
    var marks6 = node8.marks;
    if (!mark7.isInSet(marks6) && parent.type.allowsMarkType(mark7.type)) {
      var start8 = Math.max(pos, from8), end7 = Math.min(pos + node8.nodeSize, to);
      var newSet = mark7.addToSet(marks6);
      for (var i = 0; i < marks6.length; i++) {
        if (!marks6[i].isInSet(newSet)) {
          if (removing && removing.to == start8 && removing.mark.eq(marks6[i])) {
            removing.to = end7;
          } else {
            removed.push(removing = new RemoveMarkStep$3(start8, end7, marks6[i]));
          }
        }
      }
      if (adding && adding.to == start8) {
        adding.to = end7;
      } else {
        added.push(adding = new AddMarkStep$3(start8, end7, mark7));
      }
    }
  });
  removed.forEach(function(s) {
    return this$1$1.step(s);
  });
  added.forEach(function(s) {
    return this$1$1.step(s);
  });
  return this;
};
Transform$3.prototype.removeMark = function(from8, to, mark7) {
  var this$1$1 = this;
  if (mark7 === void 0)
    mark7 = null;
  var matched = [], step5 = 0;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (!node8.isInline) {
      return;
    }
    step5++;
    var toRemove = null;
    if (mark7 instanceof MarkType$3) {
      var set3 = node8.marks, found2;
      while (found2 = mark7.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark7) {
      if (mark7.isInSet(node8.marks)) {
        toRemove = [mark7];
      }
    } else {
      toRemove = node8.marks;
    }
    if (toRemove && toRemove.length) {
      var end7 = Math.min(pos + node8.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style2 = toRemove[i], found$12 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step5 - 1 && style2.eq(matched[j].style)) {
            found$12 = m;
          }
        }
        if (found$12) {
          found$12.to = end7;
          found$12.step = step5;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from8), to: end7, step: step5 });
        }
      }
    }
  });
  matched.forEach(function(m) {
    return this$1$1.step(new RemoveMarkStep$3(m.from, m.to, m.style));
  });
  return this;
};
Transform$3.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node8 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node8.childCount; i++) {
    var child11 = node8.child(i), end7 = cur + child11.nodeSize;
    var allowed = match.matchType(child11.type, child11.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep$3(cur, end7, Slice$4.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child11.marks.length; j++) {
        if (!parentType.allowsMarkType(child11.marks[j].type)) {
          this.step(new RemoveMarkStep$3(cur, end7, child11.marks[j]));
        }
      }
    }
    cur = end7;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment$4.empty, true);
    this.replace(cur, cur, new Slice$4(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep$3(doc2, from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$4.empty;
  if (from8 == to && !slice11.size) {
    return null;
  }
  var $from = doc2.resolve(from8), $to = doc2.resolve(to);
  if (fitsTrivially$3($from, $to, slice11)) {
    return new ReplaceStep$3(from8, to, slice11);
  }
  return new Fitter$3($from, $to, slice11).fit();
}
Transform$3.prototype.replace = function(from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$4.empty;
  var step5 = replaceStep$3(this.doc, from8, to, slice11);
  if (step5) {
    this.step(step5);
  }
  return this;
};
Transform$3.prototype.replaceWith = function(from8, to, content4) {
  return this.replace(from8, to, new Slice$4(Fragment$4.from(content4), 0, 0));
};
Transform$3.prototype.delete = function(from8, to) {
  return this.replace(from8, to, Slice$4.empty);
};
Transform$3.prototype.insert = function(pos, content4) {
  return this.replaceWith(pos, pos, content4);
};
function fitsTrivially$3($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
var Fitter$3 = function Fitter2($from, $to, slice11) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice11;
  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node8 = $from.node(i);
    this.frontier.push({
      type: node8.type,
      match: node8.contentMatchAt($from.indexAfter(i))
    });
  }
  this.placed = Fragment$4.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment$4.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$a = { depth: { configurable: true } };
prototypeAccessors$1$a.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter$3.prototype.fit = function fit2() {
  while (this.unplaced.size) {
    var fit5 = this.findFittable();
    if (fit5) {
      this.placeNodes(fit5);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content4 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content4.childCount == 1) {
    content4 = content4.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice11 = new Slice$4(content4, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep$3($from.pos, moveInline, this.$to.pos, this.$to.end(), slice11, placedSize);
  }
  if (slice11.size || $from.pos != this.$to.pos) {
    return new ReplaceStep$3($from.pos, $to.pos, slice11);
  }
};
Fitter$3.prototype.findFittable = function findFittable2() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt$3(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first2 = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref2 = this.frontier[frontierDepth];
        var type4 = ref2.type;
        var match = ref2.match;
        var wrap2 = void 0, inject2 = void 0;
        if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment$4.from(first2), false)) : type4.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject: inject2 };
        } else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type))) {
          return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter$3.prototype.openMore = function openMore2() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$3(content4, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice$4(content4, openStart + 1, Math.max(openEnd, inner.size + openStart >= content4.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter$3.prototype.dropNode = function dropNode2() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$3(content4, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content4.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice$4(dropFromFragment$3(content4, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice$4(dropFromFragment$3(content4, openStart, 1), openStart, openEnd);
  }
};
Fitter$3.prototype.placeNodes = function placeNodes2(ref2) {
  var sliceDepth = ref2.sliceDepth;
  var frontierDepth = ref2.frontierDepth;
  var parent = ref2.parent;
  var inject2 = ref2.inject;
  var wrap2 = ref2.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap2) {
    for (var i = 0; i < wrap2.length; i++) {
      this.openFrontierNode(wrap2[i]);
    }
  }
  var slice11 = this.unplaced, fragment = parent ? parent.content : slice11.content;
  var openStart = slice11.openStart - sliceDepth;
  var taken = 0, add2 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type4 = ref$1.type;
  if (inject2) {
    for (var i$1 = 0; i$1 < inject2.childCount; i$1++) {
      add2.push(inject2.child(i$1));
    }
    match = match.matchFragment(inject2);
  }
  var openEndCount = fragment.size + sliceDepth - (slice11.content.size - slice11.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add2.push(closeNodeStart$3(next.mark(type4.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment$3(this.placed, frontierDepth, Fragment$4.from(add2));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node8 = cur.lastChild;
    this.frontier.push({ type: node8.type, match: node8.contentMatchAt(node8.childCount) });
    cur = node8.content;
  }
  this.unplaced = !toEnd ? new Slice$4(dropFromFragment$3(slice11.content, sliceDepth, taken), slice11.openStart, slice11.openEnd) : sliceDepth == 0 ? Slice$4.empty : new Slice$4(dropFromFragment$3(slice11.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice11.openEnd : sliceDepth - 1);
};
Fitter$3.prototype.mustMoveInline = function mustMoveInline2() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits$3(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref2 = this.$to;
  var depth = ref2.depth;
  var after6 = this.$to.after(depth);
  while (depth > 1 && after6 == this.$to.end(--depth)) {
    ++after6;
  }
  return after6;
};
Fitter$3.prototype.findCloseLevel = function findCloseLevel2($to) {
  scan:
    for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      var ref2 = this.frontier[i];
      var match = ref2.match;
      var type4 = ref2.type;
      var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      var fit5 = contentAfterFits$3($to, i, type4, match, dropInner);
      if (!fit5) {
        continue;
      }
      for (var d = i - 1; d >= 0; d--) {
        var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$12 = ref$1.type;
        var matches2 = contentAfterFits$3($to, d, type$12, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i, fit: fit5, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
};
Fitter$3.prototype.close = function close2($to) {
  var close6 = this.findCloseLevel($to);
  if (!close6) {
    return null;
  }
  while (this.depth > close6.depth) {
    this.closeFrontierNode();
  }
  if (close6.fit.childCount) {
    this.placed = addToFragment$3(this.placed, close6.depth, close6.fit);
  }
  $to = close6.move;
  for (var d = close6.depth + 1; d <= $to.depth; d++) {
    var node8 = $to.node(d), add2 = node8.type.contentMatch.fillBefore(node8.content, true, $to.index(d));
    this.openFrontierNode(node8.type, node8.attrs, add2);
  }
  return $to;
};
Fitter$3.prototype.openFrontierNode = function openFrontierNode2(type4, attrs, content4) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type4);
  this.placed = addToFragment$3(this.placed, this.depth, Fragment$4.from(type4.create(attrs, content4)));
  this.frontier.push({ type: type4, match: type4.contentMatch });
};
Fitter$3.prototype.closeFrontierNode = function closeFrontierNode2() {
  var open = this.frontier.pop();
  var add2 = open.match.fillBefore(Fragment$4.empty, true);
  if (add2.childCount) {
    this.placed = addToFragment$3(this.placed, this.frontier.length, add2);
  }
};
Object.defineProperties(Fitter$3.prototype, prototypeAccessors$1$a);
function dropFromFragment$3(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment$3(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment$3(fragment, depth, content4) {
  if (depth == 0) {
    return fragment.append(content4);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment$3(fragment.lastChild.content, depth - 1, content4)));
}
function contentAt$3(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart$3(node8, openStart, openEnd) {
  if (openStart <= 0) {
    return node8;
  }
  var frag = node8.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart$3(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node8.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node8.type.contentMatch.matchFragment(frag).fillBefore(Fragment$4.empty, true));
    }
  }
  return node8.copy(frag);
}
function contentAfterFits$3($to, depth, type4, match, open) {
  var node8 = $to.node(depth), index6 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index6 == node8.childCount && !type4.compatibleContent(node8.type)) {
    return null;
  }
  var fit5 = match.fillBefore(node8.content, true, index6);
  return fit5 && !invalidMarks$3(type4, node8.content, index6) ? fit5 : null;
}
function invalidMarks$3(type4, fragment, start8) {
  for (var i = start8; i < fragment.childCount; i++) {
    if (!type4.allowsMarks(fragment.child(i).marks)) {
      return true;
    }
  }
  return false;
}
Transform$3.prototype.replaceRange = function(from8, to, slice11) {
  if (!slice11.size) {
    return this.deleteRange(from8, to);
  }
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  if (fitsTrivially$3($from, $to, slice11)) {
    return this.step(new ReplaceStep$3(from8, to, slice11));
  }
  var targetDepths = coveredDepths$3($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d) > -1) {
      preferredTarget = d;
    } else if ($from.before(d) == pos) {
      targetDepths.splice(1, 0, -d);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice11.openStart;
  for (var content4 = slice11.content, i = 0; ; i++) {
    var node8 = content4.firstChild;
    leftNodes.push(node8);
    if (i == slice11.openStart) {
      break;
    }
    content4 = node8.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice11.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index6 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index6, index6, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice$4(closeFragment$3(slice11.content, 0, slice11.openStart, openDepth), openDepth, slice11.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from8, to, slice11);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from8 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment$3(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment$3(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start8 = match.fillBefore(fragment).append(fragment);
    fragment = start8.append(match.matchFragment(start8).fillBefore(Fragment$4.empty, true));
  }
  return fragment;
}
Transform$3.prototype.replaceRangeWith = function(from8, to, node8) {
  if (!node8.isInline && from8 == to && this.doc.resolve(from8).parent.content.size) {
    var point = insertPoint$3(this.doc, from8, node8.type);
    if (point != null) {
      from8 = to = point;
    }
  }
  return this.replaceRange(from8, to, new Slice$4(Fragment$4.from(node8), 0, 0));
};
Transform$3.prototype.deleteRange = function(from8, to) {
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  var covered = coveredDepths$3($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from8 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
      return this.delete($from.before(d), to);
    }
  }
  return this.delete(from8, to);
};
function coveredDepths$3($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start8 = $from.start(d);
    if (start8 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start8 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start8 - 1) {
      result2.push(d);
    }
  }
  return result2;
}
const classesById$2 = /* @__PURE__ */ Object.create(null);
class Selection$2 {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange$2($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content4 = Slice$4.empty) {
    let lastNode = content4.content.lastChild, lastParent = null;
    for (let i = 0; i < content4.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice$4.empty : content4);
      if (i == 0)
        selectionToInsertionEnd$2(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node8) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from8 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from8, to);
      } else {
        tr.replaceRangeWith(from8, to, node8);
        selectionToInsertionEnd$2(tr, mapFrom, node8.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection$2($pos) : findSelectionIn$2($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn$2($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn$2($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection$2($pos.node(0));
  }
  static atStart(doc2) {
    return findSelectionIn$2(doc2, doc2, 0, 0, 1) || new AllSelection$2(doc2);
  }
  static atEnd(doc2) {
    return findSelectionIn$2(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection$2(doc2);
  }
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById$2[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  static jsonID(id, selectionClass) {
    if (id in classesById$2)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById$2[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection$2.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection$2.prototype.visible = true;
class SelectionRange$2 {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection$2 extends Selection$2 {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection$2.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection$2($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content4 = Slice$4.empty) {
    super.replace(tr, content4);
    if (content4 == Slice$4.empty) {
      let marks6 = this.$from.marksAcross(this.$to);
      if (marks6)
        tr.ensureMarks(marks6);
    }
  }
  eq(other) {
    return other instanceof TextSelection$2 && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark$2(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection$2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection$2.findFrom($head, bias, true) || Selection$2.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection$2.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection$2.findFrom($anchor, -bias, true) || Selection$2.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection$2($anchor, $head);
  }
}
Selection$2.jsonID("text", TextSelection$2);
class TextBookmark$2 {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark$2(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection$2.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection$2 extends Selection$2 {
  constructor($pos) {
    let node8 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node8.nodeSize);
    super($pos, $end);
    this.node = node8;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection$2.near($pos);
    return new NodeSelection$2($pos);
  }
  content() {
    return new Slice$4(Fragment$4.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection$2 && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark$2(this.anchor);
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection$2(doc2.resolve(json.anchor));
  }
  static create(doc2, from8) {
    return new NodeSelection$2(doc2.resolve(from8));
  }
  static isSelectable(node8) {
    return !node8.isText && node8.type.spec.selectable !== false;
  }
}
NodeSelection$2.prototype.visible = false;
Selection$2.jsonID("node", NodeSelection$2);
class NodeBookmark$2 {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark$2(pos, pos) : new NodeBookmark$2(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node8 = $pos.nodeAfter;
    if (node8 && NodeSelection$2.isSelectable(node8))
      return new NodeSelection$2($pos);
    return Selection$2.near($pos);
  }
}
class AllSelection$2 extends Selection$2 {
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content4 = Slice$4.empty) {
    if (content4 == Slice$4.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection$2.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content4);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc2) {
    return new AllSelection$2(doc2);
  }
  map(doc2) {
    return new AllSelection$2(doc2);
  }
  eq(other) {
    return other instanceof AllSelection$2;
  }
  getBookmark() {
    return AllBookmark$2;
  }
}
Selection$2.jsonID("all", AllSelection$2);
const AllBookmark$2 = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection$2(doc2);
  }
};
function findSelectionIn$2(doc2, node8, pos, index6, dir, text3 = false) {
  if (node8.inlineContent)
    return TextSelection$2.create(doc2, pos);
  for (let i = index6 - (dir > 0 ? 0 : 1); dir > 0 ? i < node8.childCount : i >= 0; i += dir) {
    let child11 = node8.child(i);
    if (!child11.isAtom) {
      let inner = findSelectionIn$2(doc2, child11, pos + dir, dir < 0 ? child11.childCount : 0, dir, text3);
      if (inner)
        return inner;
    } else if (!text3 && NodeSelection$2.isSelectable(child11)) {
      return NodeSelection$2.create(doc2, pos - (dir < 0 ? child11.nodeSize : 0));
    }
    pos += child11.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$2(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step5 = tr.steps[last];
  if (!(step5 instanceof ReplaceStep$3 || step5 instanceof ReplaceAroundStep$3))
    return;
  let map30 = tr.mapping.maps[last], end7;
  map30.forEach((_from, _to, _newFrom, newTo) => {
    if (end7 == null)
      end7 = newTo;
  });
  tr.setSelection(Selection$2.near(tr.doc.resolve(end7), bias));
}
function bind$2(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc$2 {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind$2(desc.init, self2);
    this.apply = bind$2(desc.apply, self2);
  }
}
[
  new FieldDesc$2("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc$2("selection", {
    init(config, instance) {
      return config.selection || Selection$2.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc$2("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc$2("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin2 {
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  getState(state) {
    return state[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey2 {
  constructor(name = "key") {
    this.key = createKey(name);
  }
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  getState(state) {
    return state[this.key];
  }
}
function findDiffStart$3(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart$3(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$3(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd$3(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
class Fragment$3 {
  constructor(content4, size) {
    this.content = content4;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content4.length; i++)
        this.size += content4[i].nodeSize;
  }
  nodesBetween(from8, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8 && f(child11, nodeStart + pos, parent || null, i) !== false && child11.content.size) {
        let start8 = pos + 1;
        child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
      }
      pos = end7;
    }
  }
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  textBetween(from8, to, blockSeparator, leafText) {
    let text3 = "", separated = true;
    this.nodesBetween(from8, to, (node8, pos) => {
      if (node8.isText) {
        text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node8.isLeaf) {
        if (leafText) {
          text3 += typeof leafText === "function" ? leafText(node8) : leafText;
        } else if (node8.type.spec.leafText) {
          text3 += node8.type.spec.leafText(node8);
        }
        separated = !blockSeparator;
      } else if (!separated && node8.isBlock) {
        text3 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text3;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content4[content4.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content4.push(other.content[i]);
    return new Fragment$3(content4, this.size + other.size);
  }
  cut(from8, to = this.size) {
    if (from8 == 0 && to == this.size)
      return this;
    let result2 = [], size = 0;
    if (to > from8)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child11 = this.content[i], end7 = pos + child11.nodeSize;
        if (end7 > from8) {
          if (pos < from8 || end7 > to) {
            if (child11.isText)
              child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
            else
              child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
          result2.push(child11);
          size += child11.nodeSize;
        }
        pos = end7;
      }
    return new Fragment$3(result2, size);
  }
  cutByIndex(from8, to) {
    if (from8 == to)
      return Fragment$3.empty;
    if (from8 == 0 && to == this.content.length)
      return this;
    return new Fragment$3(this.content.slice(from8, to));
  }
  replaceChild(index6, node8) {
    let current = this.content[index6];
    if (current == node8)
      return this;
    let copy12 = this.content.slice();
    let size = this.size + node8.nodeSize - current.nodeSize;
    copy12[index6] = node8;
    return new Fragment$3(copy12, size);
  }
  addToStart(node8) {
    return new Fragment$3([node8].concat(this.content), this.size + node8.nodeSize);
  }
  addToEnd(node8) {
    return new Fragment$3(this.content.concat(node8), this.size + node8.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index6) {
    let found2 = this.content[index6];
    if (!found2)
      throw new RangeError("Index " + index6 + " out of range for " + this);
    return found2;
  }
  maybeChild(index6) {
    return this.content[index6] || null;
  }
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child11 = this.content[i];
      f(child11, p, i);
      p += child11.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart$3(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd$3(this, other, pos, otherPos);
  }
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex$3(0, pos);
    if (pos == this.size)
      return retIndex$3(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end7 = curPos + cur.nodeSize;
      if (end7 >= pos) {
        if (end7 == pos || round2 > 0)
          return retIndex$3(i + 1, end7);
        return retIndex$3(i, curPos);
      }
      curPos = end7;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  static fromJSON(schema, value) {
    if (!value)
      return Fragment$3.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment$3(value.map(schema.nodeFromJSON));
  }
  static fromArray(array4) {
    if (!array4.length)
      return Fragment$3.empty;
    let joined, size = 0;
    for (let i = 0; i < array4.length; i++) {
      let node8 = array4[i];
      size += node8.nodeSize;
      if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
        if (!joined)
          joined = array4.slice(0, i);
        joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
      } else if (joined) {
        joined.push(node8);
      }
    }
    return new Fragment$3(joined || array4, size);
  }
  static from(nodes) {
    if (!nodes)
      return Fragment$3.empty;
    if (nodes instanceof Fragment$3)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment$3([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment$3.empty = new Fragment$3([], 0);
const found$3 = { index: 0, offset: 0 };
function retIndex$3(index6, offset6) {
  found$3.index = index6;
  found$3.offset = offset6;
  return found$3;
}
class Slice$3 {
  constructor(content4, openStart, openEnd) {
    this.content = content4;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment) {
    let content4 = insertInto$3(this.content, pos + this.openStart, fragment);
    return content4 && new Slice$3(content4, this.openStart, this.openEnd);
  }
  removeBetween(from8, to) {
    return new Slice$3(removeRange$3(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema, json) {
    if (!json)
      return Slice$3.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice$3(Fragment$3.fromJSON(schema, json.content), openStart, openEnd);
  }
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice$3(fragment, openStart, openEnd);
  }
}
Slice$3.empty = new Slice$3(Fragment$3.empty, 0, 0);
function removeRange$3(content4, from8, to) {
  let { index: index6, offset: offset6 } = content4.findIndex(from8), child11 = content4.maybeChild(index6);
  let { index: indexTo, offset: offsetTo } = content4.findIndex(to);
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content4.replaceChild(index6, child11.copy(removeRange$3(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto$3(content4, dist, insert, parent) {
  let { index: index6, offset: offset6 } = content4.findIndex(dist), child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert))
      return null;
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  let inner = insertInto$3(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
function findDiffStart$2(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$2(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$2(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$2(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$2 = function Fragment3(content4, size) {
  this.content = content4;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content4.length; i++) {
      this.size += content4[i].nodeSize;
    }
  }
};
var prototypeAccessors$c = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment$2.prototype.nodesBetween = function nodesBetween5(from8, to, f, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child11 = this.content[i], end7 = pos + child11.nodeSize;
    if (end7 > from8 && f(child11, nodeStart + pos, parent, i) !== false && child11.content.size) {
      var start8 = pos + 1;
      child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
    }
    pos = end7;
  }
};
Fragment$2.prototype.descendants = function descendants5(f) {
  this.nodesBetween(0, this.size, f);
};
Fragment$2.prototype.textBetween = function textBetween5(from8, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isText) {
      text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node8.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node8) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node8.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment$2.prototype.append = function append3(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content4[content4.length - 1] = last.withText(last.text + first2.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content4.push(other.content[i]);
  }
  return new Fragment$2(content4, this.size + other.size);
};
Fragment$2.prototype.cut = function cut5(from8, to) {
  if (to == null) {
    to = this.size;
  }
  if (from8 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from8) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8) {
        if (pos < from8 || end7 > to) {
          if (child11.isText) {
            child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
          } else {
            child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
        }
        result2.push(child11);
        size += child11.nodeSize;
      }
      pos = end7;
    }
  }
  return new Fragment$2(result2, size);
};
Fragment$2.prototype.cutByIndex = function cutByIndex3(from8, to) {
  if (from8 == to) {
    return Fragment$2.empty;
  }
  if (from8 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$2(this.content.slice(from8, to));
};
Fragment$2.prototype.replaceChild = function replaceChild3(index6, node8) {
  var current = this.content[index6];
  if (current == node8) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node8.nodeSize - current.nodeSize;
  copy12[index6] = node8;
  return new Fragment$2(copy12, size);
};
Fragment$2.prototype.addToStart = function addToStart3(node8) {
  return new Fragment$2([node8].concat(this.content), this.size + node8.nodeSize);
};
Fragment$2.prototype.addToEnd = function addToEnd3(node8) {
  return new Fragment$2(this.content.concat(node8), this.size + node8.nodeSize);
};
Fragment$2.prototype.eq = function eq17(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$c.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$c.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$c.childCount.get = function() {
  return this.content.length;
};
Fragment$2.prototype.child = function child5(index6) {
  var found2 = this.content[index6];
  if (!found2) {
    throw new RangeError("Index " + index6 + " out of range for " + this);
  }
  return found2;
};
Fragment$2.prototype.maybeChild = function maybeChild5(index6) {
  return this.content[index6];
};
Fragment$2.prototype.forEach = function forEach8(f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child11 = this.content[i];
    f(child11, p, i);
    p += child11.nodeSize;
  }
};
Fragment$2.prototype.findDiffStart = function findDiffStart$13(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$2(this, other, pos);
};
Fragment$2.prototype.findDiffEnd = function findDiffEnd$13(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$2(this, other, pos, otherPos);
};
Fragment$2.prototype.findIndex = function findIndex3(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex$2(0, pos);
  }
  if (pos == this.size) {
    return retIndex$2(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this.child(i), end7 = curPos + cur.nodeSize;
    if (end7 >= pos) {
      if (end7 == pos || round2 > 0) {
        return retIndex$2(i + 1, end7);
      }
      return retIndex$2(i, curPos);
    }
    curPos = end7;
  }
};
Fragment$2.prototype.toString = function toString14() {
  return "<" + this.toStringInner() + ">";
};
Fragment$2.prototype.toStringInner = function toStringInner3() {
  return this.content.join(", ");
};
Fragment$2.prototype.toJSON = function toJSON12() {
  return this.content.length ? this.content.map(function(n) {
    return n.toJSON();
  }) : null;
};
Fragment$2.fromJSON = function fromJSON13(schema, value) {
  if (!value) {
    return Fragment$2.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$2(value.map(schema.nodeFromJSON));
};
Fragment$2.fromArray = function fromArray3(array4) {
  if (!array4.length) {
    return Fragment$2.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array4.length; i++) {
    var node8 = array4[i];
    size += node8.nodeSize;
    if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
      if (!joined) {
        joined = array4.slice(0, i);
      }
      joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
    } else if (joined) {
      joined.push(node8);
    }
  }
  return new Fragment$2(joined || array4, size);
};
Fragment$2.from = function from4(nodes) {
  if (!nodes) {
    return Fragment$2.empty;
  }
  if (nodes instanceof Fragment$2) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment$2([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment$2.prototype, prototypeAccessors$c);
var found$2 = { index: 0, offset: 0 };
function retIndex$2(index6, offset6) {
  found$2.index = index6;
  found$2.offset = offset6;
  return found$2;
}
Fragment$2.empty = new Fragment$2([], 0);
function compareDeep$2(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array4 = Array.isArray(a);
  if (Array.isArray(b) != array4) {
    return false;
  }
  if (array4) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$2(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep$2(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$2 = function Mark3(type4, attrs) {
  this.type = type4;
  this.attrs = attrs;
};
Mark$2.prototype.addToSet = function addToSet3(set3) {
  var copy12, placed = false;
  for (var i = 0; i < set3.length; i++) {
    var other = set3[i];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set3.slice(0, i);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy12) {
          copy12 = set3.slice(0, i);
        }
        copy12.push(this);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set3.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$2.prototype.removeFromSet = function removeFromSet5(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return set3.slice(0, i).concat(set3.slice(i + 1));
    }
  }
  return set3;
};
Mark$2.prototype.isInSet = function isInSet5(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return true;
    }
  }
  return false;
};
Mark$2.prototype.eq = function eq18(other) {
  return this == other || this.type == other.type && compareDeep$2(this.attrs, other.attrs);
};
Mark$2.prototype.toJSON = function toJSON13() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark$2.fromJSON = function fromJSON14(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type4 = schema.marks[json.type];
  if (!type4) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type4.create(json.attrs);
};
Mark$2.sameSet = function sameSet3(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$2.setFrom = function setFrom3(marks6) {
  if (!marks6 || marks6.length == 0) {
    return Mark$2.none;
  }
  if (marks6 instanceof Mark$2) {
    return [marks6];
  }
  var copy12 = marks6.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$2.none = [];
function ReplaceError$2(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = ReplaceError$2.prototype;
  return err6;
}
ReplaceError$2.prototype = Object.create(Error.prototype);
ReplaceError$2.prototype.constructor = ReplaceError$2;
ReplaceError$2.prototype.name = "ReplaceError";
var Slice$2 = function Slice3(content4, openStart, openEnd) {
  this.content = content4;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$9 = { size: { configurable: true } };
prototypeAccessors$1$9.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$2.prototype.insertAt = function insertAt3(pos, fragment) {
  var content4 = insertInto$2(this.content, pos + this.openStart, fragment, null);
  return content4 && new Slice$2(content4, this.openStart, this.openEnd);
};
Slice$2.prototype.removeBetween = function removeBetween3(from8, to) {
  return new Slice$2(removeRange$2(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$2.prototype.eq = function eq19(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$2.prototype.toString = function toString15() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$2.prototype.toJSON = function toJSON14() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$2.fromJSON = function fromJSON15(schema, json) {
  if (!json) {
    return Slice$2.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$2(Fragment$2.fromJSON(schema, json.content), openStart, openEnd);
};
Slice$2.maxOpen = function maxOpen3(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
    openStart++;
  }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
    openEnd++;
  }
  return new Slice$2(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$2.prototype, prototypeAccessors$1$9);
function removeRange$2(content4, from8, to) {
  var ref2 = content4.findIndex(from8);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  var ref$1 = content4.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content4.replaceChild(index6, child11.copy(removeRange$2(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto$2(content4, dist, insert, parent) {
  var ref2 = content4.findIndex(dist);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert)) {
      return null;
    }
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  var inner = insertInto$2(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
Slice$2.empty = new Slice$2(Fragment$2.empty, 0, 0);
function replace$2($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$2("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$2("Inconsistent open depths");
  }
  return replaceOuter$2($from, $to, slice11, 0);
}
function replaceOuter$2($from, $to, slice11, depth) {
  var index6 = $from.index(depth), node8 = $from.node(depth);
  if (index6 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$2($from, $to, slice11, depth + 1);
    return node8.copy(node8.content.replaceChild(index6, inner));
  } else if (!slice11.content.size) {
    return close$2(node8, replaceTwoWay$2($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content4 = parent.content;
    return close$2(parent, content4.cut(0, $from.parentOffset).append(slice11.content).append(content4.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace$2(slice11, $from);
    var start8 = ref2.start;
    var end7 = ref2.end;
    return close$2(node8, replaceThreeWay$2($from, start8, end7, $to, depth));
  }
}
function checkJoin$2(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError$2("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$2($before, $after, depth) {
  var node8 = $before.node(depth);
  checkJoin$2(node8, $after.node(depth));
  return node8;
}
function addNode$2(child11, target) {
  var last = target.length - 1;
  if (last >= 0 && child11.isText && child11.sameMarkup(target[last])) {
    target[last] = child11.withText(target[last].text + child11.text);
  } else {
    target.push(child11);
  }
}
function addRange$2($start, $end, depth, target) {
  var node8 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node8.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode$2($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i = startIndex2; i < endIndex2; i++) {
    addNode$2(node8.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$2($end.nodeBefore, target);
  }
}
function close$2(node8, content4) {
  if (!node8.type.validContent(content4)) {
    throw new ReplaceError$2("Invalid content for node " + node8.type.name);
  }
  return node8.copy(content4);
}
function replaceThreeWay$2($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$2($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$2($end, $to, depth + 1);
  var content4 = [];
  addRange$2(null, $from, depth, content4);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$2(openStart, openEnd);
    addNode$2(close$2(openStart, replaceThreeWay$2($from, $start, $end, $to, depth + 1)), content4);
  } else {
    if (openStart) {
      addNode$2(close$2(openStart, replaceTwoWay$2($from, $start, depth + 1)), content4);
    }
    addRange$2($start, $end, depth, content4);
    if (openEnd) {
      addNode$2(close$2(openEnd, replaceTwoWay$2($end, $to, depth + 1)), content4);
    }
  }
  addRange$2($to, null, depth, content4);
  return new Fragment$2(content4);
}
function replaceTwoWay$2($from, $to, depth) {
  var content4 = [];
  addRange$2(null, $from, depth, content4);
  if ($from.depth > depth) {
    var type4 = joinable$2($from, $to, depth + 1);
    addNode$2(close$2(type4, replaceTwoWay$2($from, $to, depth + 1)), content4);
  }
  addRange$2($to, null, depth, content4);
  return new Fragment$2(content4);
}
function prepareSliceForReplace$2(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node8 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node8 = $along.node(i).copy(Fragment$2.from(node8));
  }
  return {
    start: node8.resolveNoCache(slice11.openStart + extra),
    end: node8.resolveNoCache(node8.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$2 = function ResolvedPos3(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos$2.prototype.resolveDepth = function resolveDepth3(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$2.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$2.doc.get = function() {
  return this.node(0);
};
ResolvedPos$2.prototype.node = function node5(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$2.prototype.index = function index3(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$2.prototype.indexAfter = function indexAfter3(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$2.prototype.start = function start5(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$2.prototype.end = function end4(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$2.prototype.before = function before3(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$2.prototype.after = function after3(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$2.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$2.nodeAfter.get = function() {
  var parent = this.parent, index6 = this.index(this.depth);
  if (index6 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child11 = parent.child(index6);
  return dOff ? parent.child(index6).cut(dOff) : child11;
};
prototypeAccessors$2$2.nodeBefore.get = function() {
  var index6 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index6).cut(0, dOff);
  }
  return index6 == 0 ? null : this.parent.child(index6 - 1);
};
ResolvedPos$2.prototype.posAtIndex = function posAtIndex3(index6, depth) {
  depth = this.resolveDepth(depth);
  var node8 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index6; i++) {
    pos += node8.child(i).nodeSize;
  }
  return pos;
};
ResolvedPos$2.prototype.marks = function marks3() {
  var parent = this.parent, index6 = this.index();
  if (parent.content.size == 0) {
    return Mark$2.none;
  }
  if (this.textOffset) {
    return parent.child(index6).marks;
  }
  var main2 = parent.maybeChild(index6 - 1), other = parent.maybeChild(index6);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks6 = main2.marks;
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!other || !marks6[i].isInSet(other.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$2.prototype.marksAcross = function marksAcross3($end) {
  var after6 = this.parent.maybeChild(this.index());
  if (!after6 || !after6.isInline) {
    return null;
  }
  var marks6 = after6.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!next || !marks6[i].isInSet(next.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$2.prototype.sharedDepth = function sharedDepth3(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$2.prototype.blockRange = function blockRange3(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
      return new NodeRange$2(this, other, d);
    }
  }
};
ResolvedPos$2.prototype.sameParent = function sameParent3(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$2.prototype.max = function max4(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$2.prototype.min = function min4(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$2.prototype.toString = function toString16() {
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$2.resolve = function resolve8(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start8 = 0, parentOffset = pos;
  for (var node8 = doc2; ; ) {
    var ref2 = node8.content.findIndex(parentOffset);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    var rem = parentOffset - offset6;
    path.push(node8, index6, start8 + offset6);
    if (!rem) {
      break;
    }
    node8 = node8.child(index6);
    if (node8.isText) {
      break;
    }
    parentOffset = rem - 1;
    start8 += offset6 + 1;
  }
  return new ResolvedPos$2(pos, path, parentOffset);
};
ResolvedPos$2.resolveCached = function resolveCached3(doc2, pos) {
  for (var i = 0; i < resolveCache$2.length; i++) {
    var cached = resolveCache$2[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$2[resolveCachePos$2] = ResolvedPos$2.resolve(doc2, pos);
  resolveCachePos$2 = (resolveCachePos$2 + 1) % resolveCacheSize$2;
  return result2;
};
Object.defineProperties(ResolvedPos$2.prototype, prototypeAccessors$2$2);
var resolveCache$2 = [], resolveCachePos$2 = 0, resolveCacheSize$2 = 12;
var NodeRange$2 = function NodeRange3($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$2 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$2.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$2.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$2.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$2.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$2.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$2.prototype, prototypeAccessors$1$1$2);
var emptyAttrs$2 = /* @__PURE__ */ Object.create(null);
var Node$2 = function Node3(type4, attrs, content4, marks6) {
  this.type = type4;
  this.attrs = attrs;
  this.content = content4 || Fragment$2.empty;
  this.marks = marks6 || Mark$2.none;
};
var prototypeAccessors$3$2 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$2.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$2.childCount.get = function() {
  return this.content.childCount;
};
Node$2.prototype.child = function child6(index6) {
  return this.content.child(index6);
};
Node$2.prototype.maybeChild = function maybeChild6(index6) {
  return this.content.maybeChild(index6);
};
Node$2.prototype.forEach = function forEach9(f) {
  this.content.forEach(f);
};
Node$2.prototype.nodesBetween = function nodesBetween6(from8, to, f, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from8, to, f, startPos, this);
};
Node$2.prototype.descendants = function descendants6(f) {
  this.nodesBetween(0, this.content.size, f);
};
prototypeAccessors$3$2.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$2.prototype.textBetween = function textBetween6(from8, to, blockSeparator, leafText) {
  return this.content.textBetween(from8, to, blockSeparator, leafText);
};
prototypeAccessors$3$2.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$2.lastChild.get = function() {
  return this.content.lastChild;
};
Node$2.prototype.eq = function eq20(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$2.prototype.sameMarkup = function sameMarkup3(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$2.prototype.hasMarkup = function hasMarkup3(type4, attrs, marks6) {
  return this.type == type4 && compareDeep$2(this.attrs, attrs || type4.defaultAttrs || emptyAttrs$2) && Mark$2.sameSet(this.marks, marks6 || Mark$2.none);
};
Node$2.prototype.copy = function copy6(content4) {
  if (content4 === void 0)
    content4 = null;
  if (content4 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content4, this.marks);
};
Node$2.prototype.mark = function mark4(marks6) {
  return marks6 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks6);
};
Node$2.prototype.cut = function cut6(from8, to) {
  if (from8 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from8, to));
};
Node$2.prototype.slice = function slice5(from8, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from8 == to) {
    return Slice$2.empty;
  }
  var $from = this.resolve(from8), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start8 = $from.start(depth), node8 = $from.node(depth);
  var content4 = node8.content.cut($from.pos - start8, $to.pos - start8);
  return new Slice$2(content4, $from.depth - depth, $to.depth - depth);
};
Node$2.prototype.replace = function replace$13(from8, to, slice11) {
  return replace$2(this.resolve(from8), this.resolve(to), slice11);
};
Node$2.prototype.nodeAt = function nodeAt3(pos) {
  for (var node8 = this; ; ) {
    var ref2 = node8.content.findIndex(pos);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    node8 = node8.maybeChild(index6);
    if (!node8) {
      return null;
    }
    if (offset6 == pos || node8.isText) {
      return node8;
    }
    pos -= offset6 + 1;
  }
};
Node$2.prototype.childAfter = function childAfter3(pos) {
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  return { node: this.content.maybeChild(index6), index: index6, offset: offset6 };
};
Node$2.prototype.childBefore = function childBefore3(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  if (offset6 < pos) {
    return { node: this.content.child(index6), index: index6, offset: offset6 };
  }
  var node8 = this.content.child(index6 - 1);
  return { node: node8, index: index6 - 1, offset: offset6 - node8.nodeSize };
};
Node$2.prototype.resolve = function resolve9(pos) {
  return ResolvedPos$2.resolveCached(this, pos);
};
Node$2.prototype.resolveNoCache = function resolveNoCache3(pos) {
  return ResolvedPos$2.resolve(this, pos);
};
Node$2.prototype.rangeHasMark = function rangeHasMark3(from8, to, type4) {
  var found2 = false;
  if (to > from8) {
    this.nodesBetween(from8, to, function(node8) {
      if (type4.isInSet(node8.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$2.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$2.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$2.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$2.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$2.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$2.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$2.isAtom.get = function() {
  return this.type.isAtom;
};
Node$2.prototype.toString = function toString17() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$2(this.marks, name);
};
Node$2.prototype.contentMatchAt = function contentMatchAt3(index6) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index6);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node$2.prototype.canReplace = function canReplace3(from8, to, replacement, start8, end7) {
  if (replacement === void 0)
    replacement = Fragment$2.empty;
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = replacement.childCount;
  var one = this.contentMatchAt(from8).matchFragment(replacement, start8, end7);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start8; i < end7; i++) {
    if (!this.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$2.prototype.canReplaceWith = function canReplaceWith3(from8, to, type4, marks6) {
  if (marks6 && !this.type.allowsMarks(marks6)) {
    return false;
  }
  var start8 = this.contentMatchAt(from8).matchType(type4);
  var end7 = start8 && start8.matchFragment(this.content, to);
  return end7 ? end7.validEnd : false;
};
Node$2.prototype.canAppend = function canAppend3(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$2.prototype.check = function check3() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy12 = Mark$2.none;
  for (var i = 0; i < this.marks.length; i++) {
    copy12 = this.marks[i].addToSet(copy12);
  }
  if (!Mark$2.sameSet(copy12, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
      return m.type.name;
    }));
  }
  this.content.forEach(function(node8) {
    return node8.check();
  });
};
Node$2.prototype.toJSON = function toJSON15() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n) {
      return n.toJSON();
    });
  }
  return obj;
};
Node$2.fromJSON = function fromJSON16(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks6 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks6 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks6);
  }
  var content4 = Fragment$2.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content4, marks6);
};
Object.defineProperties(Node$2.prototype, prototypeAccessors$3$2);
function wrapMarks$2(marks6, str) {
  for (var i = marks6.length - 1; i >= 0; i--) {
    str = marks6[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$2 = function ContentMatch3(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$2 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch$2.parse = function parse4(string3, nodeTypes) {
  var stream = new TokenStream$2(string3, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$2.empty;
  }
  var expr = parseExpr$2(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa$2(nfa$2(expr));
  checkForDeadEnds$2(match, stream);
  return match;
};
ContentMatch$2.prototype.matchType = function matchType3(type4) {
  for (var i = 0; i < this.next.length; i += 2) {
    if (this.next[i] == type4) {
      return this.next[i + 1];
    }
  }
  return null;
};
ContentMatch$2.prototype.matchFragment = function matchFragment3(frag, start8, end7) {
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = frag.childCount;
  var cur = this;
  for (var i = start8; cur && i < end7; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$4$2.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4$2.defaultType.get = function() {
  for (var i = 0; i < this.next.length; i += 2) {
    var type4 = this.next[i];
    if (!(type4.isText || type4.hasRequiredAttrs())) {
      return type4;
    }
  }
};
ContentMatch$2.prototype.compatible = function compatible3(other) {
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$2.prototype.fillBefore = function fillBefore3(after6, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match, types2) {
    var finished = match.matchFragment(after6, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$2.from(types2.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i], next = match.next[i + 1];
      if (!(type4.isText || type4.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types2.concat(type4));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$2.prototype.findWrapping = function findWrapping6(target) {
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this.wrapCache[i] == target) {
      return this.wrapCache[i + 1];
    }
  }
  var computed2 = this.computeWrapping(target);
  this.wrapCache.push(target, computed2);
  return computed2;
};
ContentMatch$2.prototype.computeWrapping = function computeWrapping3(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i];
      if (!type4.isLeaf && !type4.hasRequiredAttrs() && !(type4.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({ match: type4.contentMatch, type: type4, via: current });
        seen[type4.name] = true;
      }
    }
  }
};
prototypeAccessors$4$2.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$2.prototype.edge = function edge3(n) {
  var i = n << 1;
  if (i >= this.next.length) {
    throw new RangeError("There's no " + n + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$2.prototype.toString = function toString18() {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2) {
      if (seen.indexOf(m.next[i]) == -1) {
        scan(m.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$2.prototype, prototypeAccessors$4$2);
ContentMatch$2.empty = new ContentMatch$2(true);
var TokenStream$2 = function TokenStream3(string3, nodeTypes) {
  this.string = string3;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string3.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$2 = { next: { configurable: true } };
prototypeAccessors$1$2$2.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$2.prototype.eat = function eat3(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$2.prototype.err = function err3(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$2.prototype, prototypeAccessors$1$2$2);
function parseExpr$2(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$2(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$2(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$2(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$2(stream) {
  var expr = parseExprAtom$2(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$2(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$2(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$2(stream, expr) {
  var min7 = parseNum$2(stream), max7 = min7;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max7 = parseNum$2(stream);
    } else {
      max7 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min7, max: max7, expr };
}
function resolveName$2(stream, name) {
  var types2 = stream.nodeTypes, type4 = types2[name];
  if (type4) {
    return [type4];
  }
  var result2 = [];
  for (var typeName in types2) {
    var type$12 = types2[typeName];
    if (type$12.groups.indexOf(name) > -1) {
      result2.push(type$12);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$2(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$2(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$2(stream, stream.next).map(function(type4) {
      if (stream.inline == null) {
        stream.inline = type4.isInline;
      } else if (stream.inline != type4.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type4 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$2(expr) {
  var nfa2 = [[]];
  connect(compile11(expr, 0), node8());
  return nfa2;
  function node8() {
    return nfa2.push([]) - 1;
  }
  function edge6(from8, to, term) {
    var edge7 = { term, to };
    nfa2[from8].push(edge7);
    return edge7;
  }
  function connect(edges, to) {
    edges.forEach(function(edge7) {
      return edge7.to = to;
    });
  }
  function compile11(expr2, from8) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile11(expr3, from8));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile11(expr2.exprs[i], from8);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from8 = node8());
      }
    } else if (expr2.type == "star") {
      var loop = node8();
      edge6(from8, loop);
      connect(compile11(expr2.expr, loop), loop);
      return [edge6(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node8();
      connect(compile11(expr2.expr, from8), loop$1);
      connect(compile11(expr2.expr, loop$1), loop$1);
      return [edge6(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge6(from8)].concat(compile11(expr2.expr, from8));
    } else if (expr2.type == "range") {
      var cur = from8;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node8();
        connect(compile11(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile11(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node8();
          edge6(cur, next$2);
          connect(compile11(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge6(cur)];
    } else if (expr2.type == "name") {
      return [edge6(from8, null, expr2.value)];
    }
  }
}
function cmp$2(a, b) {
  return b - a;
}
function nullFrom$2(nfa2, node8) {
  var result2 = [];
  scan(node8);
  return result2.sort(cmp$2);
  function scan(node9) {
    var edges = nfa2[node9];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node9);
    for (var i = 0; i < edges.length; i++) {
      var ref2 = edges[i];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$2(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$2(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node8) {
      nfa2[node8].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom$2(nfa2, to).forEach(function(node9) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node9) == -1) {
            set3.push(node9);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$2(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$2);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$2(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node8 = state.next[j], next = state.next[j + 1];
      nodes.push(node8.name);
      if (dead && !(node8.isText || node8.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs$2(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs$2(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$2(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$2(attrs[name]);
    }
  }
  return result2;
}
var NodeType$3 = function NodeType4(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$2(spec.attrs);
  this.defaultAttrs = defaultAttrs$2(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$2 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$2.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$2.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$2.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$2.empty;
};
prototypeAccessors$5$2.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$2.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$3.prototype.hasRequiredAttrs = function hasRequiredAttrs3() {
  for (var n in this.attrs) {
    if (this.attrs[n].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$3.prototype.compatibleContent = function compatibleContent3(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$3.prototype.computeAttrs = function computeAttrs$13(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$2(this.attrs, attrs);
  }
};
NodeType$3.prototype.create = function create7(attrs, content4, marks6) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$2(this, this.computeAttrs(attrs), Fragment$2.from(content4), Mark$2.setFrom(marks6));
};
NodeType$3.prototype.createChecked = function createChecked3(attrs, content4, marks6) {
  content4 = Fragment$2.from(content4);
  if (!this.validContent(content4)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$2(this, this.computeAttrs(attrs), content4, Mark$2.setFrom(marks6));
};
NodeType$3.prototype.createAndFill = function createAndFill3(attrs, content4, marks6) {
  attrs = this.computeAttrs(attrs);
  content4 = Fragment$2.from(content4);
  if (content4.size) {
    var before6 = this.contentMatch.fillBefore(content4);
    if (!before6) {
      return null;
    }
    content4 = before6.append(content4);
  }
  var after6 = this.contentMatch.matchFragment(content4).fillBefore(Fragment$2.empty, true);
  if (!after6) {
    return null;
  }
  return new Node$2(this, attrs, content4.append(after6), Mark$2.setFrom(marks6));
};
NodeType$3.prototype.validContent = function validContent3(content4) {
  var result2 = this.contentMatch.matchFragment(content4);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content4.childCount; i++) {
    if (!this.allowsMarks(content4.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$3.prototype.allowsMarkType = function allowsMarkType3(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$3.prototype.allowsMarks = function allowsMarks3(marks6) {
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$3.prototype.allowedMarks = function allowedMarks3(marks6) {
  if (this.markSet == null) {
    return marks6;
  }
  var copy12;
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      if (!copy12) {
        copy12 = marks6.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks6[i]);
    }
  }
  return !copy12 ? marks6 : copy12.length ? copy12 : Mark$2.empty;
};
NodeType$3.compile = function compile5(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$3(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$3.prototype, prototypeAccessors$5$2);
var Attribute$2 = function Attribute3(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$2 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$2.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$2.prototype, prototypeAccessors$1$3$2);
var MarkType$2 = function MarkType3(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs$2(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs$2(this.attrs);
  this.instance = defaults2 && new Mark$2(this, defaults2);
};
MarkType$2.prototype.create = function create8(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$2(this, computeAttrs$2(this.attrs, attrs));
};
MarkType$2.compile = function compile6(marks6, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks6.forEach(function(name, spec) {
    return result2[name] = new MarkType$2(name, rank++, schema, spec);
  });
  return result2;
};
MarkType$2.prototype.removeFromSet = function removeFromSet6(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      set3 = set3.slice(0, i).concat(set3.slice(i + 1));
      i--;
    }
  }
  return set3;
};
MarkType$2.prototype.isInSet = function isInSet6(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      return set3[i];
    }
  }
};
MarkType$2.prototype.excludes = function excludes3(other) {
  return this.excluded.indexOf(other) > -1;
};
var blockTags$2 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$2 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$2 = { ol: true, ul: true };
var OPT_PRESERVE_WS$2 = 1, OPT_PRESERVE_WS_FULL$2 = 2, OPT_OPEN_LEFT$2 = 4;
function wsOptionsFor$2(type4, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS$2 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$2 : 0);
  }
  return type4 && type4.whitespace == "pre" ? OPT_PRESERVE_WS$2 | OPT_PRESERVE_WS_FULL$2 : base2 & ~OPT_OPEN_LEFT$2;
}
var NodeContext$2 = function NodeContext3(type4, attrs, marks6, pendingMarks, solid, match, options) {
  this.type = type4;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT$2 ? null : type4.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks6;
  this.activeMarks = Mark$2.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext$2.prototype.findWrapping = function findWrapping7(node8) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$2.from(node8));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start8 = this.type.contentMatch, wrap2;
      if (wrap2 = start8.findWrapping(node8.type)) {
        this.match = start8;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node8.type);
};
NodeContext$2.prototype.finish = function finish5(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$2)) {
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
  }
  var content4 = Fragment$2.from(this.content);
  if (!openEnd && this.match) {
    content4 = content4.append(this.match.fillBefore(Fragment$2.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content4, this.marks) : content4;
};
NodeContext$2.prototype.popFromStashMark = function popFromStashMark3(mark7) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--) {
    if (mark7.eq(this.stashMarks[i])) {
      return this.stashMarks.splice(i, 1)[0];
    }
  }
};
NodeContext$2.prototype.applyPending = function applyPending3(nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark7 = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark7.type) : markMayApply$2(mark7.type, nextType)) && !mark7.isInSet(this.activeMarks)) {
      this.activeMarks = mark7.addToSet(this.activeMarks);
      this.pendingMarks = mark7.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext$2.prototype.inlineContext = function inlineContext3(node8) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node8.parentNode && !blockTags$2.hasOwnProperty(node8.parentNode.nodeName.toLowerCase());
};
var ParseContext$2 = function ParseContext3(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$2(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT$2 : 0);
  if (topNode) {
    topContext = new NodeContext$2(topNode.type, topNode.attrs, Mark$2.none, Mark$2.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext$2(null, null, Mark$2.none, Mark$2.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$2(parser.schema.topNodeType, null, Mark$2.none, Mark$2.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$2 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6$2.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$2.prototype.addDOM = function addDOM3(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks6 = style2 ? this.readStyles(parseStyles$2(style2)) : null, top2 = this.top;
    if (marks6 != null) {
      for (var i = 0; i < marks6.length; i++) {
        this.addPendingMark(marks6[i]);
      }
    }
    this.addElement(dom);
    if (marks6 != null) {
      for (var i$1 = 0; i$1 < marks6.length; i$1++) {
        this.removePendingMark(marks6[i$1], top2);
      }
    }
  }
};
ParseContext$2.prototype.addTextNode = function addTextNode3(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL$2 || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS$2)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL$2)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$2.prototype.addElement = function addElement3(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags$2.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList$2(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags$2.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync6, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$2.hasOwnProperty(name)) {
      sync6 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync6) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext$2.prototype.leafFallback = function leafFallback3(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext$2.prototype.ignoreFallback = function ignoreFallback3(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext$2.prototype.readStyles = function readStyles3(styles) {
  var marks6 = Mark$2.none;
  style:
    for (var i = 0; i < styles.length; i += 2) {
      for (var after6 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after6);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks6 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks6);
        if (rule.consuming === false) {
          after6 = rule;
        } else {
          break;
        }
      }
    }
  return marks6;
};
ParseContext$2.prototype.addElementByRule = function addElementByRule3(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync6, nodeType2, markType, mark7;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync6 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark7 = markType.create(rule.attrs);
    this.addPendingMark(mark7);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node8) {
      return this$1$1.insertNode(node8);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync6);
  }
  if (sync6) {
    this.sync(startIn);
    this.open--;
  }
  if (mark7) {
    this.removePendingMark(mark7, startIn);
  }
};
ParseContext$2.prototype.addAll = function addAll3(parent, sync6, startIndex2, endIndex2) {
  var index6 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end7 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end7; dom = dom.nextSibling, ++index6) {
    this.findAtPoint(parent, index6);
    this.addDOM(dom);
    if (sync6 && blockTags$2.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync6);
    }
  }
  this.findAtPoint(parent, index6);
};
ParseContext$2.prototype.findPlace = function findPlace3(node8) {
  var route, sync6;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node8);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync6 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync6);
  for (var i = 0; i < route.length; i++) {
    this.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$2.prototype.insertNode = function insertNode3(node8) {
  if (node8.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node8)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node8.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node8.type);
    }
    var marks6 = top2.activeMarks;
    for (var i = 0; i < node8.marks.length; i++) {
      if (!top2.type || top2.type.allowsMarkType(node8.marks[i].type)) {
        marks6 = node8.marks[i].addToSet(marks6);
      }
    }
    top2.content.push(node8.mark(marks6));
    return true;
  }
  return false;
};
ParseContext$2.prototype.enter = function enter4(type4, attrs, preserveWS) {
  var ok5 = this.findPlace(type4.create(attrs));
  if (ok5) {
    this.enterInner(type4, attrs, true, preserveWS);
  }
  return ok5;
};
ParseContext$2.prototype.enterInner = function enterInner3(type4, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type4);
  top2.match = top2.match && top2.match.matchType(type4, attrs);
  var options = wsOptionsFor$2(type4, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT$2 && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT$2;
  }
  this.nodes.push(new NodeContext$2(type4, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext$2.prototype.closeExtra = function closeExtra3(openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$2.prototype.finish = function finish6() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$2.prototype.sync = function sync3(to) {
  for (var i = this.open; i >= 0; i--) {
    if (this.nodes[i] == to) {
      this.open = i;
      return;
    }
  }
};
prototypeAccessors$6$2.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content4 = this.nodes[i].content;
    for (var j = content4.length - 1; j >= 0; j--) {
      pos += content4[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$2.prototype.findAtPoint = function findAtPoint3(parent, offset6) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset6) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$2.prototype.findInside = function findInside3(parent) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$2.prototype.findAround = function findAround3(parent, content4, before6) {
  if (parent != content4 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        var pos = content4.compareDocumentPosition(this.find[i].node);
        if (pos & (before6 ? 2 : 4)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext$2.prototype.findInText = function findInText3(textNode) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode) {
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }
};
ParseContext$2.prototype.matchesContext = function matchesContext3(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext$2.prototype.textblockFromContext = function textblockFromContext3() {
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type4 = this.parser.schema.nodes[name];
    if (type4.isTextblock && type4.defaultAttrs) {
      return type4;
    }
  }
};
ParseContext$2.prototype.addPendingMark = function addPendingMark3(mark7) {
  var found2 = findSameMarkInSet$2(mark7, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark7.addToSet(this.top.pendingMarks);
};
ParseContext$2.prototype.removePendingMark = function removePendingMark3(mark7, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark7);
    if (found2 > -1) {
      level.pendingMarks = mark7.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark7.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark7);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext$2.prototype, prototypeAccessors$6$2);
function normalizeList$2(dom) {
  for (var child11 = dom.firstChild, prevItem = null; child11; child11 = child11.nextSibling) {
    var name = child11.nodeType == 1 ? child11.nodeName.toLowerCase() : null;
    if (name && listTags$2.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child11);
      child11 = prevItem;
    } else if (name == "li") {
      prevItem = child11;
    } else if (name) {
      prevItem = null;
    }
  }
}
function parseStyles$2(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style2)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function markMayApply$2(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref2 = match.edge(i);
        var type4 = ref2.type;
        var next = ref2.next;
        if (type4 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet$2(mark7, set3) {
  for (var i = 0; i < set3.length; i++) {
    if (mark7.eq(set3[i])) {
      return set3[i];
    }
  }
}
var lower16$2 = 65535;
var factor16$2 = Math.pow(2, 16);
function makeRecover$2(index6, offset6) {
  return index6 + offset6 * factor16$2;
}
function recoverIndex$2(value) {
  return value & lower16$2;
}
function recoverOffset$2(value) {
  return (value - (value & lower16$2)) / factor16$2;
}
var MapResult$2 = function MapResult3(pos, deleted, recover5) {
  if (deleted === void 0)
    deleted = false;
  if (recover5 === void 0)
    recover5 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover5;
};
var StepMap$2 = function StepMap3(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap$2.prototype.recover = function recover3(value) {
  var diff = 0, index6 = recoverIndex$2(value);
  if (!this.inverted) {
    for (var i = 0; i < index6; i++) {
      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    }
  }
  return this.ranges[index6 * 3] + diff + recoverOffset$2(value);
};
StepMap$2.prototype.mapResult = function mapResult5(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap$2.prototype.map = function map16(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap$2.prototype._map = function _map5(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end7 = start8 + oldSize;
    if (pos <= end7) {
      var side = !oldSize ? assoc : pos == start8 ? -1 : pos == end7 ? 1 : assoc;
      var result2 = start8 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover5 = pos == (assoc < 0 ? start8 : end7) ? null : makeRecover$2(i / 3, pos - start8);
      return new MapResult$2(result2, assoc < 0 ? pos != start8 : pos != end7, recover5);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult$2(pos + diff);
};
StepMap$2.prototype.touches = function touches3(pos, recover5) {
  var diff = 0, index6 = recoverIndex$2(recover5);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], end7 = start8 + oldSize;
    if (pos <= end7 && i == index6 * 3) {
      return true;
    }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false;
};
StepMap$2.prototype.forEach = function forEach10(f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i], oldStart = start8 - (this.inverted ? diff : 0), newStart = start8 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap$2.prototype.invert = function invert7() {
  return new StepMap$2(this.ranges, !this.inverted);
};
StepMap$2.prototype.toString = function toString19() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap$2.offset = function offset4(n) {
  return n == 0 ? StepMap$2.empty : new StepMap$2(n < 0 ? [0, -n, 0] : [0, 0, n]);
};
StepMap$2.empty = new StepMap$2([]);
var Mapping$2 = function Mapping3(maps, mirror, from8, to) {
  this.maps = maps || [];
  this.from = from8 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping$2.prototype.slice = function slice6(from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping$2(this.maps, this.mirror, from8, to);
};
Mapping$2.prototype.copy = function copy7() {
  return new Mapping$2(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping$2.prototype.appendMap = function appendMap3(map30, mirrors) {
  this.to = this.maps.push(map30);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping$2.prototype.appendMapping = function appendMapping3(mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};
Mapping$2.prototype.getMirror = function getMirror3(n) {
  if (this.mirror) {
    for (var i = 0; i < this.mirror.length; i++) {
      if (this.mirror[i] == n) {
        return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping$2.prototype.setMirror = function setMirror3(n, m) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n, m);
};
Mapping$2.prototype.appendMappingInverted = function appendMappingInverted3(mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};
Mapping$2.prototype.invert = function invert8() {
  var inverse = new Mapping$2();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping$2.prototype.map = function map17(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i = this.from; i < this.to; i++) {
    pos = this.maps[i].map(pos, assoc);
  }
  return pos;
};
Mapping$2.prototype.mapResult = function mapResult6(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping$2.prototype._map = function _map6(pos, assoc, simple) {
  var deleted = false;
  for (var i = this.from; i < this.to; i++) {
    var map30 = this.maps[i], result2 = map30.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult$2(pos, deleted);
};
function TransformError$2(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = TransformError$2.prototype;
  return err6;
}
TransformError$2.prototype = Object.create(Error.prototype);
TransformError$2.prototype.constructor = TransformError$2;
TransformError$2.prototype.name = "TransformError";
var Transform$2 = function Transform3(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping$2();
};
var prototypeAccessors$b = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$b.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform$2.prototype.step = function step3(object4) {
  var result2 = this.maybeStep(object4);
  if (result2.failed) {
    throw new TransformError$2(result2.failed);
  }
  return this;
};
Transform$2.prototype.maybeStep = function maybeStep3(step5) {
  var result2 = step5.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step5, result2.doc);
  }
  return result2;
};
prototypeAccessors$b.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform$2.prototype.addStep = function addStep3(step5, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step5);
  this.mapping.appendMap(step5.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform$2.prototype, prototypeAccessors$b);
function mustOverride$1() {
  throw new Error("Override me");
}
var stepsByID$2 = /* @__PURE__ */ Object.create(null);
var Step$2 = function Step3() {
};
Step$2.prototype.apply = function apply8(_doc) {
  return mustOverride$1();
};
Step$2.prototype.getMap = function getMap3() {
  return StepMap$2.empty;
};
Step$2.prototype.invert = function invert9(_doc) {
  return mustOverride$1();
};
Step$2.prototype.map = function map18(_mapping) {
  return mustOverride$1();
};
Step$2.prototype.merge = function merge3(_other) {
  return null;
};
Step$2.prototype.toJSON = function toJSON16() {
  return mustOverride$1();
};
Step$2.fromJSON = function fromJSON17(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type4 = stepsByID$2[json.stepType];
  if (!type4) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type4.fromJSON(schema, json);
};
Step$2.jsonID = function jsonID4(id, stepClass) {
  if (id in stepsByID$2) {
    throw new RangeError("Duplicate use of step JSON ID " + id);
  }
  stepsByID$2[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass;
};
var StepResult$2 = function StepResult3(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult$2.ok = function ok3(doc2) {
  return new StepResult$2(doc2, null);
};
StepResult$2.fail = function fail3(message) {
  return new StepResult$2(null, message);
};
StepResult$2.fromReplace = function fromReplace3(doc2, from8, to, slice11) {
  try {
    return StepResult$2.ok(doc2.replace(from8, to, slice11));
  } catch (e) {
    if (e instanceof ReplaceError$2) {
      return StepResult$2.fail(e.message);
    }
    throw e;
  }
};
var ReplaceStep$2 = /* @__PURE__ */ function(Step6) {
  function ReplaceStep2(from8, to, slice11, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.slice = slice11;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceStep2.__proto__ = Step6;
  ReplaceStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && contentBetween$2(doc2, this.from, this.to)) {
      return StepResult$2.fail("Structure replace would overwrite content");
    }
    return StepResult$2.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap5() {
    return new StepMap$2([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert13(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from8.pos, Math.max(from8.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge6(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice11 = this.slice.size + other.slice.size == 0 ? Slice$2.empty : new Slice$2(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice$2.empty : new Slice$2(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON28() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice$2.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step$2);
Step$2.jsonID("replace", ReplaceStep$2);
var ReplaceAroundStep$2 = /* @__PURE__ */ function(Step6) {
  function ReplaceAroundStep2(from8, to, gapFrom, gapTo, slice11, insert, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceAroundStep2.__proto__ = Step6;
  ReplaceAroundStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && (contentBetween$2(doc2, this.from, this.gapFrom) || contentBetween$2(doc2, this.gapTo, this.to))) {
      return StepResult$2.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult$2.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult$2.fail("Content does not fit in gap");
    }
    return StepResult$2.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap5() {
    return new StepMap$2([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert13(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from8.deleted && to.deleted || gapFrom < from8.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from8.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON28() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice$2.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step$2);
Step$2.jsonID("replaceAround", ReplaceAroundStep$2);
function contentBetween$2(doc2, from8, to) {
  var $from = doc2.resolve(from8), dist = to - from8, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
Transform$2.prototype.lift = function(range3, target) {
  var $from = range3.$from;
  var $to = range3.$to;
  var depth = range3.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start8 = gapStart, end7 = gapEnd;
  var before6 = Fragment$2.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before6 = Fragment$2.from($from.node(d).copy(before6));
      openStart++;
    } else {
      start8--;
    }
  }
  var after6 = Fragment$2.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after6 = Fragment$2.from($to.node(d$1).copy(after6));
      openEnd++;
    } else {
      end7++;
    }
  }
  return this.step(new ReplaceAroundStep$2(start8, end7, gapStart, gapEnd, new Slice$2(before6.append(after6), openStart, openEnd), before6.size - openStart, true));
};
Transform$2.prototype.wrap = function(range3, wrappers) {
  var content4 = Fragment$2.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content4 = Fragment$2.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  var start8 = range3.start, end7 = range3.end;
  return this.step(new ReplaceAroundStep$2(start8, end7, start8, end7, new Slice$2(content4, 0, 0), wrappers.length, true));
};
Transform$2.prototype.setBlockType = function(from8, to, type4, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from8;
  if (!type4.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isTextblock && !node8.hasMarkup(type4, attrs) && canChangeType$2(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type4)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type4);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node8.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep$2(startM, endM, startM + 1, endM - 1, new Slice$2(Fragment$2.from(type4.create(attrs, null, node8.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType$2(doc2, pos, type4) {
  var $pos = doc2.resolve(pos), index6 = $pos.index();
  return $pos.parent.canReplaceWith(index6, index6 + 1, type4);
}
Transform$2.prototype.setNodeMarkup = function(pos, type4, attrs, marks6) {
  var node8 = this.doc.nodeAt(pos);
  if (!node8) {
    throw new RangeError("No node at given position");
  }
  if (!type4) {
    type4 = node8.type;
  }
  var newNode = type4.create(attrs, null, marks6 || node8.marks);
  if (node8.isLeaf) {
    return this.replaceWith(pos, pos + node8.nodeSize, newNode);
  }
  if (!type4.validContent(node8.content)) {
    throw new RangeError("Invalid content for node type " + type4.name);
  }
  return this.step(new ReplaceAroundStep$2(pos, pos + node8.nodeSize, pos + 1, pos + node8.nodeSize - 1, new Slice$2(Fragment$2.from(newNode), 0, 0), 1, true));
};
Transform$2.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before6 = Fragment$2.empty, after6 = Fragment$2.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before6 = Fragment$2.from($pos.node(d).copy(before6));
    var typeAfter = typesAfter && typesAfter[i];
    after6 = Fragment$2.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after6) : $pos.node(d).copy(after6));
  }
  return this.step(new ReplaceStep$2(pos, pos, new Slice$2(before6.append(after6), depth, depth), true));
};
Transform$2.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step5 = new ReplaceStep$2(pos - depth, pos + depth, Slice$2.empty, true);
  return this.step(step5);
};
function insertPoint$2(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index6 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2)) {
        return $pos.before(d + 1);
      }
      if (index6 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function mapFragment$2(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child11 = fragment.child(i);
    if (child11.content.size) {
      child11 = child11.copy(mapFragment$2(child11.content, f, child11));
    }
    if (child11.isInline) {
      child11 = f(child11, parent, i);
    }
    mapped.push(child11);
  }
  return Fragment$2.fromArray(mapped);
}
var AddMarkStep$2 = /* @__PURE__ */ function(Step6) {
  function AddMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    AddMarkStep2.__proto__ = Step6;
  AddMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice11 = new Slice$2(mapFragment$2(oldSlice.content, function(node8, parent2) {
      if (!node8.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node8;
      }
      return node8.mark(this$1$1.mark.addToSet(node8.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$2.fromReplace(doc2, this.from, this.to, slice11);
  };
  AddMarkStep2.prototype.invert = function invert13() {
    return new RemoveMarkStep$2(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from8.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step$2);
Step$2.jsonID("addMark", AddMarkStep$2);
var RemoveMarkStep$2 = /* @__PURE__ */ function(Step6) {
  function RemoveMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    RemoveMarkStep2.__proto__ = Step6;
  RemoveMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice11 = new Slice$2(mapFragment$2(oldSlice.content, function(node8) {
      return node8.mark(this$1$1.mark.removeFromSet(node8.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$2.fromReplace(doc2, this.from, this.to, slice11);
  };
  RemoveMarkStep2.prototype.invert = function invert13() {
    return new AddMarkStep$2(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from8.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step$2);
Step$2.jsonID("removeMark", RemoveMarkStep$2);
Transform$2.prototype.addMark = function(from8, to, mark7) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from8, to, function(node8, pos, parent) {
    if (!node8.isInline) {
      return;
    }
    var marks6 = node8.marks;
    if (!mark7.isInSet(marks6) && parent.type.allowsMarkType(mark7.type)) {
      var start8 = Math.max(pos, from8), end7 = Math.min(pos + node8.nodeSize, to);
      var newSet = mark7.addToSet(marks6);
      for (var i = 0; i < marks6.length; i++) {
        if (!marks6[i].isInSet(newSet)) {
          if (removing && removing.to == start8 && removing.mark.eq(marks6[i])) {
            removing.to = end7;
          } else {
            removed.push(removing = new RemoveMarkStep$2(start8, end7, marks6[i]));
          }
        }
      }
      if (adding && adding.to == start8) {
        adding.to = end7;
      } else {
        added.push(adding = new AddMarkStep$2(start8, end7, mark7));
      }
    }
  });
  removed.forEach(function(s) {
    return this$1$1.step(s);
  });
  added.forEach(function(s) {
    return this$1$1.step(s);
  });
  return this;
};
Transform$2.prototype.removeMark = function(from8, to, mark7) {
  var this$1$1 = this;
  if (mark7 === void 0)
    mark7 = null;
  var matched = [], step5 = 0;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (!node8.isInline) {
      return;
    }
    step5++;
    var toRemove = null;
    if (mark7 instanceof MarkType$2) {
      var set3 = node8.marks, found2;
      while (found2 = mark7.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark7) {
      if (mark7.isInSet(node8.marks)) {
        toRemove = [mark7];
      }
    } else {
      toRemove = node8.marks;
    }
    if (toRemove && toRemove.length) {
      var end7 = Math.min(pos + node8.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style2 = toRemove[i], found$12 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step5 - 1 && style2.eq(matched[j].style)) {
            found$12 = m;
          }
        }
        if (found$12) {
          found$12.to = end7;
          found$12.step = step5;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from8), to: end7, step: step5 });
        }
      }
    }
  });
  matched.forEach(function(m) {
    return this$1$1.step(new RemoveMarkStep$2(m.from, m.to, m.style));
  });
  return this;
};
Transform$2.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node8 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node8.childCount; i++) {
    var child11 = node8.child(i), end7 = cur + child11.nodeSize;
    var allowed = match.matchType(child11.type, child11.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep$2(cur, end7, Slice$2.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child11.marks.length; j++) {
        if (!parentType.allowsMarkType(child11.marks[j].type)) {
          this.step(new RemoveMarkStep$2(cur, end7, child11.marks[j]));
        }
      }
    }
    cur = end7;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment$2.empty, true);
    this.replace(cur, cur, new Slice$2(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep$2(doc2, from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$2.empty;
  if (from8 == to && !slice11.size) {
    return null;
  }
  var $from = doc2.resolve(from8), $to = doc2.resolve(to);
  if (fitsTrivially$2($from, $to, slice11)) {
    return new ReplaceStep$2(from8, to, slice11);
  }
  return new Fitter$2($from, $to, slice11).fit();
}
Transform$2.prototype.replace = function(from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$2.empty;
  var step5 = replaceStep$2(this.doc, from8, to, slice11);
  if (step5) {
    this.step(step5);
  }
  return this;
};
Transform$2.prototype.replaceWith = function(from8, to, content4) {
  return this.replace(from8, to, new Slice$2(Fragment$2.from(content4), 0, 0));
};
Transform$2.prototype.delete = function(from8, to) {
  return this.replace(from8, to, Slice$2.empty);
};
Transform$2.prototype.insert = function(pos, content4) {
  return this.replaceWith(pos, pos, content4);
};
function fitsTrivially$2($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
var Fitter$2 = function Fitter3($from, $to, slice11) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice11;
  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node8 = $from.node(i);
    this.frontier.push({
      type: node8.type,
      match: node8.contentMatchAt($from.indexAfter(i))
    });
  }
  this.placed = Fragment$2.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment$2.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$8 = { depth: { configurable: true } };
prototypeAccessors$1$8.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter$2.prototype.fit = function fit3() {
  while (this.unplaced.size) {
    var fit5 = this.findFittable();
    if (fit5) {
      this.placeNodes(fit5);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content4 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content4.childCount == 1) {
    content4 = content4.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice11 = new Slice$2(content4, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep$2($from.pos, moveInline, this.$to.pos, this.$to.end(), slice11, placedSize);
  }
  if (slice11.size || $from.pos != this.$to.pos) {
    return new ReplaceStep$2($from.pos, $to.pos, slice11);
  }
};
Fitter$2.prototype.findFittable = function findFittable3() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt$2(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first2 = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref2 = this.frontier[frontierDepth];
        var type4 = ref2.type;
        var match = ref2.match;
        var wrap2 = void 0, inject2 = void 0;
        if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment$2.from(first2), false)) : type4.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject: inject2 };
        } else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type))) {
          return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter$2.prototype.openMore = function openMore3() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$2(content4, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice$2(content4, openStart + 1, Math.max(openEnd, inner.size + openStart >= content4.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter$2.prototype.dropNode = function dropNode3() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$2(content4, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content4.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice$2(dropFromFragment$2(content4, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice$2(dropFromFragment$2(content4, openStart, 1), openStart, openEnd);
  }
};
Fitter$2.prototype.placeNodes = function placeNodes3(ref2) {
  var sliceDepth = ref2.sliceDepth;
  var frontierDepth = ref2.frontierDepth;
  var parent = ref2.parent;
  var inject2 = ref2.inject;
  var wrap2 = ref2.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap2) {
    for (var i = 0; i < wrap2.length; i++) {
      this.openFrontierNode(wrap2[i]);
    }
  }
  var slice11 = this.unplaced, fragment = parent ? parent.content : slice11.content;
  var openStart = slice11.openStart - sliceDepth;
  var taken = 0, add2 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type4 = ref$1.type;
  if (inject2) {
    for (var i$1 = 0; i$1 < inject2.childCount; i$1++) {
      add2.push(inject2.child(i$1));
    }
    match = match.matchFragment(inject2);
  }
  var openEndCount = fragment.size + sliceDepth - (slice11.content.size - slice11.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add2.push(closeNodeStart$2(next.mark(type4.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment$2(this.placed, frontierDepth, Fragment$2.from(add2));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node8 = cur.lastChild;
    this.frontier.push({ type: node8.type, match: node8.contentMatchAt(node8.childCount) });
    cur = node8.content;
  }
  this.unplaced = !toEnd ? new Slice$2(dropFromFragment$2(slice11.content, sliceDepth, taken), slice11.openStart, slice11.openEnd) : sliceDepth == 0 ? Slice$2.empty : new Slice$2(dropFromFragment$2(slice11.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice11.openEnd : sliceDepth - 1);
};
Fitter$2.prototype.mustMoveInline = function mustMoveInline3() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits$2(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref2 = this.$to;
  var depth = ref2.depth;
  var after6 = this.$to.after(depth);
  while (depth > 1 && after6 == this.$to.end(--depth)) {
    ++after6;
  }
  return after6;
};
Fitter$2.prototype.findCloseLevel = function findCloseLevel3($to) {
  scan:
    for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      var ref2 = this.frontier[i];
      var match = ref2.match;
      var type4 = ref2.type;
      var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      var fit5 = contentAfterFits$2($to, i, type4, match, dropInner);
      if (!fit5) {
        continue;
      }
      for (var d = i - 1; d >= 0; d--) {
        var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$12 = ref$1.type;
        var matches2 = contentAfterFits$2($to, d, type$12, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i, fit: fit5, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
};
Fitter$2.prototype.close = function close3($to) {
  var close6 = this.findCloseLevel($to);
  if (!close6) {
    return null;
  }
  while (this.depth > close6.depth) {
    this.closeFrontierNode();
  }
  if (close6.fit.childCount) {
    this.placed = addToFragment$2(this.placed, close6.depth, close6.fit);
  }
  $to = close6.move;
  for (var d = close6.depth + 1; d <= $to.depth; d++) {
    var node8 = $to.node(d), add2 = node8.type.contentMatch.fillBefore(node8.content, true, $to.index(d));
    this.openFrontierNode(node8.type, node8.attrs, add2);
  }
  return $to;
};
Fitter$2.prototype.openFrontierNode = function openFrontierNode3(type4, attrs, content4) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type4);
  this.placed = addToFragment$2(this.placed, this.depth, Fragment$2.from(type4.create(attrs, content4)));
  this.frontier.push({ type: type4, match: type4.contentMatch });
};
Fitter$2.prototype.closeFrontierNode = function closeFrontierNode3() {
  var open = this.frontier.pop();
  var add2 = open.match.fillBefore(Fragment$2.empty, true);
  if (add2.childCount) {
    this.placed = addToFragment$2(this.placed, this.frontier.length, add2);
  }
};
Object.defineProperties(Fitter$2.prototype, prototypeAccessors$1$8);
function dropFromFragment$2(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment$2(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment$2(fragment, depth, content4) {
  if (depth == 0) {
    return fragment.append(content4);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment$2(fragment.lastChild.content, depth - 1, content4)));
}
function contentAt$2(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart$2(node8, openStart, openEnd) {
  if (openStart <= 0) {
    return node8;
  }
  var frag = node8.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart$2(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node8.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node8.type.contentMatch.matchFragment(frag).fillBefore(Fragment$2.empty, true));
    }
  }
  return node8.copy(frag);
}
function contentAfterFits$2($to, depth, type4, match, open) {
  var node8 = $to.node(depth), index6 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index6 == node8.childCount && !type4.compatibleContent(node8.type)) {
    return null;
  }
  var fit5 = match.fillBefore(node8.content, true, index6);
  return fit5 && !invalidMarks$2(type4, node8.content, index6) ? fit5 : null;
}
function invalidMarks$2(type4, fragment, start8) {
  for (var i = start8; i < fragment.childCount; i++) {
    if (!type4.allowsMarks(fragment.child(i).marks)) {
      return true;
    }
  }
  return false;
}
Transform$2.prototype.replaceRange = function(from8, to, slice11) {
  if (!slice11.size) {
    return this.deleteRange(from8, to);
  }
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  if (fitsTrivially$2($from, $to, slice11)) {
    return this.step(new ReplaceStep$2(from8, to, slice11));
  }
  var targetDepths = coveredDepths$2($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d) > -1) {
      preferredTarget = d;
    } else if ($from.before(d) == pos) {
      targetDepths.splice(1, 0, -d);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice11.openStart;
  for (var content4 = slice11.content, i = 0; ; i++) {
    var node8 = content4.firstChild;
    leftNodes.push(node8);
    if (i == slice11.openStart) {
      break;
    }
    content4 = node8.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice11.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index6 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index6, index6, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice$2(closeFragment$2(slice11.content, 0, slice11.openStart, openDepth), openDepth, slice11.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from8, to, slice11);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from8 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment$2(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment$2(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start8 = match.fillBefore(fragment).append(fragment);
    fragment = start8.append(match.matchFragment(start8).fillBefore(Fragment$2.empty, true));
  }
  return fragment;
}
Transform$2.prototype.replaceRangeWith = function(from8, to, node8) {
  if (!node8.isInline && from8 == to && this.doc.resolve(from8).parent.content.size) {
    var point = insertPoint$2(this.doc, from8, node8.type);
    if (point != null) {
      from8 = to = point;
    }
  }
  return this.replaceRange(from8, to, new Slice$2(Fragment$2.from(node8), 0, 0));
};
Transform$2.prototype.deleteRange = function(from8, to) {
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  var covered = coveredDepths$2($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from8 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
      return this.delete($from.before(d), to);
    }
  }
  return this.delete(from8, to);
};
function coveredDepths$2($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start8 = $from.start(d);
    if (start8 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start8 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start8 - 1) {
      result2.push(d);
    }
  }
  return result2;
}
var classesById$1 = /* @__PURE__ */ Object.create(null);
var Selection$1 = function Selection2($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange$1($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$a = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$a.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$a.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$a.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$a.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$a.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$a.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$a.empty.get = function() {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    if (ranges[i].$from.pos != ranges[i].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection$1.prototype.content = function content2() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection$1.prototype.replace = function replace2(tr, content4) {
  if (content4 === void 0)
    content4 = Slice$2.empty;
  var lastNode = content4.content.lastChild, lastParent = null;
  for (var i = 0; i < content4.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref2 = ranges[i$1];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice$2.empty : content4);
    if (i$1 == 0) {
      selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection$1.prototype.replaceWith = function replaceWith2(tr, node8) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref2 = ranges[i];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from8 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from8, to);
    } else {
      tr.replaceRangeWith(from8, to, node8);
      selectionToInsertionEnd$1(tr, mapFrom, node8.isInline ? -1 : 1);
    }
  }
};
Selection$1.findFrom = function findFrom2($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection$1($pos) : findSelectionIn$1($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn$1($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn$1($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection$1.near = function near2($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection$1($pos.node(0));
};
Selection$1.atStart = function atStart2(doc2) {
  return findSelectionIn$1(doc2, doc2, 0, 0, 1) || new AllSelection$1(doc2);
};
Selection$1.atEnd = function atEnd2(doc2) {
  return findSelectionIn$1(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection$1(doc2);
};
Selection$1.fromJSON = function fromJSON18(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById$1[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection$1.jsonID = function jsonID5(id, selectionClass) {
  if (id in classesById$1) {
    throw new RangeError("Duplicate use of selection JSON ID " + id);
  }
  classesById$1[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass;
};
Selection$1.prototype.getBookmark = function getBookmark2() {
  return TextSelection$1.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection$1.prototype, prototypeAccessors$a);
Selection$1.prototype.visible = true;
var SelectionRange$1 = function SelectionRange2($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection$1 = /* @__PURE__ */ function(Selection5) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection5.call(this, $anchor, $head);
  }
  if (Selection5)
    TextSelection2.__proto__ = Selection5;
  TextSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map30(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection5.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$2.empty;
    Selection5.prototype.replace.call(this, tr, content4);
    if (content4 == Slice$2.empty) {
      var marks6 = this.$from.marksAcross(this.$to);
      if (marks6) {
        tr.ensureMarks(marks6);
      }
    }
  };
  TextSelection2.prototype.eq = function eq29(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark4() {
    return new TextBookmark$1(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON28() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create15(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection5.findFrom($head, bias, true) || Selection5.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection5.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection5.findFrom($anchor, -bias, true) || Selection5.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection$1);
Selection$1.jsonID("text", TextSelection$1);
var TextBookmark$1 = function TextBookmark2(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark$1.prototype.map = function map19(mapping) {
  return new TextBookmark$1(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark$1.prototype.resolve = function resolve10(doc2) {
  return TextSelection$1.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection$1 = /* @__PURE__ */ function(Selection5) {
  function NodeSelection2($pos) {
    var node8 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node8.nodeSize);
    Selection5.call(this, $pos, $end);
    this.node = node8;
  }
  if (Selection5)
    NodeSelection2.__proto__ = Selection5;
  NodeSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map30(doc2, mapping) {
    var ref2 = mapping.mapResult(this.anchor);
    var deleted = ref2.deleted;
    var pos = ref2.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection5.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content4() {
    return new Slice$2(Fragment$2.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq29(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON28() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark4() {
    return new NodeBookmark$1(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create15(doc2, from8) {
    return new this(doc2.resolve(from8));
  };
  NodeSelection2.isSelectable = function isSelectable2(node8) {
    return !node8.isText && node8.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection$1);
NodeSelection$1.prototype.visible = false;
Selection$1.jsonID("node", NodeSelection$1);
var NodeBookmark$1 = function NodeBookmark2(anchor) {
  this.anchor = anchor;
};
NodeBookmark$1.prototype.map = function map20(mapping) {
  var ref2 = mapping.mapResult(this.anchor);
  var deleted = ref2.deleted;
  var pos = ref2.pos;
  return deleted ? new TextBookmark$1(pos, pos) : new NodeBookmark$1(pos);
};
NodeBookmark$1.prototype.resolve = function resolve11(doc2) {
  var $pos = doc2.resolve(this.anchor), node8 = $pos.nodeAfter;
  if (node8 && NodeSelection$1.isSelectable(node8)) {
    return new NodeSelection$1($pos);
  }
  return Selection$1.near($pos);
};
var AllSelection$1 = /* @__PURE__ */ function(Selection5) {
  function AllSelection2(doc2) {
    Selection5.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection5)
    AllSelection2.__proto__ = Selection5;
  AllSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$2.empty;
    if (content4 == Slice$2.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection5.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection5.prototype.replace.call(this, tr, content4);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON28() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON31(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map30(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq29(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark4() {
    return AllBookmark$1;
  };
  return AllSelection2;
}(Selection$1);
Selection$1.jsonID("all", AllSelection$1);
var AllBookmark$1 = {
  map: function map21() {
    return this;
  },
  resolve: function resolve12(doc2) {
    return new AllSelection$1(doc2);
  }
};
function findSelectionIn$1(doc2, node8, pos, index6, dir, text3) {
  if (node8.inlineContent) {
    return TextSelection$1.create(doc2, pos);
  }
  for (var i = index6 - (dir > 0 ? 0 : 1); dir > 0 ? i < node8.childCount : i >= 0; i += dir) {
    var child11 = node8.child(i);
    if (!child11.isAtom) {
      var inner = findSelectionIn$1(doc2, child11, pos + dir, dir < 0 ? child11.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection$1.isSelectable(child11)) {
      return NodeSelection$1.create(doc2, pos - (dir < 0 ? child11.nodeSize : 0));
    }
    pos += child11.nodeSize * dir;
  }
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step5 = tr.steps[last];
  if (!(step5 instanceof ReplaceStep$2 || step5 instanceof ReplaceAroundStep$2)) {
    return;
  }
  var map30 = tr.mapping.maps[last], end7;
  map30.forEach(function(_from, _to, _newFrom, newTo) {
    if (end7 == null) {
      end7 = newTo;
    }
  });
  tr.setSelection(Selection$1.near(tr.doc.resolve(end7), bias));
}
var UPDATED_SEL$1 = 1, UPDATED_MARKS$1 = 2, UPDATED_SCROLL$1 = 4;
var Transaction$1 = /* @__PURE__ */ function(Transform6) {
  function Transaction2(state) {
    Transform6.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform6)
    Transaction2.__proto__ = Transform6;
  Transaction2.prototype = Object.create(Transform6 && Transform6.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection2(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL$1) & ~UPDATED_MARKS$1;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL$1) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks6) {
    this.storedMarks = marks6;
    this.updated |= UPDATED_MARKS$1;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks2(marks6) {
    if (!Mark$2.sameSet(this.storedMarks || this.selection.$from.marks(), marks6)) {
      this.setStoredMarks(marks6);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark7) {
    return this.ensureMarks(mark7.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark7) {
    return this.ensureMarks(mark7.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS$1) > 0;
  };
  Transaction2.prototype.addStep = function addStep5(step5, doc2) {
    Transform6.prototype.addStep.call(this, step5, doc2);
    this.updated = this.updated & ~UPDATED_MARKS$1;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice11) {
    this.selection.replace(this, slice11);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node8, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node8 = node8.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$2.none));
    }
    selection.replaceWith(this, node8);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text3, from8, to) {
    if (to === void 0)
      to = from8;
    var schema = this.doc.type.schema;
    if (from8 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from8, to);
      }
      var marks6 = this.storedMarks;
      if (!marks6) {
        var $from = this.doc.resolve(from8);
        marks6 = to == from8 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from8, to, schema.text(text3, marks6));
      if (!this.selection.empty) {
        this.setSelection(Selection$1.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta2(key2, value) {
    this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key2) {
    return this.meta[typeof key2 == "string" ? key2 : key2.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _ in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView2() {
    this.updated |= UPDATED_SCROLL$1;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL$1) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform$2);
function bind$1(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc$1 = function FieldDesc2(name, desc, self2) {
  this.name = name;
  this.init = bind$1(desc.init, self2);
  this.apply = bind$1(desc.apply, self2);
};
var baseFields$1 = [
  new FieldDesc$1("doc", {
    init: function init5(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply: function apply9(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc$1("selection", {
    init: function init6(config, instance) {
      return config.selection || Selection$1.atStart(instance.doc);
    },
    apply: function apply10(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc$1("storedMarks", {
    init: function init7(config) {
      return config.storedMarks || null;
    },
    apply: function apply11(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc$1("scrollToSelection", {
    init: function init8() {
      return 0;
    },
    apply: function apply12(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration$1 = function Configuration2(schema, plugins) {
  var this$1$1 = this;
  this.schema = schema;
  this.fields = baseFields$1.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc$1(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState$1 = function EditorState2(config) {
  this.config = config;
};
var prototypeAccessors$1$7 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$7.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$7.plugins.get = function() {
  return this.config.plugins;
};
EditorState$1.prototype.apply = function apply13(tr) {
  return this.applyTransaction(tr).state;
};
EditorState$1.prototype.filterTransaction = function filterTransaction2(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i = 0; i < this.config.plugins.length; i++) {
    if (i != ignore) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState$1.prototype.applyTransaction = function applyTransaction2(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++) {
              seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState$1.prototype.applyInner = function applyInner2(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState$1(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners$1.length; i$1++) {
    applyListeners$1[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$7.tr.get = function() {
  return new Transaction$1(this);
};
EditorState$1.create = function create9(config) {
  var $config = new Configuration$1(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState$1($config);
  for (var i = 0; i < $config.fields.length; i++) {
    instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
  }
  return instance;
};
EditorState$1.prototype.reconfigure = function reconfigure2(config) {
  var $config = new Configuration$1(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState$1($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance;
};
EditorState$1.prototype.toJSON = function toJSON17(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m) {
      return m.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState$1.fromJSON = function fromJSON19(config, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration$1(config.schema, config.plugins);
  var instance = new EditorState$1($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node$2.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection$1.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance;
};
EditorState$1.addApplyListener = function addApplyListener2(f) {
  applyListeners$1.push(f);
};
EditorState$1.removeApplyListener = function removeApplyListener2(f) {
  var found2 = applyListeners$1.indexOf(f);
  if (found2 > -1) {
    applyListeners$1.splice(found2, 1);
  }
};
Object.defineProperties(EditorState$1.prototype, prototypeAccessors$1$7);
var applyListeners$1 = [];
const mac$1 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space")
    result2 = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac$1)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result2 = "Alt-" + result2;
  if (ctrl)
    result2 = "Ctrl-" + result2;
  if (meta)
    result2 = "Meta-" + result2;
  if (shift2)
    result2 = "Shift-" + result2;
  return result2;
}
function normalize(map30) {
  let copy12 = /* @__PURE__ */ Object.create(null);
  for (let prop in map30)
    copy12[normalizeKeyName(prop)] = map30[prop];
  return copy12;
}
function modifiers(name, event, shift2) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 !== false && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keydownHandler(bindings) {
  let map30 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    let direct = map30[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base$1[event.keyCode]) && baseName != name) {
      let fromCode = map30[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view))
        return true;
    } else if (isChar && event.shiftKey) {
      let withShift = map30[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view))
        return true;
    }
    return false;
  };
}
function findDiffStart$14(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart$14(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd$14(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd$14(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment$1 = function Fragment4(content4, size) {
  this.content = content4;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content4.length; i++) {
      this.size += content4[i].nodeSize;
    }
  }
};
var prototypeAccessors$9 = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment$1.prototype.nodesBetween = function nodesBetween7(from8, to, f, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child11 = this.content[i], end7 = pos + child11.nodeSize;
    if (end7 > from8 && f(child11, nodeStart + pos, parent, i) !== false && child11.content.size) {
      var start8 = pos + 1;
      child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
    }
    pos = end7;
  }
};
Fragment$1.prototype.descendants = function descendants7(f) {
  this.nodesBetween(0, this.size, f);
};
Fragment$1.prototype.textBetween = function textBetween7(from8, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isText) {
      text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node8.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node8) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node8.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment$1.prototype.append = function append4(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content4[content4.length - 1] = last.withText(last.text + first2.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content4.push(other.content[i]);
  }
  return new Fragment$1(content4, this.size + other.size);
};
Fragment$1.prototype.cut = function cut7(from8, to) {
  if (to == null) {
    to = this.size;
  }
  if (from8 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from8) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8) {
        if (pos < from8 || end7 > to) {
          if (child11.isText) {
            child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
          } else {
            child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
        }
        result2.push(child11);
        size += child11.nodeSize;
      }
      pos = end7;
    }
  }
  return new Fragment$1(result2, size);
};
Fragment$1.prototype.cutByIndex = function cutByIndex4(from8, to) {
  if (from8 == to) {
    return Fragment$1.empty;
  }
  if (from8 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment$1(this.content.slice(from8, to));
};
Fragment$1.prototype.replaceChild = function replaceChild4(index6, node8) {
  var current = this.content[index6];
  if (current == node8) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node8.nodeSize - current.nodeSize;
  copy12[index6] = node8;
  return new Fragment$1(copy12, size);
};
Fragment$1.prototype.addToStart = function addToStart4(node8) {
  return new Fragment$1([node8].concat(this.content), this.size + node8.nodeSize);
};
Fragment$1.prototype.addToEnd = function addToEnd4(node8) {
  return new Fragment$1(this.content.concat(node8), this.size + node8.nodeSize);
};
Fragment$1.prototype.eq = function eq21(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$9.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$9.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$9.childCount.get = function() {
  return this.content.length;
};
Fragment$1.prototype.child = function child7(index6) {
  var found2 = this.content[index6];
  if (!found2) {
    throw new RangeError("Index " + index6 + " out of range for " + this);
  }
  return found2;
};
Fragment$1.prototype.maybeChild = function maybeChild7(index6) {
  return this.content[index6];
};
Fragment$1.prototype.forEach = function forEach11(f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child11 = this.content[i];
    f(child11, p, i);
    p += child11.nodeSize;
  }
};
Fragment$1.prototype.findDiffStart = function findDiffStart$1$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart$14(this, other, pos);
};
Fragment$1.prototype.findDiffEnd = function findDiffEnd$1$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd$14(this, other, pos, otherPos);
};
Fragment$1.prototype.findIndex = function findIndex4(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex$1(0, pos);
  }
  if (pos == this.size) {
    return retIndex$1(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this.child(i), end7 = curPos + cur.nodeSize;
    if (end7 >= pos) {
      if (end7 == pos || round2 > 0) {
        return retIndex$1(i + 1, end7);
      }
      return retIndex$1(i, curPos);
    }
    curPos = end7;
  }
};
Fragment$1.prototype.toString = function toString20() {
  return "<" + this.toStringInner() + ">";
};
Fragment$1.prototype.toStringInner = function toStringInner4() {
  return this.content.join(", ");
};
Fragment$1.prototype.toJSON = function toJSON18() {
  return this.content.length ? this.content.map(function(n) {
    return n.toJSON();
  }) : null;
};
Fragment$1.fromJSON = function fromJSON20(schema, value) {
  if (!value) {
    return Fragment$1.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment$1(value.map(schema.nodeFromJSON));
};
Fragment$1.fromArray = function fromArray4(array4) {
  if (!array4.length) {
    return Fragment$1.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array4.length; i++) {
    var node8 = array4[i];
    size += node8.nodeSize;
    if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
      if (!joined) {
        joined = array4.slice(0, i);
      }
      joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
    } else if (joined) {
      joined.push(node8);
    }
  }
  return new Fragment$1(joined || array4, size);
};
Fragment$1.from = function from5(nodes) {
  if (!nodes) {
    return Fragment$1.empty;
  }
  if (nodes instanceof Fragment$1) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment$1([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment$1.prototype, prototypeAccessors$9);
var found$1 = { index: 0, offset: 0 };
function retIndex$1(index6, offset6) {
  found$1.index = index6;
  found$1.offset = offset6;
  return found$1;
}
Fragment$1.empty = new Fragment$1([], 0);
function compareDeep$1(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array4 = Array.isArray(a);
  if (Array.isArray(b) != array4) {
    return false;
  }
  if (array4) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep$1(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep$1(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark$1 = function Mark4(type4, attrs) {
  this.type = type4;
  this.attrs = attrs;
};
Mark$1.prototype.addToSet = function addToSet4(set3) {
  var copy12, placed = false;
  for (var i = 0; i < set3.length; i++) {
    var other = set3[i];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set3.slice(0, i);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy12) {
          copy12 = set3.slice(0, i);
        }
        copy12.push(this);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set3.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark$1.prototype.removeFromSet = function removeFromSet7(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return set3.slice(0, i).concat(set3.slice(i + 1));
    }
  }
  return set3;
};
Mark$1.prototype.isInSet = function isInSet7(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return true;
    }
  }
  return false;
};
Mark$1.prototype.eq = function eq22(other) {
  return this == other || this.type == other.type && compareDeep$1(this.attrs, other.attrs);
};
Mark$1.prototype.toJSON = function toJSON19() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark$1.fromJSON = function fromJSON21(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type4 = schema.marks[json.type];
  if (!type4) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type4.create(json.attrs);
};
Mark$1.sameSet = function sameSet4(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark$1.setFrom = function setFrom4(marks6) {
  if (!marks6 || marks6.length == 0) {
    return Mark$1.none;
  }
  if (marks6 instanceof Mark$1) {
    return [marks6];
  }
  var copy12 = marks6.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark$1.none = [];
function ReplaceError$1(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = ReplaceError$1.prototype;
  return err6;
}
ReplaceError$1.prototype = Object.create(Error.prototype);
ReplaceError$1.prototype.constructor = ReplaceError$1;
ReplaceError$1.prototype.name = "ReplaceError";
var Slice$1 = function Slice4(content4, openStart, openEnd) {
  this.content = content4;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$6 = { size: { configurable: true } };
prototypeAccessors$1$6.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice$1.prototype.insertAt = function insertAt4(pos, fragment) {
  var content4 = insertInto$1(this.content, pos + this.openStart, fragment, null);
  return content4 && new Slice$1(content4, this.openStart, this.openEnd);
};
Slice$1.prototype.removeBetween = function removeBetween4(from8, to) {
  return new Slice$1(removeRange$1(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice$1.prototype.eq = function eq23(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice$1.prototype.toString = function toString21() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice$1.prototype.toJSON = function toJSON20() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice$1.fromJSON = function fromJSON22(schema, json) {
  if (!json) {
    return Slice$1.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice$1(Fragment$1.fromJSON(schema, json.content), openStart, openEnd);
};
Slice$1.maxOpen = function maxOpen4(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
    openStart++;
  }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
    openEnd++;
  }
  return new Slice$1(fragment, openStart, openEnd);
};
Object.defineProperties(Slice$1.prototype, prototypeAccessors$1$6);
function removeRange$1(content4, from8, to) {
  var ref2 = content4.findIndex(from8);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  var ref$1 = content4.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content4.replaceChild(index6, child11.copy(removeRange$1(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto$1(content4, dist, insert, parent) {
  var ref2 = content4.findIndex(dist);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert)) {
      return null;
    }
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  var inner = insertInto$1(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
Slice$1.empty = new Slice$1(Fragment$1.empty, 0, 0);
function replace$14($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError$1("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError$1("Inconsistent open depths");
  }
  return replaceOuter$1($from, $to, slice11, 0);
}
function replaceOuter$1($from, $to, slice11, depth) {
  var index6 = $from.index(depth), node8 = $from.node(depth);
  if (index6 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter$1($from, $to, slice11, depth + 1);
    return node8.copy(node8.content.replaceChild(index6, inner));
  } else if (!slice11.content.size) {
    return close$1(node8, replaceTwoWay$1($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content4 = parent.content;
    return close$1(parent, content4.cut(0, $from.parentOffset).append(slice11.content).append(content4.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace$1(slice11, $from);
    var start8 = ref2.start;
    var end7 = ref2.end;
    return close$1(node8, replaceThreeWay$1($from, start8, end7, $to, depth));
  }
}
function checkJoin$1(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError$1("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable$1($before, $after, depth) {
  var node8 = $before.node(depth);
  checkJoin$1(node8, $after.node(depth));
  return node8;
}
function addNode$1(child11, target) {
  var last = target.length - 1;
  if (last >= 0 && child11.isText && child11.sameMarkup(target[last])) {
    target[last] = child11.withText(target[last].text + child11.text);
  } else {
    target.push(child11);
  }
}
function addRange$1($start, $end, depth, target) {
  var node8 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node8.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode$1($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i = startIndex2; i < endIndex2; i++) {
    addNode$1(node8.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$1($end.nodeBefore, target);
  }
}
function close$1(node8, content4) {
  if (!node8.type.validContent(content4)) {
    throw new ReplaceError$1("Invalid content for node " + node8.type.name);
  }
  return node8.copy(content4);
}
function replaceThreeWay$1($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content4 = [];
  addRange$1(null, $from, depth, content4);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin$1(openStart, openEnd);
    addNode$1(close$1(openStart, replaceThreeWay$1($from, $start, $end, $to, depth + 1)), content4);
  } else {
    if (openStart) {
      addNode$1(close$1(openStart, replaceTwoWay$1($from, $start, depth + 1)), content4);
    }
    addRange$1($start, $end, depth, content4);
    if (openEnd) {
      addNode$1(close$1(openEnd, replaceTwoWay$1($end, $to, depth + 1)), content4);
    }
  }
  addRange$1($to, null, depth, content4);
  return new Fragment$1(content4);
}
function replaceTwoWay$1($from, $to, depth) {
  var content4 = [];
  addRange$1(null, $from, depth, content4);
  if ($from.depth > depth) {
    var type4 = joinable$1($from, $to, depth + 1);
    addNode$1(close$1(type4, replaceTwoWay$1($from, $to, depth + 1)), content4);
  }
  addRange$1($to, null, depth, content4);
  return new Fragment$1(content4);
}
function prepareSliceForReplace$1(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node8 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node8 = $along.node(i).copy(Fragment$1.from(node8));
  }
  return {
    start: node8.resolveNoCache(slice11.openStart + extra),
    end: node8.resolveNoCache(node8.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos$1 = function ResolvedPos4(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$1 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos$1.prototype.resolveDepth = function resolveDepth4(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$1.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$1.doc.get = function() {
  return this.node(0);
};
ResolvedPos$1.prototype.node = function node6(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos$1.prototype.index = function index4(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos$1.prototype.indexAfter = function indexAfter4(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos$1.prototype.start = function start6(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos$1.prototype.end = function end5(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos$1.prototype.before = function before4(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos$1.prototype.after = function after4(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$1.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$1.nodeAfter.get = function() {
  var parent = this.parent, index6 = this.index(this.depth);
  if (index6 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child11 = parent.child(index6);
  return dOff ? parent.child(index6).cut(dOff) : child11;
};
prototypeAccessors$2$1.nodeBefore.get = function() {
  var index6 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index6).cut(0, dOff);
  }
  return index6 == 0 ? null : this.parent.child(index6 - 1);
};
ResolvedPos$1.prototype.posAtIndex = function posAtIndex4(index6, depth) {
  depth = this.resolveDepth(depth);
  var node8 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index6; i++) {
    pos += node8.child(i).nodeSize;
  }
  return pos;
};
ResolvedPos$1.prototype.marks = function marks4() {
  var parent = this.parent, index6 = this.index();
  if (parent.content.size == 0) {
    return Mark$1.none;
  }
  if (this.textOffset) {
    return parent.child(index6).marks;
  }
  var main2 = parent.maybeChild(index6 - 1), other = parent.maybeChild(index6);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks6 = main2.marks;
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!other || !marks6[i].isInSet(other.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$1.prototype.marksAcross = function marksAcross4($end) {
  var after6 = this.parent.maybeChild(this.index());
  if (!after6 || !after6.isInline) {
    return null;
  }
  var marks6 = after6.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!next || !marks6[i].isInSet(next.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos$1.prototype.sharedDepth = function sharedDepth4(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos$1.prototype.blockRange = function blockRange4(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
      return new NodeRange$1(this, other, d);
    }
  }
};
ResolvedPos$1.prototype.sameParent = function sameParent4(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos$1.prototype.max = function max5(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos$1.prototype.min = function min5(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos$1.prototype.toString = function toString22() {
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos$1.resolve = function resolve13(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start8 = 0, parentOffset = pos;
  for (var node8 = doc2; ; ) {
    var ref2 = node8.content.findIndex(parentOffset);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    var rem = parentOffset - offset6;
    path.push(node8, index6, start8 + offset6);
    if (!rem) {
      break;
    }
    node8 = node8.child(index6);
    if (node8.isText) {
      break;
    }
    parentOffset = rem - 1;
    start8 += offset6 + 1;
  }
  return new ResolvedPos$1(pos, path, parentOffset);
};
ResolvedPos$1.resolveCached = function resolveCached4(doc2, pos) {
  for (var i = 0; i < resolveCache$1.length; i++) {
    var cached = resolveCache$1[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache$1[resolveCachePos$1] = ResolvedPos$1.resolve(doc2, pos);
  resolveCachePos$1 = (resolveCachePos$1 + 1) % resolveCacheSize$1;
  return result2;
};
Object.defineProperties(ResolvedPos$1.prototype, prototypeAccessors$2$1);
var resolveCache$1 = [], resolveCachePos$1 = 0, resolveCacheSize$1 = 12;
var NodeRange$1 = function NodeRange4($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange$1.prototype, prototypeAccessors$1$1$1);
var emptyAttrs$1 = /* @__PURE__ */ Object.create(null);
var Node$1 = function Node4(type4, attrs, content4, marks6) {
  this.type = type4;
  this.attrs = attrs;
  this.content = content4 || Fragment$1.empty;
  this.marks = marks6 || Mark$1.none;
};
var prototypeAccessors$3$1 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$1.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$1.childCount.get = function() {
  return this.content.childCount;
};
Node$1.prototype.child = function child8(index6) {
  return this.content.child(index6);
};
Node$1.prototype.maybeChild = function maybeChild8(index6) {
  return this.content.maybeChild(index6);
};
Node$1.prototype.forEach = function forEach12(f) {
  this.content.forEach(f);
};
Node$1.prototype.nodesBetween = function nodesBetween8(from8, to, f, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from8, to, f, startPos, this);
};
Node$1.prototype.descendants = function descendants8(f) {
  this.nodesBetween(0, this.content.size, f);
};
prototypeAccessors$3$1.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node$1.prototype.textBetween = function textBetween8(from8, to, blockSeparator, leafText) {
  return this.content.textBetween(from8, to, blockSeparator, leafText);
};
prototypeAccessors$3$1.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$1.lastChild.get = function() {
  return this.content.lastChild;
};
Node$1.prototype.eq = function eq24(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node$1.prototype.sameMarkup = function sameMarkup4(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node$1.prototype.hasMarkup = function hasMarkup4(type4, attrs, marks6) {
  return this.type == type4 && compareDeep$1(this.attrs, attrs || type4.defaultAttrs || emptyAttrs$1) && Mark$1.sameSet(this.marks, marks6 || Mark$1.none);
};
Node$1.prototype.copy = function copy8(content4) {
  if (content4 === void 0)
    content4 = null;
  if (content4 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content4, this.marks);
};
Node$1.prototype.mark = function mark5(marks6) {
  return marks6 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks6);
};
Node$1.prototype.cut = function cut8(from8, to) {
  if (from8 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from8, to));
};
Node$1.prototype.slice = function slice7(from8, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from8 == to) {
    return Slice$1.empty;
  }
  var $from = this.resolve(from8), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start8 = $from.start(depth), node8 = $from.node(depth);
  var content4 = node8.content.cut($from.pos - start8, $to.pos - start8);
  return new Slice$1(content4, $from.depth - depth, $to.depth - depth);
};
Node$1.prototype.replace = function replace$1$1(from8, to, slice11) {
  return replace$14(this.resolve(from8), this.resolve(to), slice11);
};
Node$1.prototype.nodeAt = function nodeAt4(pos) {
  for (var node8 = this; ; ) {
    var ref2 = node8.content.findIndex(pos);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    node8 = node8.maybeChild(index6);
    if (!node8) {
      return null;
    }
    if (offset6 == pos || node8.isText) {
      return node8;
    }
    pos -= offset6 + 1;
  }
};
Node$1.prototype.childAfter = function childAfter4(pos) {
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  return { node: this.content.maybeChild(index6), index: index6, offset: offset6 };
};
Node$1.prototype.childBefore = function childBefore4(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  if (offset6 < pos) {
    return { node: this.content.child(index6), index: index6, offset: offset6 };
  }
  var node8 = this.content.child(index6 - 1);
  return { node: node8, index: index6 - 1, offset: offset6 - node8.nodeSize };
};
Node$1.prototype.resolve = function resolve14(pos) {
  return ResolvedPos$1.resolveCached(this, pos);
};
Node$1.prototype.resolveNoCache = function resolveNoCache4(pos) {
  return ResolvedPos$1.resolve(this, pos);
};
Node$1.prototype.rangeHasMark = function rangeHasMark4(from8, to, type4) {
  var found2 = false;
  if (to > from8) {
    this.nodesBetween(from8, to, function(node8) {
      if (type4.isInSet(node8.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$1.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$1.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$1.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$1.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$1.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$1.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$1.isAtom.get = function() {
  return this.type.isAtom;
};
Node$1.prototype.toString = function toString23() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks$1(this.marks, name);
};
Node$1.prototype.contentMatchAt = function contentMatchAt4(index6) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index6);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node$1.prototype.canReplace = function canReplace4(from8, to, replacement, start8, end7) {
  if (replacement === void 0)
    replacement = Fragment$1.empty;
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = replacement.childCount;
  var one = this.contentMatchAt(from8).matchFragment(replacement, start8, end7);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start8; i < end7; i++) {
    if (!this.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node$1.prototype.canReplaceWith = function canReplaceWith4(from8, to, type4, marks6) {
  if (marks6 && !this.type.allowsMarks(marks6)) {
    return false;
  }
  var start8 = this.contentMatchAt(from8).matchType(type4);
  var end7 = start8 && start8.matchFragment(this.content, to);
  return end7 ? end7.validEnd : false;
};
Node$1.prototype.canAppend = function canAppend4(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node$1.prototype.check = function check4() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy12 = Mark$1.none;
  for (var i = 0; i < this.marks.length; i++) {
    copy12 = this.marks[i].addToSet(copy12);
  }
  if (!Mark$1.sameSet(copy12, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
      return m.type.name;
    }));
  }
  this.content.forEach(function(node8) {
    return node8.check();
  });
};
Node$1.prototype.toJSON = function toJSON21() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n) {
      return n.toJSON();
    });
  }
  return obj;
};
Node$1.fromJSON = function fromJSON23(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks6 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks6 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks6);
  }
  var content4 = Fragment$1.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content4, marks6);
};
Object.defineProperties(Node$1.prototype, prototypeAccessors$3$1);
function wrapMarks$1(marks6, str) {
  for (var i = marks6.length - 1; i >= 0; i--) {
    str = marks6[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch$1 = function ContentMatch4(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$1 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch$1.parse = function parse5(string3, nodeTypes) {
  var stream = new TokenStream$1(string3, nodeTypes);
  if (stream.next == null) {
    return ContentMatch$1.empty;
  }
  var expr = parseExpr$1(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa$1(nfa$1(expr));
  checkForDeadEnds$1(match, stream);
  return match;
};
ContentMatch$1.prototype.matchType = function matchType4(type4) {
  for (var i = 0; i < this.next.length; i += 2) {
    if (this.next[i] == type4) {
      return this.next[i + 1];
    }
  }
  return null;
};
ContentMatch$1.prototype.matchFragment = function matchFragment4(frag, start8, end7) {
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = frag.childCount;
  var cur = this;
  for (var i = start8; cur && i < end7; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$4$1.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4$1.defaultType.get = function() {
  for (var i = 0; i < this.next.length; i += 2) {
    var type4 = this.next[i];
    if (!(type4.isText || type4.hasRequiredAttrs())) {
      return type4;
    }
  }
};
ContentMatch$1.prototype.compatible = function compatible4(other) {
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch$1.prototype.fillBefore = function fillBefore4(after6, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match, types2) {
    var finished = match.matchFragment(after6, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment$1.from(types2.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i], next = match.next[i + 1];
      if (!(type4.isText || type4.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types2.concat(type4));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch$1.prototype.findWrapping = function findWrapping8(target) {
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this.wrapCache[i] == target) {
      return this.wrapCache[i + 1];
    }
  }
  var computed2 = this.computeWrapping(target);
  this.wrapCache.push(target, computed2);
  return computed2;
};
ContentMatch$1.prototype.computeWrapping = function computeWrapping4(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i];
      if (!type4.isLeaf && !type4.hasRequiredAttrs() && !(type4.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({ match: type4.contentMatch, type: type4, via: current });
        seen[type4.name] = true;
      }
    }
  }
};
prototypeAccessors$4$1.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch$1.prototype.edge = function edge4(n) {
  var i = n << 1;
  if (i >= this.next.length) {
    throw new RangeError("There's no " + n + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch$1.prototype.toString = function toString24() {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2) {
      if (seen.indexOf(m.next[i]) == -1) {
        scan(m.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch$1.prototype, prototypeAccessors$4$1);
ContentMatch$1.empty = new ContentMatch$1(true);
var TokenStream$1 = function TokenStream4(string3, nodeTypes) {
  this.string = string3;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string3.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$1 = { next: { configurable: true } };
prototypeAccessors$1$2$1.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream$1.prototype.eat = function eat4(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream$1.prototype.err = function err4(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream$1.prototype, prototypeAccessors$1$2$1);
function parseExpr$1(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq$1(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq$1(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript$1(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript$1(stream) {
  var expr = parseExprAtom$1(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange$1(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum$1(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange$1(stream, expr) {
  var min7 = parseNum$1(stream), max7 = min7;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max7 = parseNum$1(stream);
    } else {
      max7 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min7, max: max7, expr };
}
function resolveName$1(stream, name) {
  var types2 = stream.nodeTypes, type4 = types2[name];
  if (type4) {
    return [type4];
  }
  var result2 = [];
  for (var typeName in types2) {
    var type$12 = types2[typeName];
    if (type$12.groups.indexOf(name) > -1) {
      result2.push(type$12);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom$1(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr$1(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName$1(stream, stream.next).map(function(type4) {
      if (stream.inline == null) {
        stream.inline = type4.isInline;
      } else if (stream.inline != type4.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type4 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa$1(expr) {
  var nfa2 = [[]];
  connect(compile11(expr, 0), node8());
  return nfa2;
  function node8() {
    return nfa2.push([]) - 1;
  }
  function edge6(from8, to, term) {
    var edge7 = { term, to };
    nfa2[from8].push(edge7);
    return edge7;
  }
  function connect(edges, to) {
    edges.forEach(function(edge7) {
      return edge7.to = to;
    });
  }
  function compile11(expr2, from8) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile11(expr3, from8));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile11(expr2.exprs[i], from8);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from8 = node8());
      }
    } else if (expr2.type == "star") {
      var loop = node8();
      edge6(from8, loop);
      connect(compile11(expr2.expr, loop), loop);
      return [edge6(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node8();
      connect(compile11(expr2.expr, from8), loop$1);
      connect(compile11(expr2.expr, loop$1), loop$1);
      return [edge6(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge6(from8)].concat(compile11(expr2.expr, from8));
    } else if (expr2.type == "range") {
      var cur = from8;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node8();
        connect(compile11(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile11(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node8();
          edge6(cur, next$2);
          connect(compile11(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge6(cur)];
    } else if (expr2.type == "name") {
      return [edge6(from8, null, expr2.value)];
    }
  }
}
function cmp$1(a, b) {
  return b - a;
}
function nullFrom$1(nfa2, node8) {
  var result2 = [];
  scan(node8);
  return result2.sort(cmp$1);
  function scan(node9) {
    var edges = nfa2[node9];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node9);
    for (var i = 0; i < edges.length; i++) {
      var ref2 = edges[i];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa$1(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom$1(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node8) {
      nfa2[node8].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom$1(nfa2, to).forEach(function(node9) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node9) == -1) {
            set3.push(node9);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch$1(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp$1);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds$1(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node8 = state.next[j], next = state.next[j + 1];
      nodes.push(node8.name);
      if (dead && !(node8.isText || node8.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs$1(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs$14(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs$1(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute$1(attrs[name]);
    }
  }
  return result2;
}
var NodeType$2 = function NodeType5(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs$1(spec.attrs);
  this.defaultAttrs = defaultAttrs$1(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$1 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5$1.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$1.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$1.isLeaf.get = function() {
  return this.contentMatch == ContentMatch$1.empty;
};
prototypeAccessors$5$1.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5$1.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType$2.prototype.hasRequiredAttrs = function hasRequiredAttrs4() {
  for (var n in this.attrs) {
    if (this.attrs[n].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$2.prototype.compatibleContent = function compatibleContent4(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$2.prototype.computeAttrs = function computeAttrs$1$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs$14(this.attrs, attrs);
  }
};
NodeType$2.prototype.create = function create10(attrs, content4, marks6) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node$1(this, this.computeAttrs(attrs), Fragment$1.from(content4), Mark$1.setFrom(marks6));
};
NodeType$2.prototype.createChecked = function createChecked4(attrs, content4, marks6) {
  content4 = Fragment$1.from(content4);
  if (!this.validContent(content4)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node$1(this, this.computeAttrs(attrs), content4, Mark$1.setFrom(marks6));
};
NodeType$2.prototype.createAndFill = function createAndFill4(attrs, content4, marks6) {
  attrs = this.computeAttrs(attrs);
  content4 = Fragment$1.from(content4);
  if (content4.size) {
    var before6 = this.contentMatch.fillBefore(content4);
    if (!before6) {
      return null;
    }
    content4 = before6.append(content4);
  }
  var after6 = this.contentMatch.matchFragment(content4).fillBefore(Fragment$1.empty, true);
  if (!after6) {
    return null;
  }
  return new Node$1(this, attrs, content4.append(after6), Mark$1.setFrom(marks6));
};
NodeType$2.prototype.validContent = function validContent4(content4) {
  var result2 = this.contentMatch.matchFragment(content4);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content4.childCount; i++) {
    if (!this.allowsMarks(content4.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowsMarkType = function allowsMarkType4(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$2.prototype.allowsMarks = function allowsMarks4(marks6) {
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowedMarks = function allowedMarks4(marks6) {
  if (this.markSet == null) {
    return marks6;
  }
  var copy12;
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      if (!copy12) {
        copy12 = marks6.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks6[i]);
    }
  }
  return !copy12 ? marks6 : copy12.length ? copy12 : Mark$1.empty;
};
NodeType$2.compile = function compile7(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType$2(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$2.prototype, prototypeAccessors$5$1);
var Attribute$1 = function Attribute4(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$1 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$1.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute$1.prototype, prototypeAccessors$1$3$1);
var MarkType$1 = function MarkType4(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs$1(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs$1(this.attrs);
  this.instance = defaults2 && new Mark$1(this, defaults2);
};
MarkType$1.prototype.create = function create11(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark$1(this, computeAttrs$14(this.attrs, attrs));
};
MarkType$1.compile = function compile8(marks6, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks6.forEach(function(name, spec) {
    return result2[name] = new MarkType$1(name, rank++, schema, spec);
  });
  return result2;
};
MarkType$1.prototype.removeFromSet = function removeFromSet8(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      set3 = set3.slice(0, i).concat(set3.slice(i + 1));
      i--;
    }
  }
  return set3;
};
MarkType$1.prototype.isInSet = function isInSet8(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      return set3[i];
    }
  }
};
MarkType$1.prototype.excludes = function excludes4(other) {
  return this.excluded.indexOf(other) > -1;
};
var DOMParser2 = function DOMParser3(schema, rules2) {
  var this$1$1 = this;
  this.schema = schema;
  this.rules = rules2;
  this.tags = [];
  this.styles = [];
  rules2.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
  this.normalizeLists = !this.tags.some(function(r) {
    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
      return false;
    }
    var node8 = schema.nodes[r.node];
    return node8.contentMatch.matchType(node8);
  });
};
DOMParser2.prototype.parse = function parse6(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$1(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser2.prototype.parseSlice = function parseSlice2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext$1(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice$1.maxOpen(context.finish());
};
DOMParser2.prototype.matchTag = function matchTag2(dom, context, after6) {
  for (var i = after6 ? this.tags.indexOf(after6) + 1 : 0; i < this.tags.length; i++) {
    var rule = this.tags[i];
    if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser2.prototype.matchStyle = function matchStyle2(prop, value, context, after6) {
  for (var i = after6 ? this.styles.indexOf(after6) + 1 : 0; i < this.styles.length; i++) {
    var rule = this.styles[i];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser2.schemaRules = function schemaRules2(schema) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result2.length; i++) {
      var next = result2[i], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i, 0, rule);
  }
  var loop = function(name2) {
    var rules2 = schema.marks[name2].spec.parseDOM;
    if (rules2) {
      rules2.forEach(function(rule) {
        insert(rule = copy9(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema.marks)
    loop(name);
  var loop$1 = function(name2) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy9(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema.nodes)
    loop$1();
  return result2;
};
DOMParser2.fromSchema = function fromSchema3(schema) {
  return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
};
var blockTags$1 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags$1 = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags$1 = { ol: true, ul: true };
var OPT_PRESERVE_WS$1 = 1, OPT_PRESERVE_WS_FULL$1 = 2, OPT_OPEN_LEFT$1 = 4;
function wsOptionsFor$1(type4, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS$1 : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL$1 : 0);
  }
  return type4 && type4.whitespace == "pre" ? OPT_PRESERVE_WS$1 | OPT_PRESERVE_WS_FULL$1 : base2 & ~OPT_OPEN_LEFT$1;
}
var NodeContext$1 = function NodeContext4(type4, attrs, marks6, pendingMarks, solid, match, options) {
  this.type = type4;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT$1 ? null : type4.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks6;
  this.activeMarks = Mark$1.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext$1.prototype.findWrapping = function findWrapping9(node8) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment$1.from(node8));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start8 = this.type.contentMatch, wrap2;
      if (wrap2 = start8.findWrapping(node8.type)) {
        this.match = start8;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node8.type);
};
NodeContext$1.prototype.finish = function finish7(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS$1)) {
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
  }
  var content4 = Fragment$1.from(this.content);
  if (!openEnd && this.match) {
    content4 = content4.append(this.match.fillBefore(Fragment$1.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content4, this.marks) : content4;
};
NodeContext$1.prototype.popFromStashMark = function popFromStashMark4(mark7) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--) {
    if (mark7.eq(this.stashMarks[i])) {
      return this.stashMarks.splice(i, 1)[0];
    }
  }
};
NodeContext$1.prototype.applyPending = function applyPending4(nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark7 = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark7.type) : markMayApply$1(mark7.type, nextType)) && !mark7.isInSet(this.activeMarks)) {
      this.activeMarks = mark7.addToSet(this.activeMarks);
      this.pendingMarks = mark7.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext$1.prototype.inlineContext = function inlineContext4(node8) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node8.parentNode && !blockTags$1.hasOwnProperty(node8.parentNode.nodeName.toLowerCase());
};
var ParseContext$1 = function ParseContext4(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor$1(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT$1 : 0);
  if (topNode) {
    topContext = new NodeContext$1(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext$1(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
  } else {
    topContext = new NodeContext$1(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$1 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6$1.top.get = function() {
  return this.nodes[this.open];
};
ParseContext$1.prototype.addDOM = function addDOM4(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks6 = style2 ? this.readStyles(parseStyles$1(style2)) : null, top2 = this.top;
    if (marks6 != null) {
      for (var i = 0; i < marks6.length; i++) {
        this.addPendingMark(marks6[i]);
      }
    }
    this.addElement(dom);
    if (marks6 != null) {
      for (var i$1 = 0; i$1 < marks6.length; i$1++) {
        this.removePendingMark(marks6[i$1], top2);
      }
    }
  }
};
ParseContext$1.prototype.addTextNode = function addTextNode4(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL$1 || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS$1)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL$1)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext$1.prototype.addElement = function addElement4(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags$1.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList$1(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags$1.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync6, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags$1.hasOwnProperty(name)) {
      sync6 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync6) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext$1.prototype.leafFallback = function leafFallback4(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext$1.prototype.ignoreFallback = function ignoreFallback4(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext$1.prototype.readStyles = function readStyles4(styles) {
  var marks6 = Mark$1.none;
  style:
    for (var i = 0; i < styles.length; i += 2) {
      for (var after6 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after6);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks6 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks6);
        if (rule.consuming === false) {
          after6 = rule;
        } else {
          break;
        }
      }
    }
  return marks6;
};
ParseContext$1.prototype.addElementByRule = function addElementByRule4(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync6, nodeType2, markType, mark7;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync6 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark7 = markType.create(rule.attrs);
    this.addPendingMark(mark7);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node8) {
      return this$1$1.insertNode(node8);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync6);
  }
  if (sync6) {
    this.sync(startIn);
    this.open--;
  }
  if (mark7) {
    this.removePendingMark(mark7, startIn);
  }
};
ParseContext$1.prototype.addAll = function addAll4(parent, sync6, startIndex2, endIndex2) {
  var index6 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end7 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end7; dom = dom.nextSibling, ++index6) {
    this.findAtPoint(parent, index6);
    this.addDOM(dom);
    if (sync6 && blockTags$1.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync6);
    }
  }
  this.findAtPoint(parent, index6);
};
ParseContext$1.prototype.findPlace = function findPlace4(node8) {
  var route, sync6;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node8);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync6 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync6);
  for (var i = 0; i < route.length; i++) {
    this.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext$1.prototype.insertNode = function insertNode4(node8) {
  if (node8.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node8)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node8.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node8.type);
    }
    var marks6 = top2.activeMarks;
    for (var i = 0; i < node8.marks.length; i++) {
      if (!top2.type || top2.type.allowsMarkType(node8.marks[i].type)) {
        marks6 = node8.marks[i].addToSet(marks6);
      }
    }
    top2.content.push(node8.mark(marks6));
    return true;
  }
  return false;
};
ParseContext$1.prototype.enter = function enter5(type4, attrs, preserveWS) {
  var ok5 = this.findPlace(type4.create(attrs));
  if (ok5) {
    this.enterInner(type4, attrs, true, preserveWS);
  }
  return ok5;
};
ParseContext$1.prototype.enterInner = function enterInner4(type4, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type4);
  top2.match = top2.match && top2.match.matchType(type4, attrs);
  var options = wsOptionsFor$1(type4, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT$1 && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT$1;
  }
  this.nodes.push(new NodeContext$1(type4, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext$1.prototype.closeExtra = function closeExtra4(openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext$1.prototype.finish = function finish8() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext$1.prototype.sync = function sync4(to) {
  for (var i = this.open; i >= 0; i--) {
    if (this.nodes[i] == to) {
      this.open = i;
      return;
    }
  }
};
prototypeAccessors$6$1.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content4 = this.nodes[i].content;
    for (var j = content4.length - 1; j >= 0; j--) {
      pos += content4[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext$1.prototype.findAtPoint = function findAtPoint4(parent, offset6) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset6) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$1.prototype.findInside = function findInside4(parent) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext$1.prototype.findAround = function findAround4(parent, content4, before6) {
  if (parent != content4 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        var pos = content4.compareDocumentPosition(this.find[i].node);
        if (pos & (before6 ? 2 : 4)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext$1.prototype.findInText = function findInText4(textNode) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode) {
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }
};
ParseContext$1.prototype.matchesContext = function matchesContext4(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext$1.prototype.textblockFromContext = function textblockFromContext4() {
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type4 = this.parser.schema.nodes[name];
    if (type4.isTextblock && type4.defaultAttrs) {
      return type4;
    }
  }
};
ParseContext$1.prototype.addPendingMark = function addPendingMark4(mark7) {
  var found2 = findSameMarkInSet$1(mark7, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark7.addToSet(this.top.pendingMarks);
};
ParseContext$1.prototype.removePendingMark = function removePendingMark4(mark7, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark7);
    if (found2 > -1) {
      level.pendingMarks = mark7.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark7.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark7);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext$1.prototype, prototypeAccessors$6$1);
function normalizeList$1(dom) {
  for (var child11 = dom.firstChild, prevItem = null; child11; child11 = child11.nextSibling) {
    var name = child11.nodeType == 1 ? child11.nodeName.toLowerCase() : null;
    if (name && listTags$1.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child11);
      child11 = prevItem;
    } else if (name == "li") {
      prevItem = child11;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles$1(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style2)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function copy9(obj) {
  var copy12 = {};
  for (var prop in obj) {
    copy12[prop] = obj[prop];
  }
  return copy12;
}
function markMayApply$1(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref2 = match.edge(i);
        var type4 = ref2.type;
        var next = ref2.next;
        if (type4 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet$1(mark7, set3) {
  for (var i = 0; i < set3.length; i++) {
    if (mark7.eq(set3[i])) {
      return set3[i];
    }
  }
}
var DOMSerializer2 = function DOMSerializer3(nodes, marks6) {
  this.nodes = nodes || {};
  this.marks = marks6 || {};
};
DOMSerializer2.prototype.serializeFragment = function serializeFragment2(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$1(options).createDocumentFragment();
  }
  var top2 = target, active = null;
  fragment.forEach(function(node8) {
    if (active || node8.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node8.marks.length) {
        var next = node8.marks[rendered];
        if (!this$1$1.marks[next.type.name]) {
          rendered++;
          continue;
        }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top2 = active.pop();
        active.pop();
      }
      while (rendered < node8.marks.length) {
        var add2 = node8.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add2, node8.isInline, options);
        if (markDOM) {
          active.push(add2, top2);
          top2.appendChild(markDOM.dom);
          top2 = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top2.appendChild(this$1$1.serializeNodeInner(node8, options));
  });
  return target;
};
DOMSerializer2.prototype.serializeNodeInner = function serializeNodeInner2(node8, options) {
  if (options === void 0)
    options = {};
  var ref2 = DOMSerializer2.renderSpec(doc$1(options), this.nodes[node8.type.name](node8));
  var dom = ref2.dom;
  var contentDOM = ref2.contentDOM;
  if (contentDOM) {
    if (node8.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node8, contentDOM, options);
    } else {
      this.serializeFragment(node8.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer2.prototype.serializeNode = function serializeNode2(node8, options) {
  if (options === void 0)
    options = {};
  var dom = this.serializeNodeInner(node8, options);
  for (var i = node8.marks.length - 1; i >= 0; i--) {
    var wrap2 = this.serializeMark(node8.marks[i], node8.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer2.prototype.serializeMark = function serializeMark2(mark7, inline2, options) {
  if (options === void 0)
    options = {};
  var toDOM = this.marks[mark7.type.name];
  return toDOM && DOMSerializer2.renderSpec(doc$1(options), toDOM(mark7, inline2));
};
DOMSerializer2.renderSpec = function renderSpec2(doc2, structure, xmlNS) {
  if (xmlNS === void 0)
    xmlNS = null;
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  if (structure.dom && structure.dom.nodeType != null) {
    return structure;
  }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  var attrs = structure[1], start8 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start8 = 2;
    for (var name in attrs) {
      if (attrs[name] != null) {
        var space$1 = name.indexOf(" ");
        if (space$1 > 0) {
          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
        } else {
          dom.setAttribute(name, attrs[name]);
        }
      }
    }
  }
  for (var i = start8; i < structure.length; i++) {
    var child11 = structure[i];
    if (child11 === 0) {
      if (i < structure.length - 1 || i > start8) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref2 = DOMSerializer2.renderSpec(doc2, child11, xmlNS);
      var inner = ref2.dom;
      var innerContent = ref2.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer2.fromSchema = function fromSchema4(schema) {
  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer2(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
};
DOMSerializer2.nodesFromSchema = function nodesFromSchema2(schema) {
  var result2 = gatherToDOM(schema.nodes);
  if (!result2.text) {
    result2.text = function(node8) {
      return node8.text;
    };
  }
  return result2;
};
DOMSerializer2.marksFromSchema = function marksFromSchema2(schema) {
  return gatherToDOM(schema.marks);
};
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc$1(options) {
  return options.document || window.document;
}
var lower16$1 = 65535;
var factor16$1 = Math.pow(2, 16);
function makeRecover$1(index6, offset6) {
  return index6 + offset6 * factor16$1;
}
function recoverIndex$1(value) {
  return value & lower16$1;
}
function recoverOffset$1(value) {
  return (value - (value & lower16$1)) / factor16$1;
}
var MapResult$1 = function MapResult4(pos, deleted, recover5) {
  if (deleted === void 0)
    deleted = false;
  if (recover5 === void 0)
    recover5 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover5;
};
var StepMap$1 = function StepMap4(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap$1.prototype.recover = function recover4(value) {
  var diff = 0, index6 = recoverIndex$1(value);
  if (!this.inverted) {
    for (var i = 0; i < index6; i++) {
      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    }
  }
  return this.ranges[index6 * 3] + diff + recoverOffset$1(value);
};
StepMap$1.prototype.mapResult = function mapResult7(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap$1.prototype.map = function map22(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap$1.prototype._map = function _map7(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end7 = start8 + oldSize;
    if (pos <= end7) {
      var side = !oldSize ? assoc : pos == start8 ? -1 : pos == end7 ? 1 : assoc;
      var result2 = start8 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover5 = pos == (assoc < 0 ? start8 : end7) ? null : makeRecover$1(i / 3, pos - start8);
      return new MapResult$1(result2, assoc < 0 ? pos != start8 : pos != end7, recover5);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult$1(pos + diff);
};
StepMap$1.prototype.touches = function touches4(pos, recover5) {
  var diff = 0, index6 = recoverIndex$1(recover5);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i] - (this.inverted ? diff : 0);
    if (start8 > pos) {
      break;
    }
    var oldSize = this.ranges[i + oldIndex], end7 = start8 + oldSize;
    if (pos <= end7 && i == index6 * 3) {
      return true;
    }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false;
};
StepMap$1.prototype.forEach = function forEach13(f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start8 = this.ranges[i], oldStart = start8 - (this.inverted ? diff : 0), newStart = start8 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap$1.prototype.invert = function invert10() {
  return new StepMap$1(this.ranges, !this.inverted);
};
StepMap$1.prototype.toString = function toString25() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap$1.offset = function offset5(n) {
  return n == 0 ? StepMap$1.empty : new StepMap$1(n < 0 ? [0, -n, 0] : [0, 0, n]);
};
StepMap$1.empty = new StepMap$1([]);
var Mapping$1 = function Mapping4(maps, mirror, from8, to) {
  this.maps = maps || [];
  this.from = from8 || 0;
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};
Mapping$1.prototype.slice = function slice8(from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.maps.length;
  return new Mapping$1(this.maps, this.mirror, from8, to);
};
Mapping$1.prototype.copy = function copy10() {
  return new Mapping$1(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping$1.prototype.appendMap = function appendMap4(map30, mirrors) {
  this.to = this.maps.push(map30);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping$1.prototype.appendMapping = function appendMapping4(mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};
Mapping$1.prototype.getMirror = function getMirror4(n) {
  if (this.mirror) {
    for (var i = 0; i < this.mirror.length; i++) {
      if (this.mirror[i] == n) {
        return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping$1.prototype.setMirror = function setMirror4(n, m) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n, m);
};
Mapping$1.prototype.appendMappingInverted = function appendMappingInverted4(mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};
Mapping$1.prototype.invert = function invert11() {
  var inverse = new Mapping$1();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping$1.prototype.map = function map23(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i = this.from; i < this.to; i++) {
    pos = this.maps[i].map(pos, assoc);
  }
  return pos;
};
Mapping$1.prototype.mapResult = function mapResult8(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping$1.prototype._map = function _map8(pos, assoc, simple) {
  var deleted = false;
  for (var i = this.from; i < this.to; i++) {
    var map30 = this.maps[i], result2 = map30.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult$1(pos, deleted);
};
function TransformError$1(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = TransformError$1.prototype;
  return err6;
}
TransformError$1.prototype = Object.create(Error.prototype);
TransformError$1.prototype.constructor = TransformError$1;
TransformError$1.prototype.name = "TransformError";
var Transform$1 = function Transform4(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping$1();
};
var prototypeAccessors$8 = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$8.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform$1.prototype.step = function step4(object4) {
  var result2 = this.maybeStep(object4);
  if (result2.failed) {
    throw new TransformError$1(result2.failed);
  }
  return this;
};
Transform$1.prototype.maybeStep = function maybeStep4(step5) {
  var result2 = step5.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step5, result2.doc);
  }
  return result2;
};
prototypeAccessors$8.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform$1.prototype.addStep = function addStep4(step5, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step5);
  this.mapping.appendMap(step5.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform$1.prototype, prototypeAccessors$8);
function mustOverride() {
  throw new Error("Override me");
}
var stepsByID$1 = /* @__PURE__ */ Object.create(null);
var Step$1 = function Step4() {
};
Step$1.prototype.apply = function apply14(_doc) {
  return mustOverride();
};
Step$1.prototype.getMap = function getMap4() {
  return StepMap$1.empty;
};
Step$1.prototype.invert = function invert12(_doc) {
  return mustOverride();
};
Step$1.prototype.map = function map24(_mapping) {
  return mustOverride();
};
Step$1.prototype.merge = function merge4(_other) {
  return null;
};
Step$1.prototype.toJSON = function toJSON22() {
  return mustOverride();
};
Step$1.fromJSON = function fromJSON24(schema, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type4 = stepsByID$1[json.stepType];
  if (!type4) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type4.fromJSON(schema, json);
};
Step$1.jsonID = function jsonID6(id, stepClass) {
  if (id in stepsByID$1) {
    throw new RangeError("Duplicate use of step JSON ID " + id);
  }
  stepsByID$1[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass;
};
var StepResult$1 = function StepResult4(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult$1.ok = function ok4(doc2) {
  return new StepResult$1(doc2, null);
};
StepResult$1.fail = function fail4(message) {
  return new StepResult$1(null, message);
};
StepResult$1.fromReplace = function fromReplace4(doc2, from8, to, slice11) {
  try {
    return StepResult$1.ok(doc2.replace(from8, to, slice11));
  } catch (e) {
    if (e instanceof ReplaceError$1) {
      return StepResult$1.fail(e.message);
    }
    throw e;
  }
};
var ReplaceStep$1 = /* @__PURE__ */ function(Step6) {
  function ReplaceStep2(from8, to, slice11, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.slice = slice11;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceStep2.__proto__ = Step6;
  ReplaceStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && contentBetween$1(doc2, this.from, this.to)) {
      return StepResult$1.fail("Structure replace would overwrite content");
    }
    return StepResult$1.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap5() {
    return new StepMap$1([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert13(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted) {
      return null;
    }
    return new ReplaceStep2(from8.pos, Math.max(from8.pos, to.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge6(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice11 = this.slice.size + other.slice.size == 0 ? Slice$1.empty : new Slice$1(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice$1.empty : new Slice$1(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON28() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice$1.fromJSON(schema, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step$1);
Step$1.jsonID("replace", ReplaceStep$1);
var ReplaceAroundStep$1 = /* @__PURE__ */ function(Step6) {
  function ReplaceAroundStep2(from8, to, gapFrom, gapTo, slice11, insert, structure) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step6)
    ReplaceAroundStep2.__proto__ = Step6;
  ReplaceAroundStep2.prototype = Object.create(Step6 && Step6.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply22(doc2) {
    if (this.structure && (contentBetween$1(doc2, this.from, this.gapFrom) || contentBetween$1(doc2, this.gapTo, this.to))) {
      return StepResult$1.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult$1.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult$1.fail("Content does not fit in gap");
    }
    return StepResult$1.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap5() {
    return new StepMap$1([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert13(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from8.deleted && to.deleted || gapFrom < from8.pos || gapTo > to.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from8.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON28() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice$1.fromJSON(schema, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step$1);
Step$1.jsonID("replaceAround", ReplaceAroundStep$1);
function contentBetween$1(doc2, from8, to) {
  var $from = doc2.resolve(from8), dist = to - from8, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
Transform$1.prototype.lift = function(range3, target) {
  var $from = range3.$from;
  var $to = range3.$to;
  var depth = range3.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start8 = gapStart, end7 = gapEnd;
  var before6 = Fragment$1.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before6 = Fragment$1.from($from.node(d).copy(before6));
      openStart++;
    } else {
      start8--;
    }
  }
  var after6 = Fragment$1.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after6 = Fragment$1.from($to.node(d$1).copy(after6));
      openEnd++;
    } else {
      end7++;
    }
  }
  return this.step(new ReplaceAroundStep$1(start8, end7, gapStart, gapEnd, new Slice$1(before6.append(after6), openStart, openEnd), before6.size - openStart, true));
};
Transform$1.prototype.wrap = function(range3, wrappers) {
  var content4 = Fragment$1.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    content4 = Fragment$1.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  var start8 = range3.start, end7 = range3.end;
  return this.step(new ReplaceAroundStep$1(start8, end7, start8, end7, new Slice$1(content4, 0, 0), wrappers.length, true));
};
Transform$1.prototype.setBlockType = function(from8, to, type4, attrs) {
  var this$1$1 = this;
  if (to === void 0)
    to = from8;
  if (!type4.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isTextblock && !node8.hasMarkup(type4, attrs) && canChangeType$1(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type4)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type4);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node8.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep$1(startM, endM, startM + 1, endM - 1, new Slice$1(Fragment$1.from(type4.create(attrs, null, node8.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType$1(doc2, pos, type4) {
  var $pos = doc2.resolve(pos), index6 = $pos.index();
  return $pos.parent.canReplaceWith(index6, index6 + 1, type4);
}
Transform$1.prototype.setNodeMarkup = function(pos, type4, attrs, marks6) {
  var node8 = this.doc.nodeAt(pos);
  if (!node8) {
    throw new RangeError("No node at given position");
  }
  if (!type4) {
    type4 = node8.type;
  }
  var newNode = type4.create(attrs, null, marks6 || node8.marks);
  if (node8.isLeaf) {
    return this.replaceWith(pos, pos + node8.nodeSize, newNode);
  }
  if (!type4.validContent(node8.content)) {
    throw new RangeError("Invalid content for node type " + type4.name);
  }
  return this.step(new ReplaceAroundStep$1(pos, pos + node8.nodeSize, pos + 1, pos + node8.nodeSize - 1, new Slice$1(Fragment$1.from(newNode), 0, 0), 1, true));
};
Transform$1.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before6 = Fragment$1.empty, after6 = Fragment$1.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before6 = Fragment$1.from($pos.node(d).copy(before6));
    var typeAfter = typesAfter && typesAfter[i];
    after6 = Fragment$1.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after6) : $pos.node(d).copy(after6));
  }
  return this.step(new ReplaceStep$1(pos, pos, new Slice$1(before6.append(after6), depth, depth), true));
};
Transform$1.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step5 = new ReplaceStep$1(pos - depth, pos + depth, Slice$1.empty, true);
  return this.step(step5);
};
function insertPoint$1(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index6 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2)) {
        return $pos.before(d + 1);
      }
      if (index6 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice11) {
  var $pos = doc2.resolve(pos);
  if (!slice11.content.size) {
    return pos;
  }
  var content4 = slice11.content;
  for (var i = 0; i < slice11.openStart; i++) {
    content4 = content4.firstChild.content;
  }
  for (var pass = 1; pass <= (slice11.openStart == 0 && slice11.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content4);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content4.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
  }
  return null;
}
function mapFragment$1(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child11 = fragment.child(i);
    if (child11.content.size) {
      child11 = child11.copy(mapFragment$1(child11.content, f, child11));
    }
    if (child11.isInline) {
      child11 = f(child11, parent, i);
    }
    mapped.push(child11);
  }
  return Fragment$1.fromArray(mapped);
}
var AddMarkStep$1 = /* @__PURE__ */ function(Step6) {
  function AddMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    AddMarkStep2.__proto__ = Step6;
  AddMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice11 = new Slice$1(mapFragment$1(oldSlice.content, function(node8, parent2) {
      if (!node8.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node8;
      }
      return node8.mark(this$1$1.mark.addToSet(node8.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$1.fromReplace(doc2, this.from, this.to, slice11);
  };
  AddMarkStep2.prototype.invert = function invert13() {
    return new RemoveMarkStep$1(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new AddMarkStep2(from8.pos, to.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step$1);
Step$1.jsonID("addMark", AddMarkStep$1);
var RemoveMarkStep$1 = /* @__PURE__ */ function(Step6) {
  function RemoveMarkStep2(from8, to, mark7) {
    Step6.call(this);
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  if (Step6)
    RemoveMarkStep2.__proto__ = Step6;
  RemoveMarkStep2.prototype = Object.create(Step6 && Step6.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply22(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice11 = new Slice$1(mapFragment$1(oldSlice.content, function(node8) {
      return node8.mark(this$1$1.mark.removeFromSet(node8.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult$1.fromReplace(doc2, this.from, this.to, slice11);
  };
  RemoveMarkStep2.prototype.invert = function invert13() {
    return new AddMarkStep$1(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map30(mapping) {
    var from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos) {
      return null;
    }
    return new RemoveMarkStep2(from8.pos, to.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge6(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON28() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON31(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step$1);
Step$1.jsonID("removeMark", RemoveMarkStep$1);
Transform$1.prototype.addMark = function(from8, to, mark7) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from8, to, function(node8, pos, parent) {
    if (!node8.isInline) {
      return;
    }
    var marks6 = node8.marks;
    if (!mark7.isInSet(marks6) && parent.type.allowsMarkType(mark7.type)) {
      var start8 = Math.max(pos, from8), end7 = Math.min(pos + node8.nodeSize, to);
      var newSet = mark7.addToSet(marks6);
      for (var i = 0; i < marks6.length; i++) {
        if (!marks6[i].isInSet(newSet)) {
          if (removing && removing.to == start8 && removing.mark.eq(marks6[i])) {
            removing.to = end7;
          } else {
            removed.push(removing = new RemoveMarkStep$1(start8, end7, marks6[i]));
          }
        }
      }
      if (adding && adding.to == start8) {
        adding.to = end7;
      } else {
        added.push(adding = new AddMarkStep$1(start8, end7, mark7));
      }
    }
  });
  removed.forEach(function(s) {
    return this$1$1.step(s);
  });
  added.forEach(function(s) {
    return this$1$1.step(s);
  });
  return this;
};
Transform$1.prototype.removeMark = function(from8, to, mark7) {
  var this$1$1 = this;
  if (mark7 === void 0)
    mark7 = null;
  var matched = [], step5 = 0;
  this.doc.nodesBetween(from8, to, function(node8, pos) {
    if (!node8.isInline) {
      return;
    }
    step5++;
    var toRemove = null;
    if (mark7 instanceof MarkType$1) {
      var set3 = node8.marks, found2;
      while (found2 = mark7.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark7) {
      if (mark7.isInSet(node8.marks)) {
        toRemove = [mark7];
      }
    } else {
      toRemove = node8.marks;
    }
    if (toRemove && toRemove.length) {
      var end7 = Math.min(pos + node8.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style2 = toRemove[i], found$12 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step5 - 1 && style2.eq(matched[j].style)) {
            found$12 = m;
          }
        }
        if (found$12) {
          found$12.to = end7;
          found$12.step = step5;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from8), to: end7, step: step5 });
        }
      }
    }
  });
  matched.forEach(function(m) {
    return this$1$1.step(new RemoveMarkStep$1(m.from, m.to, m.style));
  });
  return this;
};
Transform$1.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node8 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node8.childCount; i++) {
    var child11 = node8.child(i), end7 = cur + child11.nodeSize;
    var allowed = match.matchType(child11.type, child11.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep$1(cur, end7, Slice$1.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child11.marks.length; j++) {
        if (!parentType.allowsMarkType(child11.marks[j].type)) {
          this.step(new RemoveMarkStep$1(cur, end7, child11.marks[j]));
        }
      }
    }
    cur = end7;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment$1.empty, true);
    this.replace(cur, cur, new Slice$1(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep$1(doc2, from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$1.empty;
  if (from8 == to && !slice11.size) {
    return null;
  }
  var $from = doc2.resolve(from8), $to = doc2.resolve(to);
  if (fitsTrivially$1($from, $to, slice11)) {
    return new ReplaceStep$1(from8, to, slice11);
  }
  return new Fitter$1($from, $to, slice11).fit();
}
Transform$1.prototype.replace = function(from8, to, slice11) {
  if (to === void 0)
    to = from8;
  if (slice11 === void 0)
    slice11 = Slice$1.empty;
  var step5 = replaceStep$1(this.doc, from8, to, slice11);
  if (step5) {
    this.step(step5);
  }
  return this;
};
Transform$1.prototype.replaceWith = function(from8, to, content4) {
  return this.replace(from8, to, new Slice$1(Fragment$1.from(content4), 0, 0));
};
Transform$1.prototype.delete = function(from8, to) {
  return this.replace(from8, to, Slice$1.empty);
};
Transform$1.prototype.insert = function(pos, content4) {
  return this.replaceWith(pos, pos, content4);
};
function fitsTrivially$1($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
var Fitter$1 = function Fitter4($from, $to, slice11) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice11;
  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node8 = $from.node(i);
    this.frontier.push({
      type: node8.type,
      match: node8.contentMatchAt($from.indexAfter(i))
    });
  }
  this.placed = Fragment$1.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment$1.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$5 = { depth: { configurable: true } };
prototypeAccessors$1$5.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter$1.prototype.fit = function fit4() {
  while (this.unplaced.size) {
    var fit5 = this.findFittable();
    if (fit5) {
      this.placeNodes(fit5);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content4 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content4.childCount == 1) {
    content4 = content4.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice11 = new Slice$1(content4, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep$1($from.pos, moveInline, this.$to.pos, this.$to.end(), slice11, placedSize);
  }
  if (slice11.size || $from.pos != this.$to.pos) {
    return new ReplaceStep$1($from.pos, $to.pos, slice11);
  }
};
Fitter$1.prototype.findFittable = function findFittable4() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt$1(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first2 = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref2 = this.frontier[frontierDepth];
        var type4 = ref2.type;
        var match = ref2.match;
        var wrap2 = void 0, inject2 = void 0;
        if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment$1.from(first2), false)) : type4.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject: inject2 };
        } else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type))) {
          return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter$1.prototype.openMore = function openMore4() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$1(content4, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice$1(content4, openStart + 1, Math.max(openEnd, inner.size + openStart >= content4.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter$1.prototype.dropNode = function dropNode4() {
  var ref2 = this.unplaced;
  var content4 = ref2.content;
  var openStart = ref2.openStart;
  var openEnd = ref2.openEnd;
  var inner = contentAt$1(content4, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content4.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice$1(dropFromFragment$1(content4, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice$1(dropFromFragment$1(content4, openStart, 1), openStart, openEnd);
  }
};
Fitter$1.prototype.placeNodes = function placeNodes4(ref2) {
  var sliceDepth = ref2.sliceDepth;
  var frontierDepth = ref2.frontierDepth;
  var parent = ref2.parent;
  var inject2 = ref2.inject;
  var wrap2 = ref2.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap2) {
    for (var i = 0; i < wrap2.length; i++) {
      this.openFrontierNode(wrap2[i]);
    }
  }
  var slice11 = this.unplaced, fragment = parent ? parent.content : slice11.content;
  var openStart = slice11.openStart - sliceDepth;
  var taken = 0, add2 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type4 = ref$1.type;
  if (inject2) {
    for (var i$1 = 0; i$1 < inject2.childCount; i$1++) {
      add2.push(inject2.child(i$1));
    }
    match = match.matchFragment(inject2);
  }
  var openEndCount = fragment.size + sliceDepth - (slice11.content.size - slice11.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add2.push(closeNodeStart$1(next.mark(type4.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment$1(this.placed, frontierDepth, Fragment$1.from(add2));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node8 = cur.lastChild;
    this.frontier.push({ type: node8.type, match: node8.contentMatchAt(node8.childCount) });
    cur = node8.content;
  }
  this.unplaced = !toEnd ? new Slice$1(dropFromFragment$1(slice11.content, sliceDepth, taken), slice11.openStart, slice11.openEnd) : sliceDepth == 0 ? Slice$1.empty : new Slice$1(dropFromFragment$1(slice11.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice11.openEnd : sliceDepth - 1);
};
Fitter$1.prototype.mustMoveInline = function mustMoveInline4() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits$1(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref2 = this.$to;
  var depth = ref2.depth;
  var after6 = this.$to.after(depth);
  while (depth > 1 && after6 == this.$to.end(--depth)) {
    ++after6;
  }
  return after6;
};
Fitter$1.prototype.findCloseLevel = function findCloseLevel4($to) {
  scan:
    for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      var ref2 = this.frontier[i];
      var match = ref2.match;
      var type4 = ref2.type;
      var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      var fit5 = contentAfterFits$1($to, i, type4, match, dropInner);
      if (!fit5) {
        continue;
      }
      for (var d = i - 1; d >= 0; d--) {
        var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$12 = ref$1.type;
        var matches2 = contentAfterFits$1($to, d, type$12, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i, fit: fit5, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
};
Fitter$1.prototype.close = function close4($to) {
  var close6 = this.findCloseLevel($to);
  if (!close6) {
    return null;
  }
  while (this.depth > close6.depth) {
    this.closeFrontierNode();
  }
  if (close6.fit.childCount) {
    this.placed = addToFragment$1(this.placed, close6.depth, close6.fit);
  }
  $to = close6.move;
  for (var d = close6.depth + 1; d <= $to.depth; d++) {
    var node8 = $to.node(d), add2 = node8.type.contentMatch.fillBefore(node8.content, true, $to.index(d));
    this.openFrontierNode(node8.type, node8.attrs, add2);
  }
  return $to;
};
Fitter$1.prototype.openFrontierNode = function openFrontierNode4(type4, attrs, content4) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type4);
  this.placed = addToFragment$1(this.placed, this.depth, Fragment$1.from(type4.create(attrs, content4)));
  this.frontier.push({ type: type4, match: type4.contentMatch });
};
Fitter$1.prototype.closeFrontierNode = function closeFrontierNode4() {
  var open = this.frontier.pop();
  var add2 = open.match.fillBefore(Fragment$1.empty, true);
  if (add2.childCount) {
    this.placed = addToFragment$1(this.placed, this.frontier.length, add2);
  }
};
Object.defineProperties(Fitter$1.prototype, prototypeAccessors$1$5);
function dropFromFragment$1(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment$1(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment$1(fragment, depth, content4) {
  if (depth == 0) {
    return fragment.append(content4);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment$1(fragment.lastChild.content, depth - 1, content4)));
}
function contentAt$1(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart$1(node8, openStart, openEnd) {
  if (openStart <= 0) {
    return node8;
  }
  var frag = node8.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart$1(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node8.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node8.type.contentMatch.matchFragment(frag).fillBefore(Fragment$1.empty, true));
    }
  }
  return node8.copy(frag);
}
function contentAfterFits$1($to, depth, type4, match, open) {
  var node8 = $to.node(depth), index6 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index6 == node8.childCount && !type4.compatibleContent(node8.type)) {
    return null;
  }
  var fit5 = match.fillBefore(node8.content, true, index6);
  return fit5 && !invalidMarks$1(type4, node8.content, index6) ? fit5 : null;
}
function invalidMarks$1(type4, fragment, start8) {
  for (var i = start8; i < fragment.childCount; i++) {
    if (!type4.allowsMarks(fragment.child(i).marks)) {
      return true;
    }
  }
  return false;
}
Transform$1.prototype.replaceRange = function(from8, to, slice11) {
  if (!slice11.size) {
    return this.deleteRange(from8, to);
  }
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  if (fitsTrivially$1($from, $to, slice11)) {
    return this.step(new ReplaceStep$1(from8, to, slice11));
  }
  var targetDepths = coveredDepths$1($from, this.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d) > -1) {
      preferredTarget = d;
    } else if ($from.before(d) == pos) {
      targetDepths.splice(1, 0, -d);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice11.openStart;
  for (var content4 = slice11.content, i = 0; ; i++) {
    var node8 = content4.firstChild;
    leftNodes.push(node8);
    if (i == slice11.openStart) {
      break;
    }
    content4 = node8.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j = slice11.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index6 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index6, index6, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice$1(closeFragment$1(slice11.content, 0, slice11.openStart, openDepth), openDepth, slice11.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from8, to, slice11);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from8 = $from.before(depth);
    to = $to.after(depth);
  }
  return this;
};
function closeFragment$1(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment$1(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start8 = match.fillBefore(fragment).append(fragment);
    fragment = start8.append(match.matchFragment(start8).fillBefore(Fragment$1.empty, true));
  }
  return fragment;
}
Transform$1.prototype.replaceRangeWith = function(from8, to, node8) {
  if (!node8.isInline && from8 == to && this.doc.resolve(from8).parent.content.size) {
    var point = insertPoint$1(this.doc, from8, node8.type);
    if (point != null) {
      from8 = to = point;
    }
  }
  return this.replaceRange(from8, to, new Slice$1(Fragment$1.from(node8), 0, 0));
};
Transform$1.prototype.deleteRange = function(from8, to) {
  var $from = this.doc.resolve(from8), $to = this.doc.resolve(to);
  var covered = coveredDepths$1($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from8 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
      return this.delete($from.before(d), to);
    }
  }
  return this.delete(from8, to);
};
function coveredDepths$1($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start8 = $from.start(d);
    if (start8 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start8 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start8 - 1) {
      result2.push(d);
    }
  }
  return result2;
}
var classesById = /* @__PURE__ */ Object.create(null);
var Selection3 = function Selection4($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange3($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$7 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$7.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$7.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$7.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$7.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$7.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$7.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$7.empty.get = function() {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    if (ranges[i].$from.pos != ranges[i].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection3.prototype.content = function content3() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection3.prototype.replace = function replace3(tr, content4) {
  if (content4 === void 0)
    content4 = Slice$1.empty;
  var lastNode = content4.content.lastChild, lastParent = null;
  for (var i = 0; i < content4.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref2 = ranges[i$1];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice$1.empty : content4);
    if (i$1 == 0) {
      selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection3.prototype.replaceWith = function replaceWith3(tr, node8) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref2 = ranges[i];
    var $from = ref2.$from;
    var $to = ref2.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from8 = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from8, to);
    } else {
      tr.replaceRangeWith(from8, to, node8);
      selectionToInsertionEnd(tr, mapFrom, node8.isInline ? -1 : 1);
    }
  }
};
Selection3.findFrom = function findFrom3($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection3.near = function near3($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
};
Selection3.atStart = function atStart3(doc2) {
  return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
};
Selection3.atEnd = function atEnd3(doc2) {
  return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
};
Selection3.fromJSON = function fromJSON25(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection3.jsonID = function jsonID7(id, selectionClass) {
  if (id in classesById) {
    throw new RangeError("Duplicate use of selection JSON ID " + id);
  }
  classesById[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass;
};
Selection3.prototype.getBookmark = function getBookmark3() {
  return TextSelection.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection3.prototype, prototypeAccessors$7);
Selection3.prototype.visible = true;
var SelectionRange3 = function SelectionRange4($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection = /* @__PURE__ */ function(Selection5) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection5.call(this, $anchor, $head);
  }
  if (Selection5)
    TextSelection2.__proto__ = Selection5;
  TextSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map30(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection5.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$1.empty;
    Selection5.prototype.replace.call(this, tr, content4);
    if (content4 == Slice$1.empty) {
      var marks6 = this.$from.marksAcross(this.$to);
      if (marks6) {
        tr.ensureMarks(marks6);
      }
    }
  };
  TextSelection2.prototype.eq = function eq29(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark4() {
    return new TextBookmark3(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON28() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create15(doc2, anchor, head) {
    if (head === void 0)
      head = anchor;
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection5.findFrom($head, bias, true) || Selection5.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection5.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection5.findFrom($anchor, -bias, true) || Selection5.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection3);
Selection3.jsonID("text", TextSelection);
var TextBookmark3 = function TextBookmark4(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark3.prototype.map = function map25(mapping) {
  return new TextBookmark3(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark3.prototype.resolve = function resolve15(doc2) {
  return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection = /* @__PURE__ */ function(Selection5) {
  function NodeSelection2($pos) {
    var node8 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node8.nodeSize);
    Selection5.call(this, $pos, $end);
    this.node = node8;
  }
  if (Selection5)
    NodeSelection2.__proto__ = Selection5;
  NodeSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map30(doc2, mapping) {
    var ref2 = mapping.mapResult(this.anchor);
    var deleted = ref2.deleted;
    var pos = ref2.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection5.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content4() {
    return new Slice$1(Fragment$1.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq29(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON28() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark4() {
    return new NodeBookmark3(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON31(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create15(doc2, from8) {
    return new this(doc2.resolve(from8));
  };
  NodeSelection2.isSelectable = function isSelectable2(node8) {
    return !node8.isText && node8.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection3);
NodeSelection.prototype.visible = false;
Selection3.jsonID("node", NodeSelection);
var NodeBookmark3 = function NodeBookmark4(anchor) {
  this.anchor = anchor;
};
NodeBookmark3.prototype.map = function map26(mapping) {
  var ref2 = mapping.mapResult(this.anchor);
  var deleted = ref2.deleted;
  var pos = ref2.pos;
  return deleted ? new TextBookmark3(pos, pos) : new NodeBookmark3(pos);
};
NodeBookmark3.prototype.resolve = function resolve16(doc2) {
  var $pos = doc2.resolve(this.anchor), node8 = $pos.nodeAfter;
  if (node8 && NodeSelection.isSelectable(node8)) {
    return new NodeSelection($pos);
  }
  return Selection3.near($pos);
};
var AllSelection = /* @__PURE__ */ function(Selection5) {
  function AllSelection2(doc2) {
    Selection5.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection5)
    AllSelection2.__proto__ = Selection5;
  AllSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$1.empty;
    if (content4 == Slice$1.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection5.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection5.prototype.replace.call(this, tr, content4);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON28() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON31(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map30(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq29(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark4() {
    return AllBookmark;
  };
  return AllSelection2;
}(Selection3);
Selection3.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map27() {
    return this;
  },
  resolve: function resolve17(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node8, pos, index6, dir, text3) {
  if (node8.inlineContent) {
    return TextSelection.create(doc2, pos);
  }
  for (var i = index6 - (dir > 0 ? 0 : 1); dir > 0 ? i < node8.childCount : i >= 0; i += dir) {
    var child11 = node8.child(i);
    if (!child11.isAtom) {
      var inner = findSelectionIn(doc2, child11, pos + dir, dir < 0 ? child11.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection.isSelectable(child11)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child11.nodeSize : 0));
    }
    pos += child11.nodeSize * dir;
  }
}
function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step5 = tr.steps[last];
  if (!(step5 instanceof ReplaceStep$1 || step5 instanceof ReplaceAroundStep$1)) {
    return;
  }
  var map30 = tr.mapping.maps[last], end7;
  map30.forEach(function(_from, _to, _newFrom, newTo) {
    if (end7 == null) {
      end7 = newTo;
    }
  });
  tr.setSelection(Selection3.near(tr.doc.resolve(end7), bias));
}
var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
var Transaction = /* @__PURE__ */ function(Transform6) {
  function Transaction2(state) {
    Transform6.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
  }
  if (Transform6)
    Transaction2.__proto__ = Transform6;
  Transaction2.prototype = Object.create(Transform6 && Transform6.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection2(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks6) {
    this.storedMarks = marks6;
    this.updated |= UPDATED_MARKS;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks2(marks6) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks6)) {
      this.setStoredMarks(marks6);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark7) {
    return this.ensureMarks(mark7.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark7) {
    return this.ensureMarks(mark7.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS) > 0;
  };
  Transaction2.prototype.addStep = function addStep5(step5, doc2) {
    Transform6.prototype.addStep.call(this, step5, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice11) {
    this.selection.replace(this, slice11);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node8, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node8 = node8.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    }
    selection.replaceWith(this, node8);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text3, from8, to) {
    if (to === void 0)
      to = from8;
    var schema = this.doc.type.schema;
    if (from8 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from8, to);
      }
      var marks6 = this.storedMarks;
      if (!marks6) {
        var $from = this.doc.resolve(from8);
        marks6 = to == from8 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from8, to, schema.text(text3, marks6));
      if (!this.selection.empty) {
        this.setSelection(Selection3.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta2(key2, value) {
    this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key2) {
    return this.meta[typeof key2 == "string" ? key2 : key2.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _ in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView2() {
    this.updated |= UPDATED_SCROLL;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform$1);
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc3 = function FieldDesc4(name, desc, self2) {
  this.name = name;
  this.init = bind(desc.init, self2);
  this.apply = bind(desc.apply, self2);
};
var baseFields = [
  new FieldDesc3("doc", {
    init: function init9(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply: function apply15(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc3("selection", {
    init: function init10(config, instance) {
      return config.selection || Selection3.atStart(instance.doc);
    },
    apply: function apply16(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc3("storedMarks", {
    init: function init11(config) {
      return config.storedMarks || null;
    },
    apply: function apply17(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc3("scrollToSelection", {
    init: function init12() {
      return 0;
    },
    apply: function apply18(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration3 = function Configuration4(schema, plugins) {
  var this$1$1 = this;
  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin) {
      if (this$1$1.pluginsByKey[plugin.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      }
      this$1$1.plugins.push(plugin);
      this$1$1.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) {
        this$1$1.fields.push(new FieldDesc3(plugin.key, plugin.spec.state, plugin));
      }
    });
  }
};
var EditorState3 = function EditorState4(config) {
  this.config = config;
};
var prototypeAccessors$1$4 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$4.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$4.plugins.get = function() {
  return this.config.plugins;
};
EditorState3.prototype.apply = function apply19(tr) {
  return this.applyTransaction(tr).state;
};
EditorState3.prototype.filterTransaction = function filterTransaction3(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i = 0; i < this.config.plugins.length; i++) {
    if (i != ignore) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState3.prototype.applyTransaction = function applyTransaction3(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++) {
              seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState3.prototype.applyInner = function applyInner3(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState3(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
    applyListeners[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$4.tr.get = function() {
  return new Transaction(this);
};
EditorState3.create = function create12(config) {
  var $config = new Configuration3(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState3($config);
  for (var i = 0; i < $config.fields.length; i++) {
    instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
  }
  return instance;
};
EditorState3.prototype.reconfigure = function reconfigure3(config) {
  var $config = new Configuration3(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState3($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance;
};
EditorState3.prototype.toJSON = function toJSON23(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m) {
      return m.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin = pluginFields[prop], state = plugin.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    }
  }
  return result2;
};
EditorState3.fromJSON = function fromJSON26(config, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration3(config.schema, config.plugins);
  var instance = new EditorState3($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node$1.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection3.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance;
};
EditorState3.addApplyListener = function addApplyListener3(f) {
  applyListeners.push(f);
};
EditorState3.removeApplyListener = function removeApplyListener3(f) {
  var found2 = applyListeners.indexOf(f);
  if (found2 > -1) {
    applyListeners.splice(found2, 1);
  }
};
Object.defineProperties(EditorState3.prototype, prototypeAccessors$1$4);
var applyListeners = [];
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
const domIndex = function(node8) {
  for (var index6 = 0; ; index6++) {
    node8 = node8.previousSibling;
    if (!node8)
      return index6;
  }
};
const isEquivalentPosition = function(node8, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node8, off2, targetNode, targetOff, -1) || scanFor(node8, off2, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node8, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node8 == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : nodeSize(node8))) {
      let parent = node8.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node8) || atomElements.test(node8.nodeName) || node8.contentEditable == "false")
        return false;
      off2 = domIndex(node8) + (dir < 0 ? 0 : 1);
      node8 = parent;
    } else if (node8.nodeType == 1) {
      node8 = node8.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node8.contentEditable == "false")
        return false;
      off2 = dir < 0 ? nodeSize(node8) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node8) {
  return node8.nodeType == 3 ? node8.nodeValue.length : node8.childNodes.length;
}
function isOnEdge(node8, offset6, parent) {
  for (let atStart4 = offset6 == 0, atEnd4 = offset6 == nodeSize(node8); atStart4 || atEnd4; ) {
    if (node8 == parent)
      return true;
    let index6 = domIndex(node8);
    node8 = node8.parentNode;
    if (!node8)
      return false;
    atStart4 = atStart4 && index6 == 0;
    atEnd4 = atEnd4 && index6 == nodeSize(node8);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  let collapsed = domSel.isCollapsed;
  if (collapsed && chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    collapsed = false;
  return collapsed;
};
function keyEvent(keyCode, key2) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node)
      nearestDesc2 = nearestDesc2.parent;
    let nearestDescNode = nearestDesc2.node;
    if (nearestDesc2 && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc2.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      let pos = nearestDesc2.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node: node8, offset: offset6 } = view.docView.domFromPos(pos, 0);
  let after6 = offset6 < node8.childNodes.length ? node8.childNodes[offset6] : null;
  let before6 = offset6 ? node8.childNodes[offset6 - 1] : null;
  if (safari && after6 && after6.contentEditable == "false")
    return setEditable(after6);
  if ((!after6 || after6.contentEditable == "false") && (!before6 || before6.contentEditable == "false")) {
    if (after6)
      return setEditable(after6);
    else if (before6)
      return setEditable(before6);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelection();
  let node8 = domSel.anchorNode, offset6 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node8 || domSel.anchorOffset != offset6) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range3 = document.createRange();
  let node8 = view.cursorWrapper.dom, img = node8.nodeName == "IMG";
  if (img)
    range3.setEnd(node8.parentNode, domIndex(node8) + 1);
  else
    range3.setEnd(node8, 0);
  range3.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range3);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node8.disabled = true;
    node8.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasSelection(view) {
  let sel = view.domSelection();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection3.findFrom($start, dir);
}
function apply20(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply20(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node8 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node8 || node8.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node8.nodeSize : $head.pos;
      if (!(node8.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node8)) {
        return apply20(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node8.nodeSize) : $head));
      } else if (webkit) {
        return apply20(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node8.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply20(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply20(view, next);
    return false;
  }
}
function nodeLen(node8) {
  return node8.nodeType == 3 ? node8.nodeValue.length : node8.childNodes.length;
}
function isIgnorable(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  let sel = view.domSelection();
  let node8 = sel.focusNode, offset6 = sel.focusOffset;
  if (!node8)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node8.nodeType == 1 && offset6 < nodeLen(node8) && isIgnorable(node8.childNodes[offset6]))
    force = true;
  for (; ; ) {
    if (offset6 > 0) {
      if (node8.nodeType != 1) {
        break;
      } else {
        let before6 = node8.childNodes[offset6 - 1];
        if (isIgnorable(before6)) {
          moveNode = node8;
          moveOffset = --offset6;
        } else if (before6.nodeType == 3) {
          node8 = before6;
          offset6 = node8.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node8)) {
      break;
    } else {
      let prev = node8.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node8.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node8 = node8.parentNode;
        if (node8 == view.dom)
          break;
        offset6 = 0;
      } else {
        node8 = prev;
        offset6 = nodeLen(node8);
      }
    }
  }
  if (force)
    setSelFocus(view, sel, node8, offset6);
  else if (moveNode)
    setSelFocus(view, sel, moveNode, moveOffset);
}
function skipIgnoredNodesRight(view) {
  let sel = view.domSelection();
  let node8 = sel.focusNode, offset6 = sel.focusOffset;
  if (!node8)
    return;
  let len = nodeLen(node8);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset6 < len) {
      if (node8.nodeType != 1)
        break;
      let after6 = node8.childNodes[offset6];
      if (isIgnorable(after6)) {
        moveNode = node8;
        moveOffset = ++offset6;
      } else
        break;
    } else if (isBlockNode(node8)) {
      break;
    } else {
      let next = node8.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node8 = node8.parentNode;
        if (node8 == view.dom)
          break;
        offset6 = len = 0;
      } else {
        node8 = next;
        offset6 = 0;
        len = nodeLen(node8);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, sel, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node8, offset6) {
  if (selectionCollapsed(sel)) {
    let range3 = document.createRange();
    range3.setEnd(node8, offset6);
    range3.setStart(node8, offset6);
    sel.removeAllRanges();
    sel.addRange(range3);
  } else if (sel.extend) {
    sel.extend(node8, offset6);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply20(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection3.near(side, dir) : Selection3.findFrom(side, dir);
    return beyond ? apply20(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node8, state) {
  view.domObserver.stop();
  node8.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelection();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child11 = focusNode.firstChild;
    switchEditable(view, child11, "true");
    setTimeout(() => switchEditable(view, child11, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result2 = "";
  if (event.ctrlKey)
    result2 += "c";
  if (event.metaKey)
    result2 += "m";
  if (event.altKey)
    result2 += "a";
  if (event.shiftKey)
    result2 += "s";
  return result2;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code2 == 46 || mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac && code2 == 66 && mods == "c") {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 39 || mac && code2 == 70 && mods == "c") {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code2 == 38 || mac && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 40 || mac && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice11) {
  let context = [], { content: content4, openStart, openEnd } = slice11;
  while (openStart > 1 && openEnd > 1 && content4.childCount == 1 && content4.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node8 = content4.firstChild;
    context.push(node8.type.name, node8.attrs != node8.type.defaultAttrs ? node8.attrs : null);
    content4 = node8.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer2.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content4, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text3 = view.someProp("clipboardTextSerializer", (f) => f(slice11)) || slice11.content.textBetween(0, slice11.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard(view, text3, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice11;
  if (!html && !text3)
    return null;
  let asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text3 = f(text3, inCode || plainText);
    });
    if (inCode)
      return text3 ? new Slice$1(Fragment$1.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice$1.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text3, $context, plainText));
    if (parsed) {
      slice11 = parsed;
    } else {
      let marks6 = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer2.fromSchema(schema);
      dom = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks6)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0 && dom.firstChild; i--)
      dom = dom.firstChild;
  if (!slice11) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice11 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice11 = addContext(closeSlice(slice11, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice11 = Slice$1.maxOpen(normalizeSiblings(slice11.content, $context), true);
    if (slice11.openStart || slice11.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node8 = slice11.content.firstChild; openStart < slice11.openStart && !node8.type.spec.isolating; openStart++, node8 = node8.firstChild) {
      }
      for (let node8 = slice11.content.lastChild; openEnd < slice11.openEnd && !node8.type.spec.isolating; openEnd++, node8 = node8.lastChild) {
      }
      slice11 = closeSlice(slice11, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice11 = f(slice11);
  });
  return slice11;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result2 = [];
    fragment.forEach((node8) => {
      if (!result2)
        return;
      let wrap2 = match.findWrapping(node8.type), inLast;
      if (!wrap2)
        return result2 = null;
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap2, lastWrap, node8, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length)
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        let wrapped = withWrappers(node8, wrap2);
        result2.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result2)
      return Fragment$1.from(result2);
  }
  return fragment;
}
function withWrappers(node8, wrap2, from8 = 0) {
  for (let i = wrap2.length - 1; i >= from8; i--)
    node8 = wrap2[i].create(null, Fragment$1.from(node8));
  return node8;
}
function addToSibling(wrap2, lastWrap, node8, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node8, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node8.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment$1.from(withWrappers(node8, wrap2, depth + 1))));
  }
}
function closeRight(node8, depth) {
  if (depth == 0)
    return node8;
  let fragment = node8.content.replaceChild(node8.childCount - 1, closeRight(node8.lastChild, depth - 1));
  let fill = node8.contentMatchAt(node8.childCount).fillBefore(Fragment$1.empty, true);
  return node8.copy(fragment.append(fill));
}
function closeRange(fragment, side, from8, to, depth, openEnd) {
  let node8 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node8.content;
  if (depth < to - 1)
    inner = closeRange(inner, side, from8, to, depth + 1, openEnd);
  if (depth >= from8)
    inner = side < 0 ? node8.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node8.contentMatchAt(node8.childCount).fillBefore(Fragment$1.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node8.copy(inner));
}
function closeSlice(slice11, openStart, openEnd) {
  if (openStart < slice11.openStart)
    slice11 = new Slice$1(closeRange(slice11.content, -1, openStart, slice11.openStart, 0, slice11.openEnd), openStart, slice11.openEnd);
  if (openEnd < slice11.openEnd)
    slice11 = new Slice$1(closeRange(slice11.content, 1, openEnd, slice11.openEnd, 0, 0), slice11.openStart, openEnd);
  return slice11;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node8 = nodes[i];
    if (node8.childNodes.length == 1 && node8.textContent == "\xA0" && node8.parentNode)
      node8.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node8);
  }
}
function addContext(slice11, context) {
  if (!slice11.size)
    return slice11;
  let schema = slice11.content.firstChild.type.schema, array4;
  try {
    array4 = JSON.parse(context);
  } catch (e) {
    return slice11;
  }
  let { content: content4, openStart, openEnd } = slice11;
  for (let i = array4.length - 2; i >= 0; i -= 2) {
    let type4 = schema.nodes[array4[i]];
    if (!type4 || type4.hasRequiredAttrs())
      break;
    content4 = Fragment$1.from(type4.create(array4[i + 1], content4));
    openStart++;
    openEnd++;
  }
  return new Slice$1(content4, openStart, openEnd);
}
const handlers = {};
let editHandlers = {};
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
editHandlers.keydown = (view, _event2) => {
  let event = _event2;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event2) => {
  let event = _event2;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text3)))
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node8 = $pos.nodeAfter;
  if (node8 && node8.isAtom && NodeSelection.isSelectable(node8)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node8 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node8)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node8 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node8.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node8.content.size), "pointer");
    else if (NodeSelection.isSelectable(node8))
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event2) => {
  let event = _event2;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type4 = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type4 = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type4 = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type: type4 };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type4 == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown2(view, pos, event, !!flushed);
  } else if ((type4 == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown2 {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection3.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
}
handlers.touchdown = (view) => {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelection();
        for (let node8 = sel.focusNode, offset6 = sel.focusOffset; node8 && node8.nodeType == 1 && offset6 != 0; ) {
          let before6 = offset6 < 0 ? node8.lastChild : node8.childNodes[offset6 - 1];
          if (!before6)
            break;
          if (before6.nodeType == 3) {
            sel.collapse(before6, before6.nodeValue.length);
            break;
          } else {
            node8 = before6;
            offset6 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range3 = document.createRange();
  range3.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range3);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event2) => {
  let event = _event2;
  let sel = view.state.selection, cut11 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice11 = sel.content(), { dom, text: text3 } = serializeForClipboard(view, slice11);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy(view, dom);
  }
  if (cut11)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice11) {
  return slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1 ? slice11.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, event);
    else
      doPaste(view, target.textContent, target.innerHTML, event);
  }, 50);
}
function doPaste(view, text3, html, event) {
  let slice11 = parseFromClipboard(view, text3, html, view.input.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice11 || Slice$1.empty)))
    return true;
  if (!slice11)
    return false;
  let singleNode = sliceSingleNode(slice11);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice11);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = (view, _event2) => {
  let event = _event2;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging2 {
  constructor(slice11, move2) {
    this.slice = slice11;
    this.move = move2;
  }
}
const dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event2) => {
  let event = _event2;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
  }
  let slice11 = view.state.selection.content(), { dom, text: text3 } = serializeForClipboard(view, slice11);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text3);
  view.dragging = new Dragging2(slice11, !event[dragCopyModifier]);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event2) => {
  let event = _event2;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse)
    return;
  let slice11 = dragging && dragging.slice;
  if (slice11) {
    view.someProp("transformPasted", (f) => {
      slice11 = f(slice11);
    });
  } else {
    slice11 = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice11 || Slice$1.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice11)
    return;
  event.preventDefault();
  let insertPos = slice11 ? dropPoint(view.state.doc, $mouse.pos, slice11) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move2)
    tr.deleteSelection();
  let pos = tr.mapping.map(insertPos);
  let isNode = slice11.openStart == 0 && slice11.openEnd == 0 && slice11.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice11.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice11);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice11.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice11.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end7 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end7 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end7)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelection()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event2) => {
  let event = _event2;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event2) => {
  let event = _event2;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
class WidgetType2 {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset6, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration2(pos - offset6, pos - offset6, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node8) {
    if (this.spec.destroy)
      this.spec.destroy(node8);
  }
}
class InlineType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset6, oldOffset) {
    let from8 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset6;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset6;
    return from8 >= to ? null : new Decoration2(from8, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType2;
  }
  destroy() {
  }
}
class NodeType$1 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset6, oldOffset) {
    let from8 = mapping.mapResult(span.from + oldOffset, 1);
    if (from8.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from8.pos)
      return null;
    return new Decoration2(from8.pos - offset6, to.pos - offset6, this);
  }
  valid(node8, span) {
    let { index: index6, offset: offset6 } = node8.content.findIndex(span.from), child11;
    return offset6 == span.from && !(child11 = node8.child(index6)).isText && offset6 + child11.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType$1 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration2 {
  constructor(from8, to, type4) {
    this.from = from8;
    this.to = to;
    this.type = type4;
  }
  copy(from8, to) {
    return new Decoration2(from8, to, this.type);
  }
  eq(other, offset6 = 0) {
    return this.type.eq(other.type) && this.from + offset6 == other.from && this.to + offset6 == other.to;
  }
  map(mapping, offset6, oldOffset) {
    return this.type.map(mapping, this, offset6, oldOffset);
  }
  static widget(pos, toDOM, spec) {
    return new Decoration2(pos, pos, new WidgetType2(toDOM, spec));
  }
  static inline(from8, to, attrs, spec) {
    return new Decoration2(from8, to, new InlineType2(attrs, spec));
  }
  static node(from8, to, attrs, spec) {
    return new Decoration2(from8, to, new NodeType$1(attrs, spec));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof InlineType2;
  }
}
const none = [], noSpec = {};
class DecorationSet2 {
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  find(start8, end7, predicate) {
    let result2 = [];
    this.findInner(start8 == null ? 0 : start8, end7 == null ? 1e9 : end7, result2, 0, predicate);
    return result2;
  }
  findInner(start8, end7, result2, offset6, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end7 && span.to >= start8 && (!predicate || predicate(span.spec)))
        result2.push(span.copy(span.from + offset6, span.to + offset6));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end7 && this.children[i + 1] > start8) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start8 - childOff, end7 - childOff, result2, offset6 + childOff, predicate);
      }
    }
  }
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  mapInner(mapping, node8, offset6, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset6, oldOffset);
      if (mapped && mapped.type.valid(node8, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node8, offset6, oldOffset, options);
    else
      return newLocal ? new DecorationSet2(newLocal.sort(byPos), none) : empty;
  }
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet2.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset6) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset6, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset6);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet2(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset6) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from8 = children[i] + offset6, to = children[i + 1] + offset6;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from8 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from8 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset6)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet2(local, children) : empty;
  }
  forChild(offset6, node8) {
    if (this == empty)
      return this;
    if (node8.isLeaf)
      return DecorationSet2.empty;
    let child11, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset6) {
        if (this.children[i] == offset6)
          child11 = this.children[i + 2];
        break;
      }
    let start8 = offset6 + 1, end7 = start8 + node8.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end7 && dec.to > start8 && dec.type instanceof InlineType2) {
        let from8 = Math.max(start8, dec.from) - start8, to = Math.min(end7, dec.to) - start8;
        if (from8 < to)
          (local || (local = [])).push(dec.copy(from8, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet2(local.sort(byPos), none);
      return child11 ? new DecorationGroup2([localSet, child11]) : localSet;
    }
    return child11 || empty;
  }
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  locals(node8) {
    return removeOverlap(this.localsInner(node8));
  }
  localsInner(node8) {
    if (this == empty)
      return none;
    if (node8.inlineContent || !this.local.some(InlineType2.is))
      return this.local;
    let result2 = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType2))
        result2.push(this.local[i]);
    }
    return result2;
  }
}
DecorationSet2.empty = new DecorationSet2([], []);
DecorationSet2.removeOverlap = removeOverlap;
const empty = DecorationSet2.empty;
class DecorationGroup2 {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup2.from(mappedDecos);
  }
  forChild(offset6, child11) {
    if (child11.isLeaf)
      return DecorationSet2.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result2 = this.members[i].forChild(offset6, child11);
      if (result2 == empty)
        continue;
      if (result2 instanceof DecorationGroup2)
        found2 = found2.concat(result2.members);
      else
        found2.push(result2);
    }
    return DecorationGroup2.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node8) {
    let result2, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals3 = this.members[i].localsInner(node8);
      if (!locals3.length)
        continue;
      if (!result2) {
        result2 = locals3;
      } else {
        if (sorted) {
          result2 = result2.slice();
          sorted = false;
        }
        for (let j = 0; j < locals3.length; j++)
          result2.push(locals3[j]);
      }
    }
    return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
  }
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup2(members);
    }
  }
}
function mapChildren(oldChildren, newLocal, mapping, node8, offset6, oldOffset, options) {
  let children = oldChildren.slice();
  let shift2 = (oldStart, oldEnd, newStart, newEnd) => {
    for (let i = 0; i < children.length; i += 3) {
      let end7 = children[i + 1], dSize;
      if (end7 < 0 || oldStart > end7 + oldOffset)
        continue;
      let start8 = children[i] + oldOffset;
      if (oldEnd >= start8) {
        children[i + 1] = oldStart <= start8 ? -2 : -1;
      } else if (newStart >= offset6 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (let i = 0; i < mapping.maps.length; i++)
    mapping.maps[i].forEach(shift2);
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from8 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from8 - offset6;
      if (fromLocal < 0 || fromLocal >= node8.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset6;
      let { index: index6, offset: childOffset } = node8.content.findIndex(fromLocal);
      let childNode = node8.maybeChild(index6);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from8 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset6, oldOffset, options);
    let built = buildTree(decorations, node8, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from8 = built.children[i];
      while (j < children.length && children[j] < from8)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet2(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset6) {
  if (!offset6 || !spans.length)
    return spans;
  let result2 = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result2.push(new Decoration2(span.from + offset6, span.to + offset6, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset6, oldOffset, options) {
  function gather(set3, oldOffset2) {
    for (let i = 0; i < set3.local.length; i++) {
      let mapped = set3.local[i].map(mapping, offset6, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set3.local[i].spec);
    }
    for (let i = 0; i < set3.children.length; i += 3)
      gather(set3.children[i + 2], set3.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node8, offset6) {
  if (node8.isLeaf)
    return null;
  let end7 = offset6 + node8.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset6 && span.to < end7) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array4) {
  let result2 = [];
  for (let i = 0; i < array4.length; i++)
    if (array4[i] != null)
      result2.push(array4[i]);
  return result2;
}
function buildTree(spans, node8, offset6, options) {
  let children = [], hasNulls = false;
  node8.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset6);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset6 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset6).sort(byPos);
  for (let i = 0; i < locals3.length; i++)
    if (!locals3[i].type.valid(node8, locals3[i])) {
      if (options.onRemove)
        options.onRemove(locals3[i].spec);
      locals3.splice(i--, 1);
    }
  return locals3.length || children.length ? new DecorationSet2(locals3, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array4, i, deco) {
  while (i < array4.length && byPos(deco, array4[i]) > 0)
    i++;
  array4.splice(i, 0, deco);
}
function findDiffStart(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment5 = function Fragment6(content4, size) {
  this.content = content4;
  this.size = size || 0;
  if (size == null) {
    for (var i = 0; i < content4.length; i++) {
      this.size += content4[i].nodeSize;
    }
  }
};
var prototypeAccessors = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment5.prototype.nodesBetween = function nodesBetween9(from8, to, f, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i = 0, pos = 0; pos < to; i++) {
    var child11 = this.content[i], end7 = pos + child11.nodeSize;
    if (end7 > from8 && f(child11, nodeStart + pos, parent, i) !== false && child11.content.size) {
      var start8 = pos + 1;
      child11.nodesBetween(Math.max(0, from8 - start8), Math.min(child11.content.size, to - start8), f, nodeStart + start8);
    }
    pos = end7;
  }
};
Fragment5.prototype.descendants = function descendants9(f) {
  this.nodesBetween(0, this.size, f);
};
Fragment5.prototype.textBetween = function textBetween9(from8, to, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from8, to, function(node8, pos) {
    if (node8.isText) {
      text3 += node8.text.slice(Math.max(from8, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node8.isLeaf && leafText) {
      text3 += typeof leafText === "function" ? leafText(node8) : leafText;
      separated = !blockSeparator;
    } else if (!separated && node8.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment5.prototype.append = function append5(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first2 = other.firstChild, content4 = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first2)) {
    content4[content4.length - 1] = last.withText(last.text + first2.text);
    i = 1;
  }
  for (; i < other.content.length; i++) {
    content4.push(other.content[i]);
  }
  return new Fragment5(content4, this.size + other.size);
};
Fragment5.prototype.cut = function cut9(from8, to) {
  if (to == null) {
    to = this.size;
  }
  if (from8 == 0 && to == this.size) {
    return this;
  }
  var result2 = [], size = 0;
  if (to > from8) {
    for (var i = 0, pos = 0; pos < to; i++) {
      var child11 = this.content[i], end7 = pos + child11.nodeSize;
      if (end7 > from8) {
        if (pos < from8 || end7 > to) {
          if (child11.isText) {
            child11 = child11.cut(Math.max(0, from8 - pos), Math.min(child11.text.length, to - pos));
          } else {
            child11 = child11.cut(Math.max(0, from8 - pos - 1), Math.min(child11.content.size, to - pos - 1));
          }
        }
        result2.push(child11);
        size += child11.nodeSize;
      }
      pos = end7;
    }
  }
  return new Fragment5(result2, size);
};
Fragment5.prototype.cutByIndex = function cutByIndex5(from8, to) {
  if (from8 == to) {
    return Fragment5.empty;
  }
  if (from8 == 0 && to == this.content.length) {
    return this;
  }
  return new Fragment5(this.content.slice(from8, to));
};
Fragment5.prototype.replaceChild = function replaceChild5(index6, node8) {
  var current = this.content[index6];
  if (current == node8) {
    return this;
  }
  var copy12 = this.content.slice();
  var size = this.size + node8.nodeSize - current.nodeSize;
  copy12[index6] = node8;
  return new Fragment5(copy12, size);
};
Fragment5.prototype.addToStart = function addToStart5(node8) {
  return new Fragment5([node8].concat(this.content), this.size + node8.nodeSize);
};
Fragment5.prototype.addToEnd = function addToEnd5(node8) {
  return new Fragment5(this.content.concat(node8), this.size + node8.nodeSize);
};
Fragment5.prototype.eq = function eq25(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i = 0; i < this.content.length; i++) {
    if (!this.content[i].eq(other.content[i])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors.childCount.get = function() {
  return this.content.length;
};
Fragment5.prototype.child = function child9(index6) {
  var found2 = this.content[index6];
  if (!found2) {
    throw new RangeError("Index " + index6 + " out of range for " + this);
  }
  return found2;
};
Fragment5.prototype.maybeChild = function maybeChild9(index6) {
  return this.content[index6];
};
Fragment5.prototype.forEach = function forEach14(f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child11 = this.content[i];
    f(child11, p, i);
    p += child11.nodeSize;
  }
};
Fragment5.prototype.findDiffStart = function findDiffStart$15(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart(this, other, pos);
};
Fragment5.prototype.findDiffEnd = function findDiffEnd$15(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd(this, other, pos, otherPos);
};
Fragment5.prototype.findIndex = function findIndex5(pos, round2) {
  if (round2 === void 0)
    round2 = -1;
  if (pos == 0) {
    return retIndex(0, pos);
  }
  if (pos == this.size) {
    return retIndex(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i = 0, curPos = 0; ; i++) {
    var cur = this.child(i), end7 = curPos + cur.nodeSize;
    if (end7 >= pos) {
      if (end7 == pos || round2 > 0) {
        return retIndex(i + 1, end7);
      }
      return retIndex(i, curPos);
    }
    curPos = end7;
  }
};
Fragment5.prototype.toString = function toString26() {
  return "<" + this.toStringInner() + ">";
};
Fragment5.prototype.toStringInner = function toStringInner5() {
  return this.content.join(", ");
};
Fragment5.prototype.toJSON = function toJSON24() {
  return this.content.length ? this.content.map(function(n) {
    return n.toJSON();
  }) : null;
};
Fragment5.fromJSON = function fromJSON27(schema, value) {
  if (!value) {
    return Fragment5.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment5(value.map(schema.nodeFromJSON));
};
Fragment5.fromArray = function fromArray5(array4) {
  if (!array4.length) {
    return Fragment5.empty;
  }
  var joined, size = 0;
  for (var i = 0; i < array4.length; i++) {
    var node8 = array4[i];
    size += node8.nodeSize;
    if (i && node8.isText && array4[i - 1].sameMarkup(node8)) {
      if (!joined) {
        joined = array4.slice(0, i);
      }
      joined[joined.length - 1] = node8.withText(joined[joined.length - 1].text + node8.text);
    } else if (joined) {
      joined.push(node8);
    }
  }
  return new Fragment5(joined || array4, size);
};
Fragment5.from = function from6(nodes) {
  if (!nodes) {
    return Fragment5.empty;
  }
  if (nodes instanceof Fragment5) {
    return nodes;
  }
  if (Array.isArray(nodes)) {
    return this.fromArray(nodes);
  }
  if (nodes.attrs) {
    return new Fragment5([nodes], nodes.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment5.prototype, prototypeAccessors);
var found = { index: 0, offset: 0 };
function retIndex(index6, offset6) {
  found.index = index6;
  found.offset = offset6;
  return found;
}
Fragment5.empty = new Fragment5([], 0);
function compareDeep(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array4 = Array.isArray(a);
  if (Array.isArray(b) != array4) {
    return false;
  }
  if (array4) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
var Mark5 = function Mark6(type4, attrs) {
  this.type = type4;
  this.attrs = attrs;
};
Mark5.prototype.addToSet = function addToSet5(set3) {
  var copy12, placed = false;
  for (var i = 0; i < set3.length; i++) {
    var other = set3[i];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy12) {
        copy12 = set3.slice(0, i);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy12) {
          copy12 = set3.slice(0, i);
        }
        copy12.push(this);
        placed = true;
      }
      if (copy12) {
        copy12.push(other);
      }
    }
  }
  if (!copy12) {
    copy12 = set3.slice();
  }
  if (!placed) {
    copy12.push(this);
  }
  return copy12;
};
Mark5.prototype.removeFromSet = function removeFromSet9(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return set3.slice(0, i).concat(set3.slice(i + 1));
    }
  }
  return set3;
};
Mark5.prototype.isInSet = function isInSet9(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (this.eq(set3[i])) {
      return true;
    }
  }
  return false;
};
Mark5.prototype.eq = function eq26(other) {
  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
};
Mark5.prototype.toJSON = function toJSON25() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark5.fromJSON = function fromJSON28(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type4 = schema.marks[json.type];
  if (!type4) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type4.create(json.attrs);
};
Mark5.sameSet = function sameSet5(a, b) {
  if (a == b) {
    return true;
  }
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].eq(b[i])) {
      return false;
    }
  }
  return true;
};
Mark5.setFrom = function setFrom5(marks6) {
  if (!marks6 || marks6.length == 0) {
    return Mark5.none;
  }
  if (marks6 instanceof Mark5) {
    return [marks6];
  }
  var copy12 = marks6.slice();
  copy12.sort(function(a, b) {
    return a.type.rank - b.type.rank;
  });
  return copy12;
};
Mark5.none = [];
function ReplaceError(message) {
  var err6 = Error.call(this, message);
  err6.__proto__ = ReplaceError.prototype;
  return err6;
}
ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";
var Slice5 = function Slice6(content4, openStart, openEnd) {
  this.content = content4;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1 = { size: { configurable: true } };
prototypeAccessors$1.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice5.prototype.insertAt = function insertAt5(pos, fragment) {
  var content4 = insertInto(this.content, pos + this.openStart, fragment, null);
  return content4 && new Slice5(content4, this.openStart, this.openEnd);
};
Slice5.prototype.removeBetween = function removeBetween5(from8, to) {
  return new Slice5(removeRange(this.content, from8 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
};
Slice5.prototype.eq = function eq27(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice5.prototype.toString = function toString27() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice5.prototype.toJSON = function toJSON26() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice5.fromJSON = function fromJSON29(schema, json) {
  if (!json) {
    return Slice5.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice5(Fragment5.fromJSON(schema, json.content), openStart, openEnd);
};
Slice5.maxOpen = function maxOpen5(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
    openStart++;
  }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
    openEnd++;
  }
  return new Slice5(fragment, openStart, openEnd);
};
Object.defineProperties(Slice5.prototype, prototypeAccessors$1);
function removeRange(content4, from8, to) {
  var ref2 = content4.findIndex(from8);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  var ref$1 = content4.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset6 == from8 || child11.isText) {
    if (offsetTo != to && !content4.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content4.cut(0, from8).append(content4.cut(to));
  }
  if (index6 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content4.replaceChild(index6, child11.copy(removeRange(child11.content, from8 - offset6 - 1, to - offset6 - 1)));
}
function insertInto(content4, dist, insert, parent) {
  var ref2 = content4.findIndex(dist);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  var child11 = content4.maybeChild(index6);
  if (offset6 == dist || child11.isText) {
    if (parent && !parent.canReplace(index6, index6, insert)) {
      return null;
    }
    return content4.cut(0, dist).append(insert).append(content4.cut(dist));
  }
  var inner = insertInto(child11.content, dist - offset6 - 1, insert);
  return inner && content4.replaceChild(index6, child11.copy(inner));
}
Slice5.empty = new Slice5(Fragment5.empty, 0, 0);
function replace4($from, $to, slice11) {
  if (slice11.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice11.openStart != $to.depth - slice11.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice11, 0);
}
function replaceOuter($from, $to, slice11, depth) {
  var index6 = $from.index(depth), node8 = $from.node(depth);
  if (index6 == $to.index(depth) && depth < $from.depth - slice11.openStart) {
    var inner = replaceOuter($from, $to, slice11, depth + 1);
    return node8.copy(node8.content.replaceChild(index6, inner));
  } else if (!slice11.content.size) {
    return close5(node8, replaceTwoWay($from, $to, depth));
  } else if (!slice11.openStart && !slice11.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content4 = parent.content;
    return close5(parent, content4.cut(0, $from.parentOffset).append(slice11.content).append(content4.cut($to.parentOffset)));
  } else {
    var ref2 = prepareSliceForReplace(slice11, $from);
    var start8 = ref2.start;
    var end7 = ref2.end;
    return close5(node8, replaceThreeWay($from, start8, end7, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type)) {
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
}
function joinable($before, $after, depth) {
  var node8 = $before.node(depth);
  checkJoin(node8, $after.node(depth));
  return node8;
}
function addNode2(child11, target) {
  var last = target.length - 1;
  if (last >= 0 && child11.isText && child11.sameMarkup(target[last])) {
    target[last] = child11.withText(target[last].text + child11.text);
  } else {
    target.push(child11);
  }
}
function addRange($start, $end, depth, target) {
  var node8 = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node8.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode2($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var i = startIndex2; i < endIndex2; i++) {
    addNode2(node8.child(i), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode2($end.nodeBefore, target);
  }
}
function close5(node8, content4) {
  if (!node8.type.validContent(content4)) {
    throw new ReplaceError("Invalid content for node " + node8.type.name);
  }
  return node8.copy(content4);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content4 = [];
  addRange(null, $from, depth, content4);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode2(close5(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content4);
  } else {
    if (openStart) {
      addNode2(close5(openStart, replaceTwoWay($from, $start, depth + 1)), content4);
    }
    addRange($start, $end, depth, content4);
    if (openEnd) {
      addNode2(close5(openEnd, replaceTwoWay($end, $to, depth + 1)), content4);
    }
  }
  addRange($to, null, depth, content4);
  return new Fragment5(content4);
}
function replaceTwoWay($from, $to, depth) {
  var content4 = [];
  addRange(null, $from, depth, content4);
  if ($from.depth > depth) {
    var type4 = joinable($from, $to, depth + 1);
    addNode2(close5(type4, replaceTwoWay($from, $to, depth + 1)), content4);
  }
  addRange($to, null, depth, content4);
  return new Fragment5(content4);
}
function prepareSliceForReplace(slice11, $along) {
  var extra = $along.depth - slice11.openStart, parent = $along.node(extra);
  var node8 = parent.copy(slice11.content);
  for (var i = extra - 1; i >= 0; i--) {
    node8 = $along.node(i).copy(Fragment5.from(node8));
  }
  return {
    start: node8.resolveNoCache(slice11.openStart + extra),
    end: node8.resolveNoCache(node8.content.size - slice11.openEnd - extra)
  };
}
var ResolvedPos5 = function ResolvedPos6(pos, path, parentOffset) {
  this.pos = pos;
  this.path = path;
  this.depth = path.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos5.prototype.resolveDepth = function resolveDepth5(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2.doc.get = function() {
  return this.node(0);
};
ResolvedPos5.prototype.node = function node7(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos5.prototype.index = function index5(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos5.prototype.indexAfter = function indexAfter5(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos5.prototype.start = function start7(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos5.prototype.end = function end6(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos5.prototype.before = function before5(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos5.prototype.after = function after5(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2.nodeAfter.get = function() {
  var parent = this.parent, index6 = this.index(this.depth);
  if (index6 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child11 = parent.child(index6);
  return dOff ? parent.child(index6).cut(dOff) : child11;
};
prototypeAccessors$2.nodeBefore.get = function() {
  var index6 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index6).cut(0, dOff);
  }
  return index6 == 0 ? null : this.parent.child(index6 - 1);
};
ResolvedPos5.prototype.posAtIndex = function posAtIndex5(index6, depth) {
  depth = this.resolveDepth(depth);
  var node8 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index6; i++) {
    pos += node8.child(i).nodeSize;
  }
  return pos;
};
ResolvedPos5.prototype.marks = function marks5() {
  var parent = this.parent, index6 = this.index();
  if (parent.content.size == 0) {
    return Mark5.none;
  }
  if (this.textOffset) {
    return parent.child(index6).marks;
  }
  var main2 = parent.maybeChild(index6 - 1), other = parent.maybeChild(index6);
  if (!main2) {
    var tmp = main2;
    main2 = other;
    other = tmp;
  }
  var marks6 = main2.marks;
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!other || !marks6[i].isInSet(other.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos5.prototype.marksAcross = function marksAcross5($end) {
  var after6 = this.parent.maybeChild(this.index());
  if (!after6 || !after6.isInline) {
    return null;
  }
  var marks6 = after6.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks6.length; i++) {
    if (marks6[i].type.spec.inclusive === false && (!next || !marks6[i].isInSet(next.marks))) {
      marks6 = marks6[i--].removeFromSet(marks6);
    }
  }
  return marks6;
};
ResolvedPos5.prototype.sharedDepth = function sharedDepth5(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos5.prototype.blockRange = function blockRange5(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
      return new NodeRange5(this, other, d);
    }
  }
};
ResolvedPos5.prototype.sameParent = function sameParent5(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos5.prototype.max = function max6(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos5.prototype.min = function min6(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos5.prototype.toString = function toString28() {
  var str = "";
  for (var i = 1; i <= this.depth; i++) {
    str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos5.resolve = function resolve18(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path = [];
  var start8 = 0, parentOffset = pos;
  for (var node8 = doc2; ; ) {
    var ref2 = node8.content.findIndex(parentOffset);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    var rem = parentOffset - offset6;
    path.push(node8, index6, start8 + offset6);
    if (!rem) {
      break;
    }
    node8 = node8.child(index6);
    if (node8.isText) {
      break;
    }
    parentOffset = rem - 1;
    start8 += offset6 + 1;
  }
  return new ResolvedPos5(pos, path, parentOffset);
};
ResolvedPos5.resolveCached = function resolveCached5(doc2, pos) {
  for (var i = 0; i < resolveCache.length; i++) {
    var cached = resolveCache[i];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache[resolveCachePos] = ResolvedPos5.resolve(doc2, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result2;
};
Object.defineProperties(ResolvedPos5.prototype, prototypeAccessors$2);
var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
var NodeRange5 = function NodeRange6($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange5.prototype, prototypeAccessors$1$1);
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node5 = function Node6(type4, attrs, content4, marks6) {
  this.type = type4;
  this.attrs = attrs;
  this.content = content4 || Fragment5.empty;
  this.marks = marks6 || Mark5.none;
};
var prototypeAccessors$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3.childCount.get = function() {
  return this.content.childCount;
};
Node5.prototype.child = function child10(index6) {
  return this.content.child(index6);
};
Node5.prototype.maybeChild = function maybeChild10(index6) {
  return this.content.maybeChild(index6);
};
Node5.prototype.forEach = function forEach15(f) {
  this.content.forEach(f);
};
Node5.prototype.nodesBetween = function nodesBetween10(from8, to, f, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from8, to, f, startPos, this);
};
Node5.prototype.descendants = function descendants10(f) {
  this.nodesBetween(0, this.content.size, f);
};
prototypeAccessors$3.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node5.prototype.textBetween = function textBetween10(from8, to, blockSeparator, leafText) {
  return this.content.textBetween(from8, to, blockSeparator, leafText);
};
prototypeAccessors$3.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3.lastChild.get = function() {
  return this.content.lastChild;
};
Node5.prototype.eq = function eq28(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node5.prototype.sameMarkup = function sameMarkup5(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node5.prototype.hasMarkup = function hasMarkup5(type4, attrs, marks6) {
  return this.type == type4 && compareDeep(this.attrs, attrs || type4.defaultAttrs || emptyAttrs) && Mark5.sameSet(this.marks, marks6 || Mark5.none);
};
Node5.prototype.copy = function copy11(content4) {
  if (content4 === void 0)
    content4 = null;
  if (content4 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content4, this.marks);
};
Node5.prototype.mark = function mark6(marks6) {
  return marks6 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks6);
};
Node5.prototype.cut = function cut10(from8, to) {
  if (from8 == 0 && to == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from8, to));
};
Node5.prototype.slice = function slice9(from8, to, includeParents) {
  if (to === void 0)
    to = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from8 == to) {
    return Slice5.empty;
  }
  var $from = this.resolve(from8), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start8 = $from.start(depth), node8 = $from.node(depth);
  var content4 = node8.content.cut($from.pos - start8, $to.pos - start8);
  return new Slice5(content4, $from.depth - depth, $to.depth - depth);
};
Node5.prototype.replace = function replace$15(from8, to, slice11) {
  return replace4(this.resolve(from8), this.resolve(to), slice11);
};
Node5.prototype.nodeAt = function nodeAt5(pos) {
  for (var node8 = this; ; ) {
    var ref2 = node8.content.findIndex(pos);
    var index6 = ref2.index;
    var offset6 = ref2.offset;
    node8 = node8.maybeChild(index6);
    if (!node8) {
      return null;
    }
    if (offset6 == pos || node8.isText) {
      return node8;
    }
    pos -= offset6 + 1;
  }
};
Node5.prototype.childAfter = function childAfter5(pos) {
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  return { node: this.content.maybeChild(index6), index: index6, offset: offset6 };
};
Node5.prototype.childBefore = function childBefore5(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref2 = this.content.findIndex(pos);
  var index6 = ref2.index;
  var offset6 = ref2.offset;
  if (offset6 < pos) {
    return { node: this.content.child(index6), index: index6, offset: offset6 };
  }
  var node8 = this.content.child(index6 - 1);
  return { node: node8, index: index6 - 1, offset: offset6 - node8.nodeSize };
};
Node5.prototype.resolve = function resolve19(pos) {
  return ResolvedPos5.resolveCached(this, pos);
};
Node5.prototype.resolveNoCache = function resolveNoCache5(pos) {
  return ResolvedPos5.resolve(this, pos);
};
Node5.prototype.rangeHasMark = function rangeHasMark5(from8, to, type4) {
  var found2 = false;
  if (to > from8) {
    this.nodesBetween(from8, to, function(node8) {
      if (type4.isInSet(node8.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3.isAtom.get = function() {
  return this.type.isAtom;
};
Node5.prototype.toString = function toString29() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks(this.marks, name);
};
Node5.prototype.contentMatchAt = function contentMatchAt5(index6) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index6);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node5.prototype.canReplace = function canReplace5(from8, to, replacement, start8, end7) {
  if (replacement === void 0)
    replacement = Fragment5.empty;
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = replacement.childCount;
  var one = this.contentMatchAt(from8).matchFragment(replacement, start8, end7);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) {
    return false;
  }
  for (var i = start8; i < end7; i++) {
    if (!this.type.allowsMarks(replacement.child(i).marks)) {
      return false;
    }
  }
  return true;
};
Node5.prototype.canReplaceWith = function canReplaceWith5(from8, to, type4, marks6) {
  if (marks6 && !this.type.allowsMarks(marks6)) {
    return false;
  }
  var start8 = this.contentMatchAt(from8).matchType(type4);
  var end7 = start8 && start8.matchFragment(this.content, to);
  return end7 ? end7.validEnd : false;
};
Node5.prototype.canAppend = function canAppend5(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node5.prototype.check = function check5() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy12 = Mark5.none;
  for (var i = 0; i < this.marks.length; i++) {
    copy12 = this.marks[i].addToSet(copy12);
  }
  if (!Mark5.sameSet(copy12, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
      return m.type.name;
    }));
  }
  this.content.forEach(function(node8) {
    return node8.check();
  });
};
Node5.prototype.toJSON = function toJSON27() {
  var obj = { type: this.type.name };
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n) {
      return n.toJSON();
    });
  }
  return obj;
};
Node5.fromJSON = function fromJSON30(schema, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks6 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks6 = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema.text(json.text, marks6);
  }
  var content4 = Fragment5.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content4, marks6);
};
Object.defineProperties(Node5.prototype, prototypeAccessors$3);
function wrapMarks(marks6, str) {
  for (var i = marks6.length - 1; i >= 0; i--) {
    str = marks6[i].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch5 = function ContentMatch6(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch5.parse = function parse7(string3, nodeTypes) {
  var stream = new TokenStream5(string3, nodeTypes);
  if (stream.next == null) {
    return ContentMatch5.empty;
  }
  var expr = parseExpr(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match;
};
ContentMatch5.prototype.matchType = function matchType5(type4) {
  for (var i = 0; i < this.next.length; i += 2) {
    if (this.next[i] == type4) {
      return this.next[i + 1];
    }
  }
  return null;
};
ContentMatch5.prototype.matchFragment = function matchFragment5(frag, start8, end7) {
  if (start8 === void 0)
    start8 = 0;
  if (end7 === void 0)
    end7 = frag.childCount;
  var cur = this;
  for (var i = start8; cur && i < end7; i++) {
    cur = cur.matchType(frag.child(i).type);
  }
  return cur;
};
prototypeAccessors$4.inlineContent.get = function() {
  var first2 = this.next[0];
  return first2 ? first2.isInline : false;
};
prototypeAccessors$4.defaultType.get = function() {
  for (var i = 0; i < this.next.length; i += 2) {
    var type4 = this.next[i];
    if (!(type4.isText || type4.hasRequiredAttrs())) {
      return type4;
    }
  }
};
ContentMatch5.prototype.compatible = function compatible5(other) {
  for (var i = 0; i < this.next.length; i += 2) {
    for (var j = 0; j < other.next.length; j += 2) {
      if (this.next[i] == other.next[j]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch5.prototype.fillBefore = function fillBefore5(after6, toEnd, startIndex2) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex2 === void 0)
    startIndex2 = 0;
  var seen = [this];
  function search(match, types2) {
    var finished = match.matchFragment(after6, startIndex2);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment5.from(types2.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i], next = match.next[i + 1];
      if (!(type4.isText || type4.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search(next, types2.concat(type4));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search(this, []);
};
ContentMatch5.prototype.findWrapping = function findWrapping10(target) {
  for (var i = 0; i < this.wrapCache.length; i += 2) {
    if (this.wrapCache[i] == target) {
      return this.wrapCache[i + 1];
    }
  }
  var computed2 = this.computeWrapping(target);
  this.wrapCache.push(target, computed2);
  return computed2;
};
ContentMatch5.prototype.computeWrapping = function computeWrapping5(target) {
  var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type4 = match.next[i];
      if (!type4.isLeaf && !type4.hasRequiredAttrs() && !(type4.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({ match: type4.contentMatch, type: type4, via: current });
        seen[type4.name] = true;
      }
    }
  }
};
prototypeAccessors$4.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch5.prototype.edge = function edge5(n) {
  var i = n << 1;
  if (i >= this.next.length) {
    throw new RangeError("There's no " + n + "th edge in this content match");
  }
  return { type: this.next[i], next: this.next[i + 1] };
};
ContentMatch5.prototype.toString = function toString30() {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2) {
      if (seen.indexOf(m.next[i]) == -1) {
        scan(m.next[i]);
      }
    }
  }
  scan(this);
  return seen.map(function(m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch5.prototype, prototypeAccessors$4);
ContentMatch5.empty = new ContentMatch5(true);
var TokenStream5 = function TokenStream6(string3, nodeTypes) {
  this.string = string3;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string3.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2 = { next: { configurable: true } };
prototypeAccessors$1$2.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream5.prototype.eat = function eat5(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream5.prototype.err = function err5(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream5.prototype, prototypeAccessors$1$2);
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min7 = parseNum(stream), max7 = min7;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max7 = parseNum(stream);
    } else {
      max7 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min7, max: max7, expr };
}
function resolveName(stream, name) {
  var types2 = stream.nodeTypes, type4 = types2[name];
  if (type4) {
    return [type4];
  }
  var result2 = [];
  for (var typeName in types2) {
    var type$12 = types2[typeName];
    if (type$12.groups.indexOf(name) > -1) {
      result2.push(type$12);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type4) {
      if (stream.inline == null) {
        stream.inline = type4.isInline;
      } else if (stream.inline != type4.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type4 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile11(expr, 0), node8());
  return nfa2;
  function node8() {
    return nfa2.push([]) - 1;
  }
  function edge6(from8, to, term) {
    var edge7 = { term, to };
    nfa2[from8].push(edge7);
    return edge7;
  }
  function connect(edges, to) {
    edges.forEach(function(edge7) {
      return edge7.to = to;
    });
  }
  function compile11(expr2, from8) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile11(expr3, from8));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile11(expr2.exprs[i], from8);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from8 = node8());
      }
    } else if (expr2.type == "star") {
      var loop = node8();
      edge6(from8, loop);
      connect(compile11(expr2.expr, loop), loop);
      return [edge6(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node8();
      connect(compile11(expr2.expr, from8), loop$1);
      connect(compile11(expr2.expr, loop$1), loop$1);
      return [edge6(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge6(from8)].concat(compile11(expr2.expr, from8));
    } else if (expr2.type == "range") {
      var cur = from8;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node8();
        connect(compile11(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile11(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node8();
          edge6(cur, next$2);
          connect(compile11(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge6(cur)];
    } else if (expr2.type == "name") {
      return [edge6(from8, null, expr2.value)];
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node8) {
  var result2 = [];
  scan(node8);
  return result2.sort(cmp);
  function scan(node9) {
    var edges = nfa2[node9];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node9);
    for (var i = 0; i < edges.length; i++) {
      var ref2 = edges[i];
      var term = ref2.term;
      var to = ref2.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node8) {
      nfa2[node8].forEach(function(ref2) {
        var term = ref2.term;
        var to = ref2.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom(nfa2, to).forEach(function(node9) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node9) == -1) {
            set3.push(node9);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch5(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node8 = state.next[j], next = state.next[j + 1];
      nodes.push(node8.name);
      if (dead && !(node8.isText || node8.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute5(attrs[name]);
    }
  }
  return result2;
}
var NodeType6 = function NodeType7(name, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);
  this.defaultAttrs = defaultAttrs(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true }, whitespace: { configurable: true } };
prototypeAccessors$5.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5.isLeaf.get = function() {
  return this.contentMatch == ContentMatch5.empty;
};
prototypeAccessors$5.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
prototypeAccessors$5.whitespace.get = function() {
  return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
};
NodeType6.prototype.hasRequiredAttrs = function hasRequiredAttrs5() {
  for (var n in this.attrs) {
    if (this.attrs[n].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType6.prototype.compatibleContent = function compatibleContent5(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType6.prototype.computeAttrs = function computeAttrs$15(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs(this.attrs, attrs);
  }
};
NodeType6.prototype.create = function create13(attrs, content4, marks6) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node5(this, this.computeAttrs(attrs), Fragment5.from(content4), Mark5.setFrom(marks6));
};
NodeType6.prototype.createChecked = function createChecked5(attrs, content4, marks6) {
  content4 = Fragment5.from(content4);
  if (!this.validContent(content4)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node5(this, this.computeAttrs(attrs), content4, Mark5.setFrom(marks6));
};
NodeType6.prototype.createAndFill = function createAndFill5(attrs, content4, marks6) {
  attrs = this.computeAttrs(attrs);
  content4 = Fragment5.from(content4);
  if (content4.size) {
    var before6 = this.contentMatch.fillBefore(content4);
    if (!before6) {
      return null;
    }
    content4 = before6.append(content4);
  }
  var after6 = this.contentMatch.matchFragment(content4).fillBefore(Fragment5.empty, true);
  if (!after6) {
    return null;
  }
  return new Node5(this, attrs, content4.append(after6), Mark5.setFrom(marks6));
};
NodeType6.prototype.validContent = function validContent5(content4) {
  var result2 = this.contentMatch.matchFragment(content4);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i = 0; i < content4.childCount; i++) {
    if (!this.allowsMarks(content4.child(i).marks)) {
      return false;
    }
  }
  return true;
};
NodeType6.prototype.allowsMarkType = function allowsMarkType5(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType6.prototype.allowsMarks = function allowsMarks5(marks6) {
  if (this.markSet == null) {
    return true;
  }
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      return false;
    }
  }
  return true;
};
NodeType6.prototype.allowedMarks = function allowedMarks5(marks6) {
  if (this.markSet == null) {
    return marks6;
  }
  var copy12;
  for (var i = 0; i < marks6.length; i++) {
    if (!this.allowsMarkType(marks6[i].type)) {
      if (!copy12) {
        copy12 = marks6.slice(0, i);
      }
    } else if (copy12) {
      copy12.push(marks6[i]);
    }
  }
  return !copy12 ? marks6 : copy12.length ? copy12 : Mark5.empty;
};
NodeType6.compile = function compile9(nodes, schema) {
  var result2 = /* @__PURE__ */ Object.create(null);
  nodes.forEach(function(name, spec) {
    return result2[name] = new NodeType6(name, schema, spec);
  });
  var topType = schema.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _ in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType6.prototype, prototypeAccessors$5);
var Attribute5 = function Attribute6(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3 = { isRequired: { configurable: true } };
prototypeAccessors$1$3.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute5.prototype, prototypeAccessors$1$3);
var MarkType5 = function MarkType6(name, rank, schema, spec) {
  this.name = name;
  this.schema = schema;
  this.spec = spec;
  this.attrs = initAttrs(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults2 = defaultAttrs(this.attrs);
  this.instance = defaults2 && new Mark5(this, defaults2);
};
MarkType5.prototype.create = function create14(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark5(this, computeAttrs(this.attrs, attrs));
};
MarkType5.compile = function compile10(marks6, schema) {
  var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
  marks6.forEach(function(name, spec) {
    return result2[name] = new MarkType5(name, rank++, schema, spec);
  });
  return result2;
};
MarkType5.prototype.removeFromSet = function removeFromSet10(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      set3 = set3.slice(0, i).concat(set3.slice(i + 1));
      i--;
    }
  }
  return set3;
};
MarkType5.prototype.isInSet = function isInSet10(set3) {
  for (var i = 0; i < set3.length; i++) {
    if (set3[i].type == this) {
      return set3[i];
    }
  }
};
MarkType5.prototype.excludes = function excludes5(other) {
  return this.excluded.indexOf(other) > -1;
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type4, preserveWhitespace, base2) {
  if (preserveWhitespace != null) {
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  }
  return type4 && type4.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext5 = function NodeContext6(type4, attrs, marks6, pendingMarks, solid, match, options) {
  this.type = type4;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type4.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks6;
  this.activeMarks = Mark5.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext5.prototype.findWrapping = function findWrapping11(node8) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment5.from(node8));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start8 = this.type.contentMatch, wrap2;
      if (wrap2 = start8.findWrapping(node8.type)) {
        this.match = start8;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node8.type);
};
NodeContext5.prototype.finish = function finish9(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) {
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
      }
    }
  }
  var content4 = Fragment5.from(this.content);
  if (!openEnd && this.match) {
    content4 = content4.append(this.match.fillBefore(Fragment5.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content4, this.marks) : content4;
};
NodeContext5.prototype.popFromStashMark = function popFromStashMark5(mark7) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--) {
    if (mark7.eq(this.stashMarks[i])) {
      return this.stashMarks.splice(i, 1)[0];
    }
  }
};
NodeContext5.prototype.applyPending = function applyPending5(nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark7 = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark7.type) : markMayApply(mark7.type, nextType)) && !mark7.isInSet(this.activeMarks)) {
      this.activeMarks = mark7.addToSet(this.activeMarks);
      this.pendingMarks = mark7.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext5.prototype.inlineContext = function inlineContext5(node8) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node8.parentNode && !blockTags.hasOwnProperty(node8.parentNode.nodeName.toLowerCase());
};
var ParseContext5 = function ParseContext6(parser, options, open) {
  this.parser = parser;
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode) {
    topContext = new NodeContext5(topNode.type, topNode.attrs, Mark5.none, Mark5.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open) {
    topContext = new NodeContext5(null, null, Mark5.none, Mark5.none, true, null, topOptions);
  } else {
    topContext = new NodeContext5(parser.schema.topNodeType, null, Mark5.none, Mark5.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6.top.get = function() {
  return this.nodes[this.open];
};
ParseContext5.prototype.addDOM = function addDOM5(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style2 = dom.getAttribute("style");
    var marks6 = style2 ? this.readStyles(parseStyles(style2)) : null, top2 = this.top;
    if (marks6 != null) {
      for (var i = 0; i < marks6.length; i++) {
        this.addPendingMark(marks6[i]);
      }
    }
    this.addElement(dom);
    if (marks6 != null) {
      for (var i$1 = 0; i$1 < marks6.length; i$1++) {
        this.removePendingMark(marks6[i$1], top2);
      }
    }
  }
};
ParseContext5.prototype.addTextNode = function addTextNode5(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext5.prototype.addElement = function addElement5(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync6, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync6 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync6) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext5.prototype.leafFallback = function leafFallback5(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext5.prototype.ignoreFallback = function ignoreFallback5(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext5.prototype.readStyles = function readStyles5(styles) {
  var marks6 = Mark5.none;
  style:
    for (var i = 0; i < styles.length; i += 2) {
      for (var after6 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after6);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks6 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks6);
        if (rule.consuming === false) {
          after6 = rule;
        } else {
          break;
        }
      }
    }
  return marks6;
};
ParseContext5.prototype.addElementByRule = function addElementByRule5(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync6, nodeType2, markType, mark7;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync6 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark7 = markType.create(rule.attrs);
    this.addPendingMark(mark7);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node8) {
      return this$1$1.insertNode(node8);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync6);
  }
  if (sync6) {
    this.sync(startIn);
    this.open--;
  }
  if (mark7) {
    this.removePendingMark(mark7, startIn);
  }
};
ParseContext5.prototype.addAll = function addAll5(parent, sync6, startIndex2, endIndex2) {
  var index6 = startIndex2 || 0;
  for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end7 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end7; dom = dom.nextSibling, ++index6) {
    this.findAtPoint(parent, index6);
    this.addDOM(dom);
    if (sync6 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync6);
    }
  }
  this.findAtPoint(parent, index6);
};
ParseContext5.prototype.findPlace = function findPlace5(node8) {
  var route, sync6;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node8);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync6 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync6);
  for (var i = 0; i < route.length; i++) {
    this.enterInner(route[i], null, false);
  }
  return true;
};
ParseContext5.prototype.insertNode = function insertNode5(node8) {
  if (node8.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node8)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node8.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node8.type);
    }
    var marks6 = top2.activeMarks;
    for (var i = 0; i < node8.marks.length; i++) {
      if (!top2.type || top2.type.allowsMarkType(node8.marks[i].type)) {
        marks6 = node8.marks[i].addToSet(marks6);
      }
    }
    top2.content.push(node8.mark(marks6));
    return true;
  }
  return false;
};
ParseContext5.prototype.enter = function enter6(type4, attrs, preserveWS) {
  var ok5 = this.findPlace(type4.create(attrs));
  if (ok5) {
    this.enterInner(type4, attrs, true, preserveWS);
  }
  return ok5;
};
ParseContext5.prototype.enterInner = function enterInner5(type4, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type4);
  top2.match = top2.match && top2.match.matchType(type4, attrs);
  var options = wsOptionsFor(type4, preserveWS, top2.options);
  if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT;
  }
  this.nodes.push(new NodeContext5(type4, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext5.prototype.closeExtra = function closeExtra5(openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) {
      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext5.prototype.finish = function finish10() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext5.prototype.sync = function sync5(to) {
  for (var i = this.open; i >= 0; i--) {
    if (this.nodes[i] == to) {
      this.open = i;
      return;
    }
  }
};
prototypeAccessors$6.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content4 = this.nodes[i].content;
    for (var j = content4.length - 1; j >= 0; j--) {
      pos += content4[j].nodeSize;
    }
    if (i) {
      pos++;
    }
  }
  return pos;
};
ParseContext5.prototype.findAtPoint = function findAtPoint5(parent, offset6) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == parent && this.find[i].offset == offset6) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext5.prototype.findInside = function findInside5(parent) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        this.find[i].pos = this.currentPos;
      }
    }
  }
};
ParseContext5.prototype.findAround = function findAround5(parent, content4, before6) {
  if (parent != content4 && this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
        var pos = content4.compareDocumentPosition(this.find[i].node);
        if (pos & (before6 ? 2 : 4)) {
          this.find[i].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext5.prototype.findInText = function findInText5(textNode) {
  if (this.find) {
    for (var i = 0; i < this.find.length; i++) {
      if (this.find[i].node == textNode) {
        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }
};
ParseContext5.prototype.matchesContext = function matchesContext5(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part && next.groups.indexOf(part) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext5.prototype.textblockFromContext = function textblockFromContext5() {
  var $context = this.options.context;
  if ($context) {
    for (var d = $context.depth; d >= 0; d--) {
      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type4 = this.parser.schema.nodes[name];
    if (type4.isTextblock && type4.defaultAttrs) {
      return type4;
    }
  }
};
ParseContext5.prototype.addPendingMark = function addPendingMark5(mark7) {
  var found2 = findSameMarkInSet(mark7, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark7.addToSet(this.top.pendingMarks);
};
ParseContext5.prototype.removePendingMark = function removePendingMark5(mark7, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark7);
    if (found2 > -1) {
      level.pendingMarks = mark7.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark7.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark7);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext5.prototype, prototypeAccessors$6);
function normalizeList(dom) {
  for (var child11 = dom.firstChild, prevItem = null; child11; child11 = child11.nextSibling) {
    var name = child11.nodeType == 1 ? child11.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child11);
      child11 = prevItem;
    } else if (name == "li") {
      prevItem = child11;
    } else if (name) {
      prevItem = null;
    }
  }
}
function parseStyles(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style2)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function markMayApply(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref2 = match.edge(i);
        var type4 = ref2.type;
        var next = ref2.next;
        if (type4 == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet(mark7, set3) {
  for (var i = 0; i < set3.length; i++) {
    if (mark7.eq(set3[i])) {
      return set3[i];
    }
  }
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index6, offset6) {
  return index6 + offset6 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult5 {
  constructor(pos, delInfo, recover5) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover5;
  }
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap5 {
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap5.empty)
      return StepMap5.empty;
  }
  recover(value) {
    let diff = 0, index6 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index6; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index6 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start8 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start8 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end7 = start8 + oldSize;
      if (pos <= end7) {
        let side = !oldSize ? assoc : pos == start8 ? -1 : pos == end7 ? 1 : assoc;
        let result2 = start8 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result2;
        let recover5 = pos == (assoc < 0 ? start8 : end7) ? null : makeRecover(i / 3, pos - start8);
        let del2 = pos == start8 ? DEL_AFTER : pos == end7 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start8 : pos != end7)
          del2 |= DEL_SIDE;
        return new MapResult5(result2, del2, recover5);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult5(pos + diff, 0, null);
  }
  touches(pos, recover5) {
    let diff = 0, index6 = recoverIndex(recover5);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start8 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start8 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end7 = start8 + oldSize;
      if (pos <= end7 && i == index6 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start8 = this.ranges[i], oldStart = start8 - (this.inverted ? diff : 0), newStart = start8 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  invert() {
    return new StepMap5(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(n) {
    return n == 0 ? StepMap5.empty : new StepMap5(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap5.empty = new StepMap5([]);
class Mapping5 {
  constructor(maps = [], mirror, from8 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from8;
    this.to = to;
  }
  slice(from8 = 0, to = this.maps.length) {
    return new Mapping5(this.maps, this.mirror, from8, to);
  }
  copy() {
    return new Mapping5(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  appendMap(map30, mirrors) {
    this.to = this.maps.push(map30);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  invert() {
    let inverse = new Mapping5();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map30 = this.maps[i], result2 = map30.mapResult(pos, assoc);
      if (result2.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result2.recover);
          continue;
        }
      }
      delInfo |= result2.delInfo;
      pos = result2.pos;
    }
    return simple ? pos : new MapResult5(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step5 {
  getMap() {
    return StepMap5.empty;
  }
  merge(other) {
    return null;
  }
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type4 = stepsByID[json.stepType];
    if (!type4)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type4.fromJSON(schema, json);
  }
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult5 {
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  static ok(doc2) {
    return new StepResult5(doc2, null);
  }
  static fail(message) {
    return new StepResult5(null, message);
  }
  static fromReplace(doc2, from8, to, slice11) {
    try {
      return StepResult5.ok(doc2.replace(from8, to, slice11));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult5.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child11 = fragment.child(i);
    if (child11.content.size)
      child11 = child11.copy(mapFragment(child11.content, f, child11));
    if (child11.isInline)
      child11 = f(child11, parent, i);
    mapped.push(child11);
  }
  return Fragment5.fromArray(mapped);
}
class AddMarkStep extends Step5 {
  constructor(from8, to, mark7) {
    super();
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice11 = new Slice5(mapFragment(oldSlice.content, (node8, parent2) => {
      if (!node8.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node8;
      return node8.mark(this.mark.addToSet(node8.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult5.fromReplace(doc2, this.from, this.to, slice11);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos)
      return null;
    return new AddMarkStep(from8.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step5.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step5 {
  constructor(from8, to, mark7) {
    super();
    this.from = from8;
    this.to = to;
    this.mark = mark7;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice11 = new Slice5(mapFragment(oldSlice.content, (node8) => {
      return node8.mark(this.mark.removeFromSet(node8.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult5.fromReplace(doc2, this.from, this.to, slice11);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deleted && to.deleted || from8.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from8.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step5.jsonID("removeMark", RemoveMarkStep);
class ReplaceStep extends Step5 {
  constructor(from8, to, slice11, structure = false) {
    super();
    this.from = from8;
    this.to = to;
    this.slice = slice11;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult5.fail("Structure replace would overwrite content");
    return StepResult5.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap5([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from8.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from8.pos, Math.max(from8.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice11 = this.slice.size + other.slice.size == 0 ? Slice5.empty : new Slice5(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice11, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice11 = this.slice.size + other.slice.size == 0 ? Slice5.empty : new Slice5(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice11, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice5.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step5.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step5 {
  constructor(from8, to, gapFrom, gapTo, slice11, insert, structure = false) {
    super();
    this.from = from8;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice11;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult5.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult5.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult5.fail("Content does not fit in gap");
    return StepResult5.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap5([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from8 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from8.deletedAcross && to.deletedAcross || gapFrom < from8.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from8.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice5.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step5.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from8, to) {
  let $from = doc2.resolve(from8), dist = to - from8, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from8, to, mark7) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from8, to, (node8, pos, parent) => {
    if (!node8.isInline)
      return;
    let marks6 = node8.marks;
    if (!mark7.isInSet(marks6) && parent.type.allowsMarkType(mark7.type)) {
      let start8 = Math.max(pos, from8), end7 = Math.min(pos + node8.nodeSize, to);
      let newSet = mark7.addToSet(marks6);
      for (let i = 0; i < marks6.length; i++) {
        if (!marks6[i].isInSet(newSet)) {
          if (removing && removing.to == start8 && removing.mark.eq(marks6[i]))
            removing.to = end7;
          else
            removed.push(removing = new RemoveMarkStep(start8, end7, marks6[i]));
        }
      }
      if (adding && adding.to == start8)
        adding.to = end7;
      else
        added.push(adding = new AddMarkStep(start8, end7, mark7));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from8, to, mark7) {
  let matched = [], step5 = 0;
  tr.doc.nodesBetween(from8, to, (node8, pos) => {
    if (!node8.isInline)
      return;
    step5++;
    let toRemove = null;
    if (mark7 instanceof MarkType5) {
      let set3 = node8.marks, found2;
      while (found2 = mark7.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark7) {
      if (mark7.isInSet(node8.marks))
        toRemove = [mark7];
    } else {
      toRemove = node8.marks;
    }
    if (toRemove && toRemove.length) {
      let end7 = Math.min(pos + node8.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step5 - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end7;
          found2.step = step5;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from8), to: end7, step: step5 });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {
  let node8 = tr.doc.nodeAt(pos);
  let delSteps = [], cur = pos + 1;
  for (let i = 0; i < node8.childCount; i++) {
    let child11 = node8.child(i), end7 = cur + child11.nodeSize;
    let allowed = match.matchType(child11.type);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end7, Slice5.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child11.marks.length; j++)
        if (!parentType.allowsMarkType(child11.marks[j].type))
          tr.step(new RemoveMarkStep(cur, end7, child11.marks[j]));
    }
    cur = end7;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment5.empty, true);
    tr.replace(cur, cur, new Slice5(fill, 0, 0));
  }
  for (let i = delSteps.length - 1; i >= 0; i--)
    tr.step(delSteps[i]);
}
function lift(tr, range3, target) {
  let { $from, $to, depth } = range3;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start8 = gapStart, end7 = gapEnd;
  let before6 = Fragment5.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before6 = Fragment5.from($from.node(d).copy(before6));
      openStart++;
    } else {
      start8--;
    }
  let after6 = Fragment5.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after6 = Fragment5.from($to.node(d).copy(after6));
      openEnd++;
    } else {
      end7++;
    }
  tr.step(new ReplaceAroundStep(start8, end7, gapStart, gapEnd, new Slice5(before6.append(after6), openStart, openEnd), before6.size - openStart, true));
}
function wrap(tr, range3, wrappers) {
  let content4 = Fragment5.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content4.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content4);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content4 = Fragment5.from(wrappers[i].type.create(wrappers[i].attrs, content4));
  }
  let start8 = range3.start, end7 = range3.end;
  tr.step(new ReplaceAroundStep(start8, end7, start8, end7, new Slice5(content4, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from8, to, type4, attrs) {
  if (!type4.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from8, to, (node8, pos) => {
    if (node8.isTextblock && !node8.hasMarkup(type4, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type4)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type4);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node8.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice5(Fragment5.from(type4.create(attrs, null, node8.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc2, pos, type4) {
  let $pos = doc2.resolve(pos), index6 = $pos.index();
  return $pos.parent.canReplaceWith(index6, index6 + 1, type4);
}
function setNodeMarkup(tr, pos, type4, attrs, marks6) {
  let node8 = tr.doc.nodeAt(pos);
  if (!node8)
    throw new RangeError("No node at given position");
  if (!type4)
    type4 = node8.type;
  let newNode = type4.create(attrs, null, marks6 || node8.marks);
  if (node8.isLeaf)
    return tr.replaceWith(pos, pos + node8.nodeSize, newNode);
  if (!type4.validContent(node8.content))
    throw new RangeError("Invalid content for node type " + type4.name);
  tr.step(new ReplaceAroundStep(pos, pos + node8.nodeSize, pos + 1, pos + node8.nodeSize - 1, new Slice5(Fragment5.from(newNode), 0, 0), 1, true));
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before6 = Fragment5.empty, after6 = Fragment5.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before6 = Fragment5.from($pos.node(d).copy(before6));
    let typeAfter = typesAfter && typesAfter[i];
    after6 = Fragment5.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after6) : $pos.node(d).copy(after6));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice5(before6.append(after6), depth, depth), true));
}
function join(tr, pos, depth) {
  let step5 = new ReplaceStep(pos - depth, pos + depth, Slice5.empty, true);
  tr.step(step5);
}
function insertPoint(doc2, pos, nodeType2) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index6 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2))
        return $pos.before(d + 1);
      if (index6 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index6 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index6, index6, nodeType2))
        return $pos.after(d + 1);
      if (index6 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function replaceStep(doc2, from8, to = from8, slice11 = Slice5.empty) {
  if (from8 == to && !slice11.size)
    return null;
  let $from = doc2.resolve(from8), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice11))
    return new ReplaceStep(from8, to, slice11);
  return new Fitter5($from, $to, slice11).fit();
}
function fitsTrivially($from, $to, slice11) {
  return !slice11.openStart && !slice11.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice11.content);
}
class Fitter5 {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment5.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node8 = $from.node(i);
      this.frontier.push({
        type: node8.type,
        match: node8.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment5.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit5 = this.findFittable();
      if (fit5)
        this.placeNodes(fit5);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content4 = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content4.childCount == 1) {
      content4 = content4.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice11 = new Slice5(content4, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice11, placedSize);
    if (slice11.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice11);
    return null;
  }
  findFittable() {
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type: type4, match } = this.frontier[frontierDepth], wrap2, inject2 = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment5.from(first2), false)) : parent && type4.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject: inject2 };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content: content4, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content4, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice5(content4, openStart + 1, Math.max(openEnd, inner.size + openStart >= content4.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content: content4, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content4, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content4.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice5(dropFromFragment(content4, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice5(dropFromFragment(content4, openStart, 1), openStart, openEnd);
    }
  }
  placeNodes({ sliceDepth, frontierDepth, parent, inject: inject2, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice11 = this.unplaced, fragment = parent ? parent.content : slice11.content;
    let openStart = slice11.openStart - sliceDepth;
    let taken = 0, add2 = [];
    let { match, type: type4 } = this.frontier[frontierDepth];
    if (inject2) {
      for (let i = 0; i < inject2.childCount; i++)
        add2.push(inject2.child(i));
      match = match.matchFragment(inject2);
    }
    let openEndCount = fragment.size + sliceDepth - (slice11.content.size - slice11.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add2.push(closeNodeStart(next.mark(type4.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment5.from(add2));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node8 = cur.lastChild;
      this.frontier.push({ type: node8.type, match: node8.contentMatchAt(node8.childCount) });
      cur = node8.content;
    }
    this.unplaced = !toEnd ? new Slice5(dropFromFragment(slice11.content, sliceDepth, taken), slice11.openStart, slice11.openEnd) : sliceDepth == 0 ? Slice5.empty : new Slice5(dropFromFragment(slice11.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice11.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after6 = this.$to.after(depth);
    while (depth > 1 && after6 == this.$to.end(--depth))
      ++after6;
    return after6;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type: type4 } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit5 = contentAfterFits($to, i, type4, match, dropInner);
        if (!fit5)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type5 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type5, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit: fit5, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close6 = this.findCloseLevel($to);
    if (!close6)
      return null;
    while (this.depth > close6.depth)
      this.closeFrontierNode();
    if (close6.fit.childCount)
      this.placed = addToFragment(this.placed, close6.depth, close6.fit);
    $to = close6.move;
    for (let d = close6.depth + 1; d <= $to.depth; d++) {
      let node8 = $to.node(d), add2 = node8.type.contentMatch.fillBefore(node8.content, true, $to.index(d));
      this.openFrontierNode(node8.type, node8.attrs, add2);
    }
    return $to;
  }
  openFrontierNode(type4, attrs = null, content4) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type4);
    this.placed = addToFragment(this.placed, this.depth, Fragment5.from(type4.create(attrs, content4)));
    this.frontier.push({ type: type4, match: type4.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add2 = open.match.fillBefore(Fragment5.empty, true);
    if (add2.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content4) {
  if (depth == 0)
    return fragment.append(content4);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content4)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node8, openStart, openEnd) {
  if (openStart <= 0)
    return node8;
  let frag = node8.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node8.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node8.type.contentMatch.matchFragment(frag).fillBefore(Fragment5.empty, true));
  }
  return node8.copy(frag);
}
function contentAfterFits($to, depth, type4, match, open) {
  let node8 = $to.node(depth), index6 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index6 == node8.childCount && !type4.compatibleContent(node8.type))
    return null;
  let fit5 = match.fillBefore(node8.content, true, index6);
  return fit5 && !invalidMarks(type4, node8.content, index6) ? fit5 : null;
}
function invalidMarks(type4, fragment, start8) {
  for (let i = start8; i < fragment.childCount; i++)
    if (!type4.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type4) {
  return type4.spec.defining || type4.spec.definingForContent;
}
function replaceRange(tr, from8, to, slice11) {
  if (!slice11.size)
    return tr.deleteRange(from8, to);
  let $from = tr.doc.resolve(from8), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice11))
    return tr.step(new ReplaceStep(from8, to, slice11));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice11.openStart;
  for (let content4 = slice11.content, i = 0; ; i++) {
    let node8 = content4.firstChild;
    leftNodes.push(node8);
    if (i == slice11.openStart)
      break;
    content4 = node8.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let type4 = leftNodes[d].type, def = definesContent(type4);
    if (def && $from.node(preferredTargetIndex).type != type4)
      preferredDepth = d;
    else if (def || !type4.isTextblock)
      break;
  }
  for (let j = slice11.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice11.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index6 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index6, index6, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice5(closeFragment(slice11.content, 0, slice11.openStart, openDepth), openDepth, slice11.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from8, to, slice11);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from8 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start8 = match.fillBefore(fragment).append(fragment);
    fragment = start8.append(match.matchFragment(start8).fillBefore(Fragment5.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from8, to, node8) {
  if (!node8.isInline && from8 == to && tr.doc.resolve(from8).parent.content.size) {
    let point = insertPoint(tr.doc, from8, node8.type);
    if (point != null)
      from8 = to = point;
  }
  tr.replaceRange(from8, to, new Slice5(Fragment5.from(node8), 0, 0));
}
function deleteRange(tr, from8, to) {
  let $from = tr.doc.resolve(from8), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from8 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr.delete($from.before(d), to);
  }
  tr.delete(from8, to);
}
function coveredDepths($from, $to) {
  let result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start8 = $from.start(d);
    if (start8 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start8 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start8 - 1)
      result2.push(d);
  }
  return result2;
}
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err6 = Error.call(this, message);
  err6.__proto__ = TransformError2.prototype;
  return err6;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform5 {
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping5();
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(step5) {
    let result2 = this.maybeStep(step5);
    if (result2.failed)
      throw new TransformError(result2.failed);
    return this;
  }
  maybeStep(step5) {
    let result2 = step5.apply(this.doc);
    if (!result2.failed)
      this.addStep(step5, result2.doc);
    return result2;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  addStep(step5, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step5);
    this.mapping.appendMap(step5.getMap());
    this.doc = doc2;
  }
  replace(from8, to = from8, slice11 = Slice5.empty) {
    let step5 = replaceStep(this.doc, from8, to, slice11);
    if (step5)
      this.step(step5);
    return this;
  }
  replaceWith(from8, to, content4) {
    return this.replace(from8, to, new Slice5(Fragment5.from(content4), 0, 0));
  }
  delete(from8, to) {
    return this.replace(from8, to, Slice5.empty);
  }
  insert(pos, content4) {
    return this.replaceWith(pos, pos, content4);
  }
  replaceRange(from8, to, slice11) {
    replaceRange(this, from8, to, slice11);
    return this;
  }
  replaceRangeWith(from8, to, node8) {
    replaceRangeWith(this, from8, to, node8);
    return this;
  }
  deleteRange(from8, to) {
    deleteRange(this, from8, to);
    return this;
  }
  lift(range3, target) {
    lift(this, range3, target);
    return this;
  }
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  wrap(range3, wrappers) {
    wrap(this, range3, wrappers);
    return this;
  }
  setBlockType(from8, to = from8, type4, attrs = null) {
    setBlockType(this, from8, to, type4, attrs);
    return this;
  }
  setNodeMarkup(pos, type4, attrs = null, marks6 = []) {
    setNodeMarkup(this, pos, type4, attrs, marks6);
    return this;
  }
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  addMark(from8, to, mark7) {
    addMark(this, from8, to, mark7);
    return this;
  }
  removeMark(from8, to, mark7) {
    removeMark(this, from8, to, mark7);
    return this;
  }
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
var readFromCache, addToCache;
if (typeof WeakMap != "undefined") {
  var cache = /* @__PURE__ */ new WeakMap();
  readFromCache = function(key2) {
    return cache.get(key2);
  };
  addToCache = function(key2, value) {
    cache.set(key2, value);
    return value;
  };
} else {
  var cache$1 = [], cacheSize = 10, cachePos = 0;
  readFromCache = function(key2) {
    for (var i = 0; i < cache$1.length; i += 2) {
      if (cache$1[i] == key2) {
        return cache$1[i + 1];
      }
    }
  };
  addToCache = function(key2, value) {
    if (cachePos == cacheSize) {
      cachePos = 0;
    }
    cache$1[cachePos++] = key2;
    return cache$1[cachePos++] = value;
  };
}
var Rect = function Rect2(left2, top2, right2, bottom2) {
  this.left = left2;
  this.top = top2;
  this.right = right2;
  this.bottom = bottom2;
};
var TableMap = function TableMap2(width, height, map30, problems) {
  this.width = width;
  this.height = height;
  this.map = map30;
  this.problems = problems;
};
TableMap.prototype.findCell = function findCell(pos) {
  for (var i = 0; i < this.map.length; i++) {
    var curPos = this.map[i];
    if (curPos != pos) {
      continue;
    }
    var left2 = i % this.width, top2 = i / this.width | 0;
    var right2 = left2 + 1, bottom2 = top2 + 1;
    for (var j = 1; right2 < this.width && this.map[i + j] == curPos; j++) {
      right2++;
    }
    for (var j$1 = 1; bottom2 < this.height && this.map[i + this.width * j$1] == curPos; j$1++) {
      bottom2++;
    }
    return new Rect(left2, top2, right2, bottom2);
  }
  throw new RangeError("No cell with offset " + pos + " found");
};
TableMap.prototype.colCount = function colCount(pos) {
  for (var i = 0; i < this.map.length; i++) {
    if (this.map[i] == pos) {
      return i % this.width;
    }
  }
  throw new RangeError("No cell with offset " + pos + " found");
};
TableMap.prototype.nextCell = function nextCell(pos, axis, dir) {
  var ref2 = this.findCell(pos);
  var left2 = ref2.left;
  var right2 = ref2.right;
  var top2 = ref2.top;
  var bottom2 = ref2.bottom;
  if (axis == "horiz") {
    if (dir < 0 ? left2 == 0 : right2 == this.width) {
      return null;
    }
    return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
  } else {
    if (dir < 0 ? top2 == 0 : bottom2 == this.height) {
      return null;
    }
    return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
  }
};
TableMap.prototype.rectBetween = function rectBetween(a, b) {
  var ref2 = this.findCell(a);
  var leftA = ref2.left;
  var rightA = ref2.right;
  var topA = ref2.top;
  var bottomA = ref2.bottom;
  var ref$1 = this.findCell(b);
  var leftB = ref$1.left;
  var rightB = ref$1.right;
  var topB = ref$1.top;
  var bottomB = ref$1.bottom;
  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));
};
TableMap.prototype.cellsInRect = function cellsInRect(rect) {
  var result2 = [], seen = {};
  for (var row = rect.top; row < rect.bottom; row++) {
    for (var col = rect.left; col < rect.right; col++) {
      var index6 = row * this.width + col, pos = this.map[index6];
      if (seen[pos]) {
        continue;
      }
      seen[pos] = true;
      if ((col != rect.left || !col || this.map[index6 - 1] != pos) && (row != rect.top || !row || this.map[index6 - this.width] != pos)) {
        result2.push(pos);
      }
    }
  }
  return result2;
};
TableMap.prototype.positionAt = function positionAt(row, col, table2) {
  for (var i = 0, rowStart = 0; ; i++) {
    var rowEnd = rowStart + table2.child(i).nodeSize;
    if (i == row) {
      var index6 = col + row * this.width, rowEndIndex = (row + 1) * this.width;
      while (index6 < rowEndIndex && this.map[index6] < rowStart) {
        index6++;
      }
      return index6 == rowEndIndex ? rowEnd - 1 : this.map[index6];
    }
    rowStart = rowEnd;
  }
};
TableMap.get = function get3(table2) {
  return readFromCache(table2) || addToCache(table2, computeMap(table2));
};
function computeMap(table2) {
  if (table2.type.spec.tableRole != "table") {
    throw new RangeError("Not a table node: " + table2.type.name);
  }
  var width = findWidth(table2), height = table2.childCount;
  var map30 = [], mapPos = 0, problems = null, colWidths = [];
  for (var i = 0, e = width * height; i < e; i++) {
    map30[i] = 0;
  }
  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table2.child(row);
    pos++;
    for (var i$1 = 0; ; i$1++) {
      while (mapPos < map30.length && map30[mapPos] != 0) {
        mapPos++;
      }
      if (i$1 == rowNode.childCount) {
        break;
      }
      var cellNode = rowNode.child(i$1);
      var ref2 = cellNode.attrs;
      var colspan = ref2.colspan;
      var rowspan = ref2.rowspan;
      var colwidth = ref2.colwidth;
      for (var h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({ type: "overlong_rowspan", pos, n: rowspan - h2 });
          break;
        }
        var start8 = mapPos + h2 * width;
        for (var w = 0; w < colspan; w++) {
          if (map30[start8 + w] == 0) {
            map30[start8 + w] = pos;
          } else {
            (problems || (problems = [])).push({ type: "collision", row, pos, n: colspan - w });
          }
          var colW = colwidth && colwidth[w];
          if (colW) {
            var widthIndex = (start8 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width, missing = 0;
    while (mapPos < expectedPos) {
      if (map30[mapPos++] == 0) {
        missing++;
      }
    }
    if (missing) {
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    }
    pos++;
  }
  var tableMap = new TableMap(width, height, map30, problems), badWidths = false;
  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2) {
    if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) {
      badWidths = true;
    }
  }
  if (badWidths) {
    findBadColWidths(tableMap, colWidths, table2);
  }
  return tableMap;
}
function findWidth(table2) {
  var width = -1, hasRowSpan = false;
  for (var row = 0; row < table2.childCount; row++) {
    var rowNode = table2.child(row), rowWidth = 0;
    if (hasRowSpan) {
      for (var j = 0; j < row; j++) {
        var prevRow = table2.child(j);
        for (var i = 0; i < prevRow.childCount; i++) {
          var cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) {
            rowWidth += cell.attrs.colspan;
          }
        }
      }
    }
    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {
      var cell$1 = rowNode.child(i$1);
      rowWidth += cell$1.attrs.colspan;
      if (cell$1.attrs.rowspan > 1) {
        hasRowSpan = true;
      }
    }
    if (width == -1) {
      width = rowWidth;
    } else if (width != rowWidth) {
      width = Math.max(width, rowWidth);
    }
  }
  return width;
}
function findBadColWidths(map30, colWidths, table2) {
  if (!map30.problems) {
    map30.problems = [];
  }
  for (var i = 0, seen = {}; i < map30.map.length; i++) {
    var pos = map30.map[i];
    if (seen[pos]) {
      continue;
    }
    seen[pos] = true;
    var node8 = table2.nodeAt(pos), updated = null;
    for (var j = 0; j < node8.attrs.colspan; j++) {
      var col = (i + j) % map30.width, colWidth = colWidths[col * 2];
      if (colWidth != null && (!node8.attrs.colwidth || node8.attrs.colwidth[j] != colWidth)) {
        (updated || (updated = freshColWidth(node8.attrs)))[j] = colWidth;
      }
    }
    if (updated) {
      map30.problems.unshift({ type: "colwidth mismatch", pos, colwidth: updated });
    }
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) {
    return attrs.colwidth.slice();
  }
  var result2 = [];
  for (var i = 0; i < attrs.colspan; i++) {
    result2.push(0);
  }
  return result2;
}
function tableNodeTypes(schema) {
  var result2 = schema.cached.tableNodeTypes;
  if (!result2) {
    result2 = schema.cached.tableNodeTypes = {};
    for (var name in schema.nodes) {
      var type4 = schema.nodes[name], role = type4.spec.tableRole;
      if (role) {
        result2[role] = type4;
      }
    }
  }
  return result2;
}
var key = new PluginKey2("selectingCells");
function cellAround($pos) {
  for (var d = $pos.depth - 1; d > 0; d--) {
    if ($pos.node(d).type.spec.tableRole == "row") {
      return $pos.node(0).resolve($pos.before(d + 1));
    }
  }
  return null;
}
function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) {
    var role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") {
      return $pos.node(d);
    }
  }
  return null;
}
function isInTable(state) {
  var $head = state.selection.$head;
  for (var d = $head.depth; d > 0; d--) {
    if ($head.node(d).type.spec.tableRole == "row") {
      return true;
    }
  }
  return false;
}
function selectionCell(state) {
  var sel = state.selection;
  if (sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  return cellAround(sel.$head) || cellNear(sel.$head);
}
function cellNear($pos) {
  for (var after6 = $pos.nodeAfter, pos = $pos.pos; after6; after6 = after6.firstChild, pos++) {
    var role = after6.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") {
      return $pos.doc.resolve(pos);
    }
  }
  for (var before6 = $pos.nodeBefore, pos$1 = $pos.pos; before6; before6 = before6.lastChild, pos$1--) {
    var role$1 = before6.type.spec.tableRole;
    if (role$1 == "cell" || role$1 == "header_cell") {
      return $pos.doc.resolve(pos$1 - before6.nodeSize);
    }
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($a, $b) {
  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);
}
function nextCell2($pos, axis, dir) {
  var start8 = $pos.start(-1), map30 = TableMap.get($pos.node(-1));
  var moved = map30.nextCell($pos.pos - start8, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(start8 + moved);
}
function setAttr(attrs, name, value) {
  var result2 = {};
  for (var prop in attrs) {
    result2[prop] = attrs[prop];
  }
  result2[name] = value;
  return result2;
}
function removeColSpan(attrs, pos, n) {
  if (n === void 0)
    n = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan - n);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    result2.colwidth.splice(pos, n);
    if (!result2.colwidth.some(function(w) {
      return w > 0;
    })) {
      result2.colwidth = null;
    }
  }
  return result2;
}
function addColSpan(attrs, pos, n) {
  if (n === void 0)
    n = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan + n);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    for (var i = 0; i < n; i++) {
      result2.colwidth.splice(pos, 0, 0);
    }
  }
  return result2;
}
function columnIsHeader(map30, table2, col) {
  var headerCell = tableNodeTypes(table2.type.schema).header_cell;
  for (var row = 0; row < map30.height; row++) {
    if (table2.nodeAt(map30.map[col + row * map30.width]).type != headerCell) {
      return false;
    }
  }
  return true;
}
var CellSelection = /* @__PURE__ */ function(Selection5) {
  function CellSelection2($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var table2 = $anchorCell.node(-1), map30 = TableMap.get(table2), start8 = $anchorCell.start(-1);
    var rect = map30.rectBetween($anchorCell.pos - start8, $headCell.pos - start8);
    var doc2 = $anchorCell.node(0);
    var cells = map30.cellsInRect(rect).filter(function(p) {
      return p != $headCell.pos - start8;
    });
    cells.unshift($headCell.pos - start8);
    var ranges = cells.map(function(pos) {
      var cell = table2.nodeAt(pos), from8 = pos + start8 + 1;
      return new SelectionRange$2(doc2.resolve(from8), doc2.resolve(from8 + cell.content.size));
    });
    Selection5.call(this, ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  if (Selection5)
    CellSelection2.__proto__ = Selection5;
  CellSelection2.prototype = Object.create(Selection5 && Selection5.prototype);
  CellSelection2.prototype.constructor = CellSelection2;
  CellSelection2.prototype.map = function map30(doc2, mapping) {
    var $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    var $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection()) {
        return CellSelection2.rowSelection($anchorCell, $headCell);
      } else if (tableChanged && this.isColSelection()) {
        return CellSelection2.colSelection($anchorCell, $headCell);
      } else {
        return new CellSelection2($anchorCell, $headCell);
      }
    }
    return TextSelection$2.between($anchorCell, $headCell);
  };
  CellSelection2.prototype.content = function content4() {
    var table2 = this.$anchorCell.node(-1), map30 = TableMap.get(table2), start8 = this.$anchorCell.start(-1);
    var rect = map30.rectBetween(this.$anchorCell.pos - start8, this.$headCell.pos - start8);
    var seen = {}, rows = [];
    for (var row = rect.top; row < rect.bottom; row++) {
      var rowContent = [];
      for (var index6 = row * map30.width + rect.left, col = rect.left; col < rect.right; col++, index6++) {
        var pos = map30.map[index6];
        if (!seen[pos]) {
          seen[pos] = true;
          var cellRect = map30.findCell(pos), cell = table2.nodeAt(pos);
          var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
          if (extraLeft > 0 || extraRight > 0) {
            var attrs = cell.attrs;
            if (extraLeft > 0) {
              attrs = removeColSpan(attrs, 0, extraLeft);
            }
            if (extraRight > 0) {
              attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
            }
            if (cellRect.left < rect.left) {
              cell = cell.type.createAndFill(attrs);
            } else {
              cell = cell.type.create(attrs, cell.content);
            }
          }
          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
            var attrs$1 = setAttr(cell.attrs, "rowspan", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));
            if (cellRect.top < rect.top) {
              cell = cell.type.createAndFill(attrs$1);
            } else {
              cell = cell.type.create(attrs$1, cell.content);
            }
          }
          rowContent.push(cell);
        }
      }
      rows.push(table2.child(row).copy(Fragment$3.from(rowContent)));
    }
    var fragment = this.isColSelection() && this.isRowSelection() ? table2 : rows;
    return new Slice$3(Fragment$3.from(fragment), 1, 1);
  };
  CellSelection2.prototype.replace = function replace5(tr, content4) {
    if (content4 === void 0)
      content4 = Slice$3.empty;
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var ref2 = ranges[i];
      var $from = ref2.$from;
      var $to = ref2.$to;
      var mapping = tr.mapping.slice(mapFrom);
      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice$3.empty : content4);
    }
    var sel = Selection5.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
    if (sel) {
      tr.setSelection(sel);
    }
  };
  CellSelection2.prototype.replaceWith = function replaceWith4(tr, node8) {
    this.replace(tr, new Slice$3(Fragment$3.from(node8), 0, 0));
  };
  CellSelection2.prototype.forEachCell = function forEachCell(f) {
    var table2 = this.$anchorCell.node(-1), map30 = TableMap.get(table2), start8 = this.$anchorCell.start(-1);
    var cells = map30.cellsInRect(map30.rectBetween(this.$anchorCell.pos - start8, this.$headCell.pos - start8));
    for (var i = 0; i < cells.length; i++) {
      f(table2.nodeAt(cells[i]), start8 + cells[i]);
    }
  };
  CellSelection2.prototype.isColSelection = function isColSelection() {
    var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) {
      return false;
    }
    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan, headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;
  };
  CellSelection2.colSelection = function colSelection($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var map30 = TableMap.get($anchorCell.node(-1)), start8 = $anchorCell.start(-1);
    var anchorRect = map30.findCell($anchorCell.pos - start8), headRect = map30.findCell($headCell.pos - start8);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0) {
        $anchorCell = doc2.resolve(start8 + map30.map[anchorRect.left]);
      }
      if (headRect.bottom < map30.height) {
        $headCell = doc2.resolve(start8 + map30.map[map30.width * (map30.height - 1) + headRect.right - 1]);
      }
    } else {
      if (headRect.top > 0) {
        $headCell = doc2.resolve(start8 + map30.map[headRect.left]);
      }
      if (anchorRect.bottom < map30.height) {
        $anchorCell = doc2.resolve(start8 + map30.map[map30.width * (map30.height - 1) + anchorRect.right - 1]);
      }
    }
    return new CellSelection2($anchorCell, $headCell);
  };
  CellSelection2.prototype.isRowSelection = function isRowSelection() {
    var map30 = TableMap.get(this.$anchorCell.node(-1)), start8 = this.$anchorCell.start(-1);
    var anchorLeft = map30.colCount(this.$anchorCell.pos - start8), headLeft = map30.colCount(this.$headCell.pos - start8);
    if (Math.min(anchorLeft, headLeft) > 0) {
      return false;
    }
    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan, headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map30.width;
  };
  CellSelection2.prototype.eq = function eq29(other) {
    return other instanceof CellSelection2 && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  };
  CellSelection2.rowSelection = function rowSelection($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var map30 = TableMap.get($anchorCell.node(-1)), start8 = $anchorCell.start(-1);
    var anchorRect = map30.findCell($anchorCell.pos - start8), headRect = map30.findCell($headCell.pos - start8);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0) {
        $anchorCell = doc2.resolve(start8 + map30.map[anchorRect.top * map30.width]);
      }
      if (headRect.right < map30.width) {
        $headCell = doc2.resolve(start8 + map30.map[map30.width * (headRect.top + 1) - 1]);
      }
    } else {
      if (headRect.left > 0) {
        $headCell = doc2.resolve(start8 + map30.map[headRect.top * map30.width]);
      }
      if (anchorRect.right < map30.width) {
        $anchorCell = doc2.resolve(start8 + map30.map[map30.width * (anchorRect.top + 1) - 1]);
      }
    }
    return new CellSelection2($anchorCell, $headCell);
  };
  CellSelection2.prototype.toJSON = function toJSON28() {
    return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos };
  };
  CellSelection2.fromJSON = function fromJSON31(doc2, json) {
    return new CellSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  CellSelection2.create = function create15(doc2, anchorCell, headCell) {
    if (headCell === void 0)
      headCell = anchorCell;
    return new CellSelection2(doc2.resolve(anchorCell), doc2.resolve(headCell));
  };
  CellSelection2.prototype.getBookmark = function getBookmark4() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  };
  return CellSelection2;
}(Selection$2);
CellSelection.prototype.visible = false;
Selection$2.jsonID("cell", CellSelection);
var CellBookmark = function CellBookmark2(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
CellBookmark.prototype.map = function map28(mapping) {
  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
};
CellBookmark.prototype.resolve = function resolve20(doc2) {
  var $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
  if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) {
    return new CellSelection($anchorCell, $headCell);
  } else {
    return Selection$2.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) {
    return null;
  }
  var cells = [];
  state.selection.forEachCell(function(node8, pos) {
    cells.push(Decoration2.node(pos, pos + node8.nodeSize, { class: "selectedCell" }));
  });
  return DecorationSet2.create(state.doc, cells);
}
function isCellBoundarySelection(ref2) {
  var $from = ref2.$from;
  var $to = ref2.$to;
  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) {
    return false;
  }
  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++) {
    if ($from.after(depth + 1) < $from.end(depth)) {
      break;
    }
  }
  for (var d = $to.depth; d >= 0; d--, beforeTo--) {
    if ($to.before(d + 1) > $to.start(d)) {
      break;
    }
  }
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells(ref2) {
  var $from = ref2.$from;
  var $to = ref2.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  for (var i = $from.depth; i > 0; i--) {
    var node8 = $from.node(i);
    if (node8.type.spec.tableRole === "cell" || node8.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node8;
      break;
    }
  }
  for (var i$1 = $to.depth; i$1 > 0; i$1--) {
    var node$1 = $to.node(i$1);
    if (node$1.type.spec.tableRole === "cell" || node$1.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node$1;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  var sel = (tr || state).selection, doc2 = (tr || state).doc, normalize2, role;
  if (sel instanceof NodeSelection$2 && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      var $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map30 = TableMap.get(sel.node), start8 = sel.from + 1;
      var lastCell = start8 + map30.map[map30.width * map30.height - 1];
      normalize2 = CellSelection.create(doc2, start8 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection$2 && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection$2.create(doc2, sel.from);
  } else if (sel instanceof TextSelection$2 && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection$2.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) {
    (tr || (tr = state.tr)).setSelection(normalize2);
  }
  return tr;
}
function pastedCells(slice11) {
  if (!slice11.size) {
    return null;
  }
  var content4 = slice11.content;
  var openStart = slice11.openStart;
  var openEnd = slice11.openEnd;
  while (content4.childCount == 1 && (openStart > 0 && openEnd > 0 || content4.firstChild.type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content4 = content4.firstChild.content;
  }
  var first2 = content4.firstChild, role = first2.type.spec.tableRole;
  var schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (var i = 0; i < content4.childCount; i++) {
      var cells = content4.child(i).content;
      var left2 = i ? 0 : Math.max(0, openStart - 1);
      var right2 = i < content4.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left2 || right2) {
        cells = fitSlice(tableNodeTypes(schema).row, new Slice$3(cells, left2, right2)).content;
      }
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice$3(content4, openStart, openEnd)).content : content4);
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  var widths = [];
  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    for (var j = row.childCount - 1; j >= 0; j--) {
      var ref2 = row.child(j).attrs;
      var rowspan = ref2.rowspan;
      var colspan = ref2.colspan;
      for (var r = i; r < i + rowspan; r++) {
        widths[r] = (widths[r] || 0) + colspan;
      }
    }
  }
  var width = 0;
  for (var r$1 = 0; r$1 < widths.length; r$1++) {
    width = Math.max(width, widths[r$1]);
  }
  for (var r$2 = 0; r$2 < widths.length; r$2++) {
    if (r$2 >= rows.length) {
      rows.push(Fragment$3.empty);
    }
    if (widths[r$2] < width) {
      var empty2 = tableNodeTypes(schema).cell.createAndFill(), cells = [];
      for (var i$1 = widths[r$2]; i$1 < width; i$1++) {
        cells.push(empty2);
      }
      rows[r$2] = rows[r$2].append(Fragment$3.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType2, slice11) {
  var node8 = nodeType2.createAndFill();
  var tr = new Transform5(node8).replace(0, node8.content.size, slice11);
  return tr.doc;
}
function clipCells(ref2, newWidth, newHeight) {
  var width = ref2.width;
  var height = ref2.height;
  var rows = ref2.rows;
  if (width != newWidth) {
    var added = [], newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var frag = rows[row], cells = [];
      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {
        var cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth) {
          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        }
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j = 1; j < cell.attrs.rowspan; j++) {
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
        }
      }
      newRows.push(Fragment$3.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    var newRows$1 = [];
    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {
      var cells$1 = [], source = rows[i$1 % height];
      for (var j$1 = 0; j$1 < source.childCount; j$1++) {
        var cell$1 = source.child(j$1);
        if (row$1 + cell$1.attrs.rowspan > newHeight) {
          cell$1 = cell$1.type.create(setAttr(cell$1.attrs, "rowspan", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content);
        }
        cells$1.push(cell$1);
      }
      newRows$1.push(Fragment$3.from(cells$1));
    }
    rows = newRows$1;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map30, table2, start8, width, height, mapFrom) {
  var schema = tr.doc.type.schema, types2 = tableNodeTypes(schema), empty2, emptyHead;
  if (width > map30.width) {
    for (var row = 0, rowEnd = 0; row < map30.height; row++) {
      var rowNode = table2.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [], add2 = void 0;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types2.cell) {
        add2 = empty2 || (empty2 = types2.cell.createAndFill());
      } else {
        add2 = emptyHead || (emptyHead = types2.header_cell.createAndFill());
      }
      for (var i = map30.width; i < width; i++) {
        cells.push(add2);
      }
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start8), cells);
    }
  }
  if (height > map30.height) {
    var cells$1 = [];
    for (var i$1 = 0, start$1 = (map30.height - 1) * map30.width; i$1 < Math.max(map30.width, width); i$1++) {
      var header = i$1 >= map30.width ? false : table2.nodeAt(map30.map[start$1 + i$1]).type == types2.header_cell;
      cells$1.push(header ? emptyHead || (emptyHead = types2.header_cell.createAndFill()) : empty2 || (empty2 = types2.cell.createAndFill()));
    }
    var emptyRow = types2.row.create(null, Fragment$3.from(cells$1)), rows = [];
    for (var i$2 = map30.height; i$2 < height; i$2++) {
      rows.push(emptyRow);
    }
    tr.insert(tr.mapping.slice(mapFrom).map(start8 + table2.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map30, table2, start8, left2, right2, top2, mapFrom) {
  if (top2 == 0 || top2 == map30.height) {
    return false;
  }
  var found2 = false;
  for (var col = left2; col < right2; col++) {
    var index6 = top2 * map30.width + col, pos = map30.map[index6];
    if (map30.map[index6 - map30.width] == pos) {
      found2 = true;
      var cell = table2.nodeAt(pos);
      var ref2 = map30.findCell(pos);
      var cellTop = ref2.top;
      var cellLeft = ref2.left;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start8), null, setAttr(cell.attrs, "rowspan", top2 - cellTop));
      tr.insert(tr.mapping.slice(mapFrom).map(map30.positionAt(top2, cellLeft, table2)), cell.type.createAndFill(setAttr(cell.attrs, "rowspan", cellTop + cell.attrs.rowspan - top2)));
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr, map30, table2, start8, top2, bottom2, left2, mapFrom) {
  if (left2 == 0 || left2 == map30.width) {
    return false;
  }
  var found2 = false;
  for (var row = top2; row < bottom2; row++) {
    var index6 = row * map30.width + left2, pos = map30.map[index6];
    if (map30.map[index6 - 1] == pos) {
      found2 = true;
      var cell = table2.nodeAt(pos), cellLeft = map30.colCount(pos);
      var updatePos = tr.mapping.slice(mapFrom).map(pos + start8);
      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left2 - cellLeft, cell.attrs.colspan - (left2 - cellLeft)));
      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left2 - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state, dispatch2, tableStart, rect, cells) {
  var table2 = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map30 = TableMap.get(table2);
  var top2 = rect.top;
  var left2 = rect.left;
  var right2 = left2 + cells.width, bottom2 = top2 + cells.height;
  var tr = state.tr, mapFrom = 0;
  function recomp() {
    table2 = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    map30 = TableMap.get(table2);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map30, table2, tableStart, right2, bottom2, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map30, table2, tableStart, left2, right2, top2, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map30, table2, tableStart, left2, right2, bottom2, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map30, table2, tableStart, top2, bottom2, left2, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map30, table2, tableStart, top2, bottom2, right2, mapFrom)) {
    recomp();
  }
  for (var row = top2; row < bottom2; row++) {
    var from8 = map30.positionAt(row, left2, table2), to = map30.positionAt(row, right2, table2);
    tr.replace(tr.mapping.slice(mapFrom).map(from8 + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice$3(cells.rows[row - top2], 0, 0));
  }
  recomp();
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map30.positionAt(top2, left2, table2)), tr.doc.resolve(tableStart + map30.positionAt(bottom2 - 1, right2 - 1, table2))));
  dispatch2(tr);
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  "Backspace": deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  "Delete": deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch2, selection) {
  if (selection.eq(state.selection)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(selection).scrollIntoView());
  }
  return true;
}
function arrow(axis, dir) {
  return function(state, dispatch2, view) {
    var sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(state, dispatch2, Selection$2.near(sel.$headCell, dir));
    }
    if (axis != "horiz" && !sel.empty) {
      return false;
    }
    var end7 = atEndOfCell(view, axis, dir);
    if (end7 == null) {
      return false;
    }
    if (axis == "horiz") {
      return maybeSetSelection(state, dispatch2, Selection$2.near(state.doc.resolve(sel.head + dir), dir));
    } else {
      var $cell = state.doc.resolve(end7), $next = nextCell2($cell, axis, dir), newSel;
      if ($next) {
        newSel = Selection$2.near($next, 1);
      } else if (dir < 0) {
        newSel = Selection$2.near(state.doc.resolve($cell.before(-1)), -1);
      } else {
        newSel = Selection$2.near(state.doc.resolve($cell.after(-1)), 1);
      }
      return maybeSetSelection(state, dispatch2, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return function(state, dispatch2, view) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      var end7 = atEndOfCell(view, axis, dir);
      if (end7 == null) {
        return false;
      }
      sel = new CellSelection(state.doc.resolve(end7));
    }
    var $head = nextCell2(sel.$headCell, axis, dir);
    if (!$head) {
      return false;
    }
    return maybeSetSelection(state, dispatch2, new CellSelection(sel.$anchorCell, $head));
  };
}
function deleteCellSelection(state, dispatch2) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection)) {
    return false;
  }
  if (dispatch2) {
    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function(cell, pos) {
      if (!cell.content.eq(baseContent)) {
        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice$3(baseContent, 0, 0));
      }
    });
    if (tr.docChanged) {
      dispatch2(tr);
    }
  }
  return true;
}
function handleTripleClick(view, pos) {
  var doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
  if (!$cell) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice11) {
  if (!isInTable(view.state)) {
    return false;
  }
  var cells = pastedCells(slice11), sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells) {
      cells = { width: 1, height: 1, rows: [Fragment$3.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice11))] };
    }
    var table2 = sel.$anchorCell.node(-1), start8 = sel.$anchorCell.start(-1);
    var rect = TableMap.get(table2).rectBetween(sel.$anchorCell.pos - start8, sel.$headCell.pos - start8);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start8, rect, cells);
    return true;
  } else if (cells) {
    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);
    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  if (startEvent.ctrlKey || startEvent.metaKey) {
    return;
  }
  var startDOMCell = domInCell(view, startEvent.target), $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    var $head = cellUnderMouse(view, event);
    var starting = key.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) {
        $head = $anchor2;
      } else {
        return;
      }
    }
    var selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var tr = view.state.tr.setSelection(selection);
      if (starting) {
        tr.setMeta(key, $anchor2.pos);
      }
      view.dispatch(tr);
    }
  }
  function stop2() {
    view.root.removeEventListener("mouseup", stop2);
    view.root.removeEventListener("dragstart", stop2);
    view.root.removeEventListener("mousemove", move2);
    if (key.getState(view.state) != null) {
      view.dispatch(view.state.tr.setMeta(key, -1));
    }
  }
  function move2(event) {
    var anchor = key.getState(view.state), $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) {
        return stop2();
      }
    }
    if ($anchor2) {
      setCellSelection($anchor2, event);
    }
  }
  view.root.addEventListener("mouseup", stop2);
  view.root.addEventListener("dragstart", stop2);
  view.root.addEventListener("mousemove", move2);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection$2)) {
    return null;
  }
  var ref2 = view.state.selection;
  var $head = ref2.$head;
  for (var d = $head.depth - 1; d >= 0; d--) {
    var parent = $head.node(d), index6 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index6 != (dir < 0 ? 0 : parent.childCount)) {
      return null;
    }
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      var cellPos = $head.before(d);
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
}
function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!mousePos) {
    return null;
  }
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var fixTablesKey = new PluginKey2("fix-tables");
function changedDescendants(old, cur, offset6, f) {
  var oldSize = old.childCount, curSize = cur.childCount;
  outer:
    for (var i = 0, j = 0; i < curSize; i++) {
      var child11 = cur.child(i);
      for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
        if (old.child(scan) == child11) {
          j = scan + 1;
          offset6 += child11.nodeSize;
          continue outer;
        }
      }
      f(child11, offset6);
      if (j < oldSize && old.child(j).sameMarkup(child11)) {
        changedDescendants(old.child(j), child11, offset6 + 1, f);
      } else {
        child11.nodesBetween(0, child11.content.size, f, offset6 + 1);
      }
      offset6 += child11.nodeSize;
    }
}
function fixTables(state, oldState) {
  var tr, check6 = function(node8, pos) {
    if (node8.type.spec.tableRole == "table") {
      tr = fixTable(state, node8, pos, tr);
    }
  };
  if (!oldState) {
    state.doc.descendants(check6);
  } else if (oldState.doc != state.doc) {
    changedDescendants(oldState.doc, state.doc, 0, check6);
  }
  return tr;
}
function fixTable(state, table2, tablePos, tr) {
  var map30 = TableMap.get(table2);
  if (!map30.problems) {
    return tr;
  }
  if (!tr) {
    tr = state.tr;
  }
  var mustAdd = [];
  for (var i = 0; i < map30.height; i++) {
    mustAdd.push(0);
  }
  for (var i$1 = 0; i$1 < map30.problems.length; i$1++) {
    var prob = map30.problems[i$1];
    if (prob.type == "collision") {
      var cell = table2.nodeAt(prob.pos);
      for (var j = 0; j < cell.attrs.rowspan; j++) {
        mustAdd[prob.row + j] += prob.n;
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      var cell$1 = table2.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, "rowspan", cell$1.attrs.rowspan - prob.n));
    } else if (prob.type == "colwidth mismatch") {
      var cell$2 = table2.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, "colwidth", prob.colwidth));
    }
  }
  var first2, last;
  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) {
    if (mustAdd[i$2]) {
      if (first2 == null) {
        first2 = i$2;
      }
      last = i$2;
    }
  }
  for (var i$3 = 0, pos = tablePos + 1; i$3 < map30.height; i$3++) {
    var row = table2.child(i$3);
    var end7 = pos + row.nodeSize;
    var add2 = mustAdd[i$3];
    if (add2 > 0) {
      var tableNodeType = "cell";
      if (row.firstChild) {
        tableNodeType = row.firstChild.type.spec.tableRole;
      }
      var nodes = [];
      for (var j$1 = 0; j$1 < add2; j$1++) {
        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
      }
      var side = (i$3 == 0 || first2 == i$3 - 1) && last == i$3 ? pos + 1 : end7 - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end7;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  var sel = state.selection, $pos = selectionCell(state);
  var table2 = $pos.node(-1), tableStart = $pos.start(-1), map30 = TableMap.get(table2);
  var rect;
  if (sel instanceof CellSelection) {
    rect = map30.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);
  } else {
    rect = map30.findCell($pos.pos - tableStart);
  }
  rect.tableStart = tableStart;
  rect.map = map30;
  rect.table = table2;
  return rect;
}
function addColumn(tr, ref2, col) {
  var map30 = ref2.map;
  var tableStart = ref2.tableStart;
  var table2 = ref2.table;
  var refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map30, table2, col + refColumn)) {
    refColumn = col == 0 || col == map30.width ? null : 0;
  }
  for (var row = 0; row < map30.height; row++) {
    var index6 = row * map30.width + col;
    if (col > 0 && col < map30.width && map30.map[index6 - 1] == map30.map[index6]) {
      var pos = map30.map[index6], cell = table2.nodeAt(pos);
      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map30.colCount(pos)));
      row += cell.attrs.rowspan - 1;
    } else {
      var type4 = refColumn == null ? tableNodeTypes(table2.type.schema).cell : table2.nodeAt(map30.map[index6 + refColumn]).type;
      var pos$1 = map30.positionAt(row, col, table2);
      tr.insert(tr.mapping.map(tableStart + pos$1), type4.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, ref2, col) {
  var map30 = ref2.map;
  var table2 = ref2.table;
  var tableStart = ref2.tableStart;
  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map30.height; ) {
    var index6 = row * map30.width + col, pos = map30.map[index6], cell = table2.nodeAt(pos);
    if (col > 0 && map30.map[index6 - 1] == pos || col < map30.width - 1 && map30.map[index6 + 1] == pos) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map30.colCount(pos)));
    } else {
      var start8 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start8, start8 + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
}
function deleteColumn(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) {
      return false;
    }
    for (var i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch2(tr);
  }
  return true;
}
function rowIsHeader(map30, table2, row) {
  var headerCell = tableNodeTypes(table2.type.schema).header_cell;
  for (var col = 0; col < map30.width; col++) {
    if (table2.nodeAt(map30.map[col + row * map30.width]).type != headerCell) {
      return false;
    }
  }
  return true;
}
function addRow(tr, ref2, row) {
  var map30 = ref2.map;
  var tableStart = ref2.tableStart;
  var table2 = ref2.table;
  var rowPos = tableStart;
  for (var i = 0; i < row; i++) {
    rowPos += table2.child(i).nodeSize;
  }
  var cells = [], refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map30, table2, row + refRow)) {
    refRow = row == 0 || row == map30.height ? null : 0;
  }
  for (var col = 0, index6 = map30.width * row; col < map30.width; col++, index6++) {
    if (row > 0 && row < map30.height && map30.map[index6] == map30.map[index6 - map30.width]) {
      var pos = map30.map[index6], attrs = table2.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, "rowspan", attrs.rowspan + 1));
      col += attrs.colspan - 1;
    } else {
      var type4 = refRow == null ? tableNodeTypes(table2.type.schema).cell : table2.nodeAt(map30.map[index6 + refRow * map30.width]).type;
      cells.push(type4.createAndFill());
    }
  }
  tr.insert(rowPos, tableNodeTypes(table2.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, ref2, row) {
  var map30 = ref2.map;
  var table2 = ref2.table;
  var tableStart = ref2.tableStart;
  var rowPos = 0;
  for (var i = 0; i < row; i++) {
    rowPos += table2.child(i).nodeSize;
  }
  var nextRow = rowPos + table2.child(row).nodeSize;
  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  for (var col = 0, index6 = row * map30.width; col < map30.width; col++, index6++) {
    var pos = map30.map[index6];
    if (row > 0 && pos == map30.map[index6 - map30.width]) {
      var attrs = table2.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, "rowspan", attrs.rowspan - 1));
      col += attrs.colspan - 1;
    } else if (row < map30.width && pos == map30.map[index6 + map30.width]) {
      var cell = table2.nodeAt(pos);
      var copy12 = cell.type.create(setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1), cell.content);
      var newPos = map30.positionAt(row + 1, col, table2);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy12);
      col += cell.attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) {
      return false;
    }
    for (var i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch2(tr);
  }
  return true;
}
function isEmpty(cell) {
  var c = cell.content;
  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;
}
function cellsOverlapRectangle(ref2, rect) {
  var width = ref2.width;
  var height = ref2.height;
  var map30 = ref2.map;
  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (var i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map30[indexLeft] == map30[indexLeft - 1] || rect.right < width && map30[indexRight] == map30[indexRight + 1]) {
      return true;
    }
    indexLeft += width;
    indexRight += width;
  }
  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {
    if (rect.top > 0 && map30[indexTop] == map30[indexTop - width] || rect.bottom < height && map30[indexBottom] == map30[indexBottom + width]) {
      return true;
    }
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch2) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) {
    return false;
  }
  var rect = selectedRect(state);
  var map30 = rect.map;
  if (cellsOverlapRectangle(map30, rect)) {
    return false;
  }
  if (dispatch2) {
    var tr = state.tr, seen = {}, content4 = Fragment$3.empty, mergedPos, mergedCell;
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var cellPos = map30.map[row * map30.width + col], cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos]) {
          continue;
        }
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) {
            content4 = content4.append(cell.content);
          }
          var mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), "rowspan", rect.bottom - rect.top));
    if (content4.size) {
      var end7 = mergedPos + 1 + mergedCell.content.size;
      var start8 = isEmpty(mergedCell) ? mergedPos + 1 : end7;
      tr.replaceWith(start8 + rect.tableStart, end7 + rect.tableStart, content4);
    }
    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));
    dispatch2(tr);
  }
  return true;
}
function splitCell(state, dispatch2) {
  var nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(function(ref2) {
    var node8 = ref2.node;
    return nodeTypes[node8.type.spec.tableRole];
  })(state, dispatch2);
}
function splitCellWithType(getCellType) {
  return function(state, dispatch2) {
    var sel = state.selection;
    var cellNode, cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) {
        return false;
      }
      cellPos = cellAround(sel.$from).pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) {
        return false;
      }
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch2) {
      var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) {
        baseAttrs = setAttr(baseAttrs, "rowspan", 1);
      }
      if (baseAttrs.colspan > 1) {
        baseAttrs = setAttr(baseAttrs, "colspan", 1);
      }
      var rect = selectedRect(state), tr = state.tr;
      for (var i = 0; i < rect.right - rect.left; i++) {
        attrs.push(colwidth ? setAttr(baseAttrs, "colwidth", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);
      }
      var lastCell;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) {
          pos += cellNode.nodeSize;
        }
        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {
          if (col == rect.left && row == rect.top) {
            continue;
          }
          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col }).createAndFill(attrs[i$1]));
        }
      }
      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left }), attrs[0]);
      if (sel instanceof CellSelection) {
        tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));
      }
      dispatch2(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    var $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) {
      return false;
    }
    if (dispatch2) {
      var tr = state.tr;
      if (state.selection instanceof CellSelection) {
        state.selection.forEachCell(function(node8, pos) {
          if (node8.attrs[name] !== value) {
            tr.setNodeMarkup(pos, null, setAttr(node8.attrs, name, value));
          }
        });
      } else {
        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));
      }
      dispatch2(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type4) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch2) {
      var types2 = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var cells = rect.map.cellsInRect(type4 == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type4 == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);
      var nodes = cells.map(function(pos) {
        return rect.table.nodeAt(pos);
      });
      for (var i = 0; i < cells.length; i++) {
        if (nodes[i].type == types2.header_cell) {
          tr.setNodeMarkup(rect.tableStart + cells[i], types2.cell, nodes[i].attrs);
        }
      }
      if (tr.steps.length == 0) {
        for (var i$1 = 0; i$1 < cells.length; i$1++) {
          tr.setNodeMarkup(rect.tableStart + cells[i$1], types2.header_cell, nodes[i$1].attrs);
        }
      }
      dispatch2(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type4, rect, types2) {
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type4 == "row" ? rect.map.width : 1,
    bottom: type4 == "column" ? rect.map.height : 1
  });
  for (var i = 0; i < cellPositions.length; i++) {
    var cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types2.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type4, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) {
    return deprecated_toggleHeader(type4);
  }
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch2) {
      var types2 = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types2);
      var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types2);
      var isHeaderEnabled = type4 === "column" ? isHeaderRowEnabled : type4 === "row" ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type4 == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type4 == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
      var newType = type4 == "column" ? isHeaderColumnEnabled ? types2.cell : types2.header_cell : type4 == "row" ? isHeaderRowEnabled ? types2.cell : types2.header_cell : types2.cell;
      rect.map.cellsInRect(cellsRect).forEach(function(relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch2(tr);
    }
    return true;
  };
}
toggleHeader("row", { useDeprecatedLogic: true });
toggleHeader("column", { useDeprecatedLogic: true });
var toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });
function findNextCell($cell, dir) {
  if (dir < 0) {
    var before6 = $cell.nodeBefore;
    if (before6) {
      return $cell.pos - before6.nodeSize;
    }
    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      var rowNode = $cell.node(-1).child(row);
      if (rowNode.childCount) {
        return rowEnd - 1 - rowNode.lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    var table2 = $cell.node(-1);
    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table2.childCount; row$1++) {
      var rowNode$1 = table2.child(row$1);
      if (rowNode$1.childCount) {
        return rowStart + 1;
      }
      rowStart += rowNode$1.nodeSize;
    }
  }
}
function goToNextCell(direction) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    var cell = findNextCell(selectionCell(state), direction);
    if (cell == null) {
      return;
    }
    if (dispatch2) {
      var $cell = state.doc.resolve(cell);
      dispatch2(state.tr.setSelection(TextSelection$2.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true;
  };
}
function deleteTable(state, dispatch2) {
  var $pos = state.selection.$anchor;
  for (var d = $pos.depth; d > 0; d--) {
    var node8 = $pos.node(d);
    if (node8.type.spec.tableRole == "table") {
      if (dispatch2) {
        dispatch2(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
var TableView$1 = function TableView(node8, cellMinWidth) {
  this.node = node8;
  this.cellMinWidth = cellMinWidth;
  this.dom = document.createElement("div");
  this.dom.className = "tableWrapper";
  this.table = this.dom.appendChild(document.createElement("table"));
  this.colgroup = this.table.appendChild(document.createElement("colgroup"));
  updateColumns$1(node8, this.colgroup, this.table, cellMinWidth);
  this.contentDOM = this.table.appendChild(document.createElement("tbody"));
};
TableView$1.prototype.update = function update2(node8) {
  if (node8.type != this.node.type) {
    return false;
  }
  this.node = node8;
  updateColumns$1(node8, this.colgroup, this.table, this.cellMinWidth);
  return true;
};
TableView$1.prototype.ignoreMutation = function ignoreMutation2(record) {
  return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
};
function updateColumns$1(node8, colgroup, table2, cellMinWidth, overrideCol, overrideValue) {
  var totalWidth = 0, fixedWidth = true;
  var nextDOM = colgroup.firstChild, row = node8.firstChild;
  for (var i = 0, col = 0; i < row.childCount; i++) {
    var ref2 = row.child(i).attrs;
    var colspan = ref2.colspan;
    var colwidth = ref2.colwidth;
    for (var j = 0; j < colspan; j++, col++) {
      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var after6 = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after6;
  }
  if (fixedWidth) {
    table2.style.width = totalWidth + "px";
    table2.style.minWidth = "";
  } else {
    table2.style.width = "";
    table2.style.minWidth = totalWidth + "px";
  }
}
var key$1 = new PluginKey2("tableColumnResizing");
function columnResizing(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var handleWidth = ref2.handleWidth;
  if (handleWidth === void 0)
    handleWidth = 5;
  var cellMinWidth = ref2.cellMinWidth;
  if (cellMinWidth === void 0)
    cellMinWidth = 25;
  var View = ref2.View;
  if (View === void 0)
    View = TableView$1;
  var lastColumnResizable = ref2.lastColumnResizable;
  if (lastColumnResizable === void 0)
    lastColumnResizable = true;
  var plugin = new Plugin2({
    key: key$1,
    state: {
      init: function init14(_, state) {
        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function(node8, view) {
          return new View(node8, cellMinWidth, view);
        };
        return new ResizeState(-1, false);
      },
      apply: function apply22(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: function attributes(state) {
        var pluginState = key$1.getState(state);
        return pluginState.activeHandle > -1 ? { class: "resize-cursor" } : null;
      },
      handleDOMEvents: {
        mousemove: function mousemove(view, event) {
          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);
        },
        mouseleave: function mouseleave(view) {
          handleMouseLeave(view);
        },
        mousedown: function mousedown(view, event) {
          handleMouseDown$1(view, event, cellMinWidth);
        }
      },
      decorations: function decorations(state) {
        var pluginState = key$1.getState(state);
        if (pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = function ResizeState2(activeHandle, dragging) {
  this.activeHandle = activeHandle;
  this.dragging = dragging;
};
ResizeState.prototype.apply = function apply21(tr) {
  var state = this, action = tr.getMeta(key$1);
  if (action && action.setHandle != null) {
    return new ResizeState(action.setHandle, null);
  }
  if (action && action.setDragging !== void 0) {
    return new ResizeState(state.activeHandle, action.setDragging);
  }
  if (state.activeHandle > -1 && tr.docChanged) {
    var handle = tr.mapping.map(state.activeHandle, -1);
    if (!pointsAtCell(tr.doc.resolve(handle))) {
      handle = null;
    }
    state = new ResizeState(handle, state.dragging);
  }
  return state;
};
function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
  var pluginState = key$1.getState(view.state);
  if (!pluginState.dragging) {
    var target = domCellAround(event.target), cell = -1;
    if (target) {
      var ref2 = target.getBoundingClientRect();
      var left2 = ref2.left;
      var right2 = ref2.right;
      if (event.clientX - left2 <= handleWidth) {
        cell = edgeCell(view, event, "left");
      } else if (right2 - event.clientX <= handleWidth) {
        cell = edgeCell(view, event, "right");
      }
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        var $cell = view.state.doc.resolve(cell);
        var table2 = $cell.node(-1), map30 = TableMap.get(table2), start8 = $cell.start(-1);
        var col = map30.colCount($cell.pos - start8) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map30.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle > -1 && !pluginState.dragging) {
    updateHandle(view, -1);
  }
}
function handleMouseDown$1(view, event, cellMinWidth) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle == -1 || pluginState.dragging) {
    return false;
  }
  var cell = view.state.doc.nodeAt(pluginState.activeHandle);
  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(key$1, { setDragging: { startX: event.clientX, startWidth: width } }));
  function finish11(event2) {
    window.removeEventListener("mouseup", finish11);
    window.removeEventListener("mousemove", move2);
    var pluginState2 = key$1.getState(view.state);
    if (pluginState2.dragging) {
      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(key$1, { setDragging: null }));
    }
  }
  function move2(event2) {
    if (!event2.which) {
      return finish11(event2);
    }
    var pluginState2 = key$1.getState(view.state);
    var dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
    displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
  }
  window.addEventListener("mouseup", finish11);
  window.addEventListener("mousemove", move2);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, ref2) {
  var colspan = ref2.colspan;
  var colwidth = ref2.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) {
    return width;
  }
  var dom = view.domAtPos(cellPos);
  var node8 = dom.node.childNodes[dom.offset];
  var domWidth = node8.offsetWidth, parts = colspan;
  if (colwidth) {
    for (var i = 0; i < colspan; i++) {
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
    }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH") {
    target = target.classList.contains("ProseMirror") ? null : target.parentNode;
  }
  return target;
}
function edgeCell(view, event, side) {
  var found2 = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!found2) {
    return -1;
  }
  var pos = found2.pos;
  var $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) {
    return -1;
  }
  if (side == "right") {
    return $cell.pos;
  }
  var map30 = TableMap.get($cell.node(-1)), start8 = $cell.start(-1);
  var index6 = map30.map.indexOf($cell.pos - start8);
  return index6 % map30.width == 0 ? -1 : start8 + map30.map[index6 - 1];
}
function draggedWidth(dragging, event, cellMinWidth) {
  var offset6 = event.clientX - dragging.startX;
  return Math.max(cellMinWidth, dragging.startWidth + offset6);
}
function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(key$1, { setHandle: value }));
}
function updateColumnWidth(view, cell, width) {
  var $cell = view.state.doc.resolve(cell);
  var table2 = $cell.node(-1), map30 = TableMap.get(table2), start8 = $cell.start(-1);
  var col = map30.colCount($cell.pos - start8) + $cell.nodeAfter.attrs.colspan - 1;
  var tr = view.state.tr;
  for (var row = 0; row < map30.height; row++) {
    var mapIndex = row * map30.width + col;
    if (row && map30.map[mapIndex] == map30.map[mapIndex - map30.width]) {
      continue;
    }
    var pos = map30.map[mapIndex];
    var ref2 = table2.nodeAt(pos);
    var attrs = ref2.attrs;
    var index6 = attrs.colspan == 1 ? 0 : col - map30.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index6] == width) {
      continue;
    }
    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index6] = width;
    tr.setNodeMarkup(start8 + pos, null, setAttr(attrs, "colwidth", colwidth));
  }
  if (tr.docChanged) {
    view.dispatch(tr);
  }
}
function displayColumnWidth(view, cell, width, cellMinWidth) {
  var $cell = view.state.doc.resolve(cell);
  var table2 = $cell.node(-1), start8 = $cell.start(-1);
  var col = TableMap.get(table2).colCount($cell.pos - start8) + $cell.nodeAfter.attrs.colspan - 1;
  var dom = view.domAtPos($cell.start(-1)).node;
  while (dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  updateColumns$1(table2, dom.firstChild, dom, cellMinWidth, col, width);
}
function zeroes(n) {
  var result2 = [];
  for (var i = 0; i < n; i++) {
    result2.push(0);
  }
  return result2;
}
function handleDecorations(state, cell) {
  var decorations = [];
  var $cell = state.doc.resolve(cell);
  var table2 = $cell.node(-1), map30 = TableMap.get(table2), start8 = $cell.start(-1);
  var col = map30.colCount($cell.pos - start8) + $cell.nodeAfter.attrs.colspan;
  for (var row = 0; row < map30.height; row++) {
    var index6 = col + row * map30.width - 1;
    if ((col == map30.width || map30.map[index6] != map30.map[index6 + 1]) && (row == 0 || map30.map[index6 - 1] != map30.map[index6 - 1 - map30.width])) {
      var cellPos = map30.map[index6];
      var pos = start8 + cellPos + table2.nodeAt(cellPos).nodeSize - 1;
      var dom = document.createElement("div");
      dom.className = "column-resize-handle";
      decorations.push(Decoration2.widget(pos, dom));
    }
  }
  return DecorationSet2.create(state.doc, decorations);
}
function tableEditing(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var allowTableNodeSelection = ref2.allowTableNodeSelection;
  if (allowTableNodeSelection === void 0)
    allowTableNodeSelection = false;
  return new Plugin2({
    key,
    state: {
      init: function init14() {
        return null;
      },
      apply: function apply22(tr, cur) {
        var set3 = tr.getMeta(key);
        if (set3 != null) {
          return set3 == -1 ? null : set3;
        }
        if (cur == null || !tr.docChanged) {
          return cur;
        }
        var ref3 = tr.mapping.mapResult(cur);
        var deleted = ref3.deleted;
        var pos = ref3.pos;
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween: function createSelectionBetween(view) {
        if (key.getState(view.state) != null) {
          return view.state.selection;
        }
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction: function appendTransaction(_, oldState, state) {
      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);
    }
  });
}
function createCell(cellType, cellContent) {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
}
function getTableNodeTypes(schema) {
  if (schema.cached.tableNodeTypes) {
    return schema.cached.tableNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type4) => {
    const nodeType2 = schema.nodes[type4];
    if (nodeType2.spec.tableRole) {
      roles[nodeType2.spec.tableRole] = nodeType2;
    }
  });
  schema.cached.tableNodeTypes = roles;
  return roles;
}
function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
  const types2 = getTableNodeTypes(schema);
  const headerCells = [];
  const cells = [];
  for (let index6 = 0; index6 < colsCount; index6 += 1) {
    const cell = createCell(types2.cell, cellContent);
    if (cell) {
      cells.push(cell);
    }
    if (withHeaderRow) {
      const headerCell = createCell(types2.header_cell, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index6 = 0; index6 < rowsCount; index6 += 1) {
    rows.push(types2.row.createChecked(null, withHeaderRow && index6 === 0 ? headerCells : cells));
  }
  return types2.table.createChecked(null, rows);
}
function isCellSelection(value) {
  return value instanceof CellSelection;
}
const deleteTableWhenAllCellsSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) {
    return false;
  }
  let cellCount = 0;
  const table2 = findParentNodeClosestToPos(selection.ranges[0].$from, (node8) => {
    return node8.type.name === "table";
  });
  table2 === null || table2 === void 0 ? void 0 : table2.node.descendants((node8) => {
    if (node8.type.name === "table") {
      return false;
    }
    if (["tableCell", "tableHeader"].includes(node8.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
function updateColumns(node8, colgroup, table2, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node8.firstChild;
  for (let i = 0, col = 0; i < row.childCount; i += 1) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j += 1, col += 1) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? `${hasWidth}px` : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width !== cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after6 = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after6;
  }
  if (fixedWidth) {
    table2.style.width = `${totalWidth}px`;
    table2.style.minWidth = "";
  } else {
    table2.style.width = "";
    table2.style.minWidth = `${totalWidth}px`;
  }
}
class TableView2 {
  constructor(node8, cellMinWidth) {
    this.node = node8;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node8, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node8) {
    if (node8.type !== this.node.type) {
      return false;
    }
    this.node = node8;
    updateColumns(node8, this.colgroup, this.table, this.cellMinWidth);
    return true;
  }
  ignoreMutation(mutation) {
    return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
  }
}
const Table$1 = Node$4.create({
  name: "table",
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: false,
      handleWidth: 5,
      cellMinWidth: 25,
      View: TableView2,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: true,
  group: "block",
  parseHTML() {
    return [
      { tag: "table" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["table", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ["tbody", 0]];
  },
  addCommands() {
    return {
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch: dispatch2, editor }) => {
        const node8 = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch2) {
          const offset6 = tr.selection.anchor + 1;
          tr.replaceSelectionWith(node8).scrollIntoView().setSelection(TextSelection$3.near(tr.doc.resolve(offset6)));
        }
        return true;
      },
      addColumnBefore: () => ({ state, dispatch: dispatch2 }) => {
        return addColumnBefore(state, dispatch2);
      },
      addColumnAfter: () => ({ state, dispatch: dispatch2 }) => {
        return addColumnAfter(state, dispatch2);
      },
      deleteColumn: () => ({ state, dispatch: dispatch2 }) => {
        return deleteColumn(state, dispatch2);
      },
      addRowBefore: () => ({ state, dispatch: dispatch2 }) => {
        return addRowBefore(state, dispatch2);
      },
      addRowAfter: () => ({ state, dispatch: dispatch2 }) => {
        return addRowAfter(state, dispatch2);
      },
      deleteRow: () => ({ state, dispatch: dispatch2 }) => {
        return deleteRow(state, dispatch2);
      },
      deleteTable: () => ({ state, dispatch: dispatch2 }) => {
        return deleteTable(state, dispatch2);
      },
      mergeCells: () => ({ state, dispatch: dispatch2 }) => {
        return mergeCells(state, dispatch2);
      },
      splitCell: () => ({ state, dispatch: dispatch2 }) => {
        return splitCell(state, dispatch2);
      },
      toggleHeaderColumn: () => ({ state, dispatch: dispatch2 }) => {
        return toggleHeader("column")(state, dispatch2);
      },
      toggleHeaderRow: () => ({ state, dispatch: dispatch2 }) => {
        return toggleHeader("row")(state, dispatch2);
      },
      toggleHeaderCell: () => ({ state, dispatch: dispatch2 }) => {
        return toggleHeaderCell(state, dispatch2);
      },
      mergeOrSplit: () => ({ state, dispatch: dispatch2 }) => {
        if (mergeCells(state, dispatch2)) {
          return true;
        }
        return splitCell(state, dispatch2);
      },
      setCellAttribute: (name, value) => ({ state, dispatch: dispatch2 }) => {
        return setCellAttr(name, value)(state, dispatch2);
      },
      goToNextCell: () => ({ state, dispatch: dispatch2 }) => {
        return goToNextCell(1)(state, dispatch2);
      },
      goToPreviousCell: () => ({ state, dispatch: dispatch2 }) => {
        return goToNextCell(-1)(state, dispatch2);
      },
      fixTables: () => ({ state, dispatch: dispatch2 }) => {
        if (dispatch2) {
          fixTables(state);
        }
        return true;
      },
      setCellSelection: (position) => ({ tr, dispatch: dispatch2 }) => {
        if (dispatch2) {
          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);
          tr.setSelection(selection);
        }
        return true;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenAllCellsSelected,
      "Mod-Backspace": deleteTableWhenAllCellsSelected,
      Delete: deleteTableWhenAllCellsSelected,
      "Mod-Delete": deleteTableWhenAllCellsSelected
    };
  },
  addProseMirrorPlugins() {
    const isResizable = this.options.resizable && this.editor.isEditable;
    return [
      ...isResizable ? [columnResizing({
        handleWidth: this.options.handleWidth,
        cellMinWidth: this.options.cellMinWidth,
        View: this.options.View,
        lastColumnResizable: this.options.lastColumnResizable
      })] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      tableRole: callOrReturn(getExtensionField(extension, "tableRole", context))
    };
  }
});
const TableRow = Node$4.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
const TableHeader = Node$4.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? [parseInt(colwidth, 10)] : null;
          return value;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: true,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
const TableCell = Node$4.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? [parseInt(colwidth, 10)] : null;
          return value;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: true,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
function isTableActive(state) {
  const { selection, doc: doc2 } = state;
  const { from: from8, to } = selection;
  let keepLooking = true;
  let active = false;
  doc2.nodesBetween(from8, to, (node8) => {
    const name = node8.type.name;
    if (keepLooking && (name === "table" || name === "table_row" || name === "table_column" || name === "table_cell")) {
      keepLooking = false;
      active = true;
    }
    return keepLooking;
  });
  return active;
}
function enableMergeCells(state) {
  return isTableActive(state) && mergeCells(state);
}
function enableSplitCell(state) {
  return isTableActive(state) && splitCell(state);
}
const INIT_GRID_SIZE = 4;
const MAX_GRID_SIZE = 1e3;
const MAX_COL_SIZE = 4;
const DEFAULT_SELECTED_GRID_SIZE = 4;
const _sfc_main$c = defineComponent({
  name: "CreateTablePopover",
  components: {
    ElPopover
  },
  setup(_, { emit }) {
    const t = inject("t");
    const popoverRef = ref();
    const popoverVisible = ref(false);
    const confirmCreateTable = (row, col) => {
      unref(popoverRef).hide();
      emit("createTable", { row, col });
    };
    return { t, popoverVisible, popoverRef, confirmCreateTable };
  },
  data() {
    return {
      tableGridSize: {
        row: INIT_GRID_SIZE,
        col: INIT_GRID_SIZE
      },
      selectedTableGridSize: {
        row: DEFAULT_SELECTED_GRID_SIZE,
        col: DEFAULT_SELECTED_GRID_SIZE
      }
    };
  },
  methods: {
    selectTableGridSize(row, col) {
      if (row === this.tableGridSize.row) {
        this.tableGridSize.row = Math.min(row + 1, MAX_GRID_SIZE);
      }
      if (col === this.tableGridSize.col) {
        this.tableGridSize.col = Math.min(col + 1, MAX_COL_SIZE);
      }
      this.selectedTableGridSize.row = row;
      this.selectedTableGridSize.col = col;
    },
    resetTableGridSize() {
      this.tableGridSize = {
        row: INIT_GRID_SIZE,
        col: INIT_GRID_SIZE
      };
      this.selectedTableGridSize = {
        row: DEFAULT_SELECTED_GRID_SIZE,
        col: DEFAULT_SELECTED_GRID_SIZE
      };
    }
  }
});
const _hoisted_1$O = { class: "table-grid-size-editor" };
const _hoisted_2$M = { class: "table-grid-size-editor__body" };
const _hoisted_3$J = ["onMouseover", "onMousedown"];
const _hoisted_4$4 = /* @__PURE__ */ createElementVNode("div", { class: "table-grid-size-editor__cell__inner" }, null, -1);
const _hoisted_5$3 = [
  _hoisted_4$4
];
const _hoisted_6$2 = { class: "table-grid-size-editor__footer" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createBlock(_component_el_popover, {
    ref: "popoverRef",
    modelValue: _ctx.popoverVisible,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.popoverVisible = $event),
    placement: "right",
    trigger: "hover",
    "popper-class": "el-tiptap-popper",
    onAfterLeave: _ctx.resetTableGridSize
  }, {
    reference: withCtx(() => [
      createElementVNode("div", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.insert_table")), 1)
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$O, [
        createElementVNode("div", _hoisted_2$M, [
          (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.tableGridSize.row, (row) => {
            return openBlock(), createElementBlock("div", {
              key: "r" + row,
              class: "table-grid-size-editor__row"
            }, [
              (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.tableGridSize.col, (col) => {
                return openBlock(), createElementBlock("div", {
                  key: "c" + col,
                  class: normalizeClass([{
                    "table-grid-size-editor__cell--selected": col <= _ctx.selectedTableGridSize.col && row <= _ctx.selectedTableGridSize.row
                  }, "table-grid-size-editor__cell"]),
                  onMouseover: ($event) => _ctx.selectTableGridSize(row, col),
                  onMousedown: ($event) => _ctx.confirmCreateTable(row, col)
                }, _hoisted_5$3, 42, _hoisted_3$J);
              }), 128))
            ]);
          }), 128))
        ]),
        createElementVNode("div", _hoisted_6$2, toDisplayString(_ctx.selectedTableGridSize.row) + " X " + toDisplayString(_ctx.selectedTableGridSize.col), 1)
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "onAfterLeave"]);
}
var CreateTablePopover = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$c]]);
const _sfc_main$b = defineComponent({
  name: "TablePopover",
  components: {
    ElPopover,
    CommandButton,
    CreateTablePopover
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    const popoverRef = ref();
    const hidePopover = () => {
      unref(popoverRef).hide();
    };
    return { t, enableTooltip, isCodeViewMode, popoverRef, hidePopover };
  },
  computed: {
    isTableActive() {
      return isTableActive(this.editor.state);
    },
    enableMergeCells() {
      return enableMergeCells(this.editor.state);
    },
    enableSplitCell() {
      return enableSplitCell(this.editor.state);
    }
  },
  methods: {
    createTable({ row, col }) {
      this.editor.commands.insertTable({
        rows: row,
        cols: col,
        withHeaderRow: true
      });
      this.hidePopover();
    }
  }
});
const _hoisted_1$N = { class: "el-tiptap-popper__menu" };
const _hoisted_2$L = { class: "el-tiptap-popper__menu__item" };
const _hoisted_3$I = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-popper__menu__item__separator" }, null, -1);
const _hoisted_4$3 = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-popper__menu__item__separator" }, null, -1);
const _hoisted_5$2 = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-popper__menu__item__separator" }, null, -1);
const _hoisted_6$1 = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-popper__menu__item__separator" }, null, -1);
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_create_table_popover = resolveComponent("create-table-popover");
  const _component_command_button = resolveComponent("command-button");
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createBlock(_component_el_popover, {
    disabled: _ctx.isCodeViewMode,
    placement: "bottom",
    trigger: "click",
    "popper-class": "el-tiptap-popper",
    ref: "popoverRef"
  }, {
    reference: withCtx(() => [
      createElementVNode("span", null, [
        createVNode(_component_command_button, {
          "is-active": _ctx.isTableActive,
          "enable-tooltip": _ctx.enableTooltip,
          tooltip: _ctx.t("editor.extensions.Table.tooltip"),
          readonly: _ctx.isCodeViewMode,
          icon: "table"
        }, null, 8, ["is-active", "enable-tooltip", "tooltip", "readonly"])
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$N, [
        createElementVNode("div", _hoisted_2$L, [
          createVNode(_component_create_table_popover, { onCreateTable: _ctx.createTable }, null, 8, ["onCreateTable"])
        ]),
        _hoisted_3$I,
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.editor.commands.addColumnBefore && _ctx.editor.commands.addColumnBefore(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.add_column_before")), 1)
        ], 34),
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[2] || (_cache[2] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.editor.commands.addColumnAfter && _ctx.editor.commands.addColumnAfter(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.add_column_after")), 1)
        ], 34),
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[4] || (_cache[4] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.editor.commands.deleteColumn && _ctx.editor.commands.deleteColumn(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.delete_column")), 1)
        ], 34),
        _hoisted_4$3,
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[6] || (_cache[6] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[7] || (_cache[7] = (...args) => _ctx.editor.commands.addRowBefore && _ctx.editor.commands.addRowBefore(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.add_row_before")), 1)
        ], 34),
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[8] || (_cache[8] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[9] || (_cache[9] = (...args) => _ctx.editor.commands.addRowAfter && _ctx.editor.commands.addRowAfter(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.add_row_after")), 1)
        ], 34),
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[10] || (_cache[10] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[11] || (_cache[11] = (...args) => _ctx.editor.commands.deleteRow && _ctx.editor.commands.deleteRow(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.delete_row")), 1)
        ], 34),
        _hoisted_5$2,
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.enableMergeCells }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[12] || (_cache[12] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[13] || (_cache[13] = (...args) => _ctx.editor.commands.mergeCells && _ctx.editor.commands.mergeCells(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.merge_cells")), 1)
        ], 34),
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.enableSplitCell }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[14] || (_cache[14] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[15] || (_cache[15] = (...args) => _ctx.editor.commands.splitCell && _ctx.editor.commands.splitCell(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.split_cell")), 1)
        ], 34),
        _hoisted_6$1,
        createElementVNode("div", {
          class: normalizeClass([{ "el-tiptap-popper__menu__item--disabled": !_ctx.isTableActive }, "el-tiptap-popper__menu__item"]),
          onMousedown: _cache[16] || (_cache[16] = (...args) => _ctx.hidePopover && _ctx.hidePopover(...args)),
          onClick: _cache[17] || (_cache[17] = (...args) => _ctx.editor.commands.deleteTable && _ctx.editor.commands.deleteTable(...args))
        }, [
          createElementVNode("span", null, toDisplayString(_ctx.t("editor.extensions.Table.buttons.delete_table")), 1)
        ], 34)
      ])
    ]),
    _: 1
  }, 8, ["disabled"]);
}
var TablePopover = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$b]]);
const Table = Table$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: TablePopover,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addExtensions() {
    return [TableRow, TableHeader, TableCell];
  }
});
const _sfc_main$a = defineComponent({
  name: "IframeCommandButton",
  components: {
    CommandButton,
    ElDialog,
    ElUpload,
    ElPopover
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  data() {
    return {
      imageUploadDialogVisible: false,
      uploading: false
    };
  },
  computed: {
    imageNodeOptions() {
      return this.editor.extensionManager.extensions.find((e) => e.name === "iframe").options;
    }
  },
  methods: {
    async openInsertVideoControl() {
      const { value: href } = await ElMessageBox.prompt("", this.t("editor.extensions.Iframe.control.title"), {
        confirmButtonText: this.t("editor.extensions.Iframe.control.confirm"),
        cancelButtonText: this.t("editor.extensions.Iframe.control.cancel"),
        inputPlaceholder: this.t("editor.extensions.Iframe.control.placeholder"),
        roundButton: true
      });
      this.editor.commands.setIframe({ src: href });
    },
    async uploadImage(requestOptions) {
      const { file } = requestOptions;
      const uploadRequest = this.imageNodeOptions.uploadRequest;
      const loadingInstance = ElLoading.service({
        target: ".el-tiptap-upload"
      });
      try {
        const url2 = await (uploadRequest ? uploadRequest(file) : readFileDataUrl(file));
        this.editor.commands.setIframe({ src: url2 });
        this.imageUploadDialogVisible = false;
      } catch (e) {
        Logger.error(String(e));
      } finally {
        this.$nextTick(() => {
          loadingInstance.close();
        });
      }
    }
  }
});
const _hoisted_1$M = { class: "el-tiptap-popper__menu" };
const _hoisted_2$K = /* @__PURE__ */ createElementVNode("span", null, /* @__PURE__ */ toDisplayString("\u63D2\u5165\u4E00\u4E2A\u89C6\u9891\u94FE\u63A5"), -1);
const _hoisted_3$H = [
  _hoisted_2$K
];
const _hoisted_4$2 = /* @__PURE__ */ createElementVNode("span", null, /* @__PURE__ */ toDisplayString("\u4E0A\u4F20\u4E00\u4E2A\u89C6\u9891\u6587\u4EF6"), -1);
const _hoisted_5$1 = [
  _hoisted_4$2
];
const _hoisted_6 = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-upload__icon" }, [
  /* @__PURE__ */ createElementVNode("i", { class: "fa fa-upload" })
], -1);
const _hoisted_7 = /* @__PURE__ */ createElementVNode("div", { class: "el-tiptap-upload__text" }, /* @__PURE__ */ toDisplayString("\u9009\u62E9\u4E00\u4E2A\u89C6\u9891\u6587\u4EF6\u6216\u5C06\u5176\u62D6\u5230\u6B64\u5904"), -1);
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_popover = resolveComponent("el-popover");
  const _component_el_upload = resolveComponent("el-upload");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock(Fragment$6, null, [
    createVNode(_component_el_popover, {
      disabled: _ctx.isCodeViewMode,
      placement: "bottom",
      trigger: "click",
      "popper-class": "el-tiptap-popper"
    }, {
      reference: withCtx(() => [
        createElementVNode("span", null, [
          createVNode(_component_command_button, {
            "enable-tooltip": _ctx.enableTooltip,
            tooltip: _ctx.t("editor.extensions.Iframe.tooltip"),
            readonly: _ctx.isCodeViewMode,
            icon: "video"
          }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$M, [
          createElementVNode("div", {
            class: "el-tiptap-popper__menu__item",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openInsertVideoControl && _ctx.openInsertVideoControl(...args))
          }, _hoisted_3$H),
          createElementVNode("div", {
            class: "el-tiptap-popper__menu__item",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.imageUploadDialogVisible = true)
          }, _hoisted_5$1)
        ])
      ]),
      _: 1
    }, 8, ["disabled"]),
    createVNode(_component_el_dialog, {
      modelValue: _ctx.imageUploadDialogVisible,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.imageUploadDialogVisible = $event),
      title: "\u4E0A\u4F20\u89C6\u9891 \u652F\u6301mp4,m4v,webm,ogv,wav,gltf",
      "append-to-body": true
    }, {
      default: withCtx(() => [
        createVNode(_component_el_upload, {
          "http-request": _ctx.uploadImage,
          "show-file-list": false,
          class: "el-tiptap-upload",
          action: "#",
          drag: "",
          accept: "video/*"
        }, {
          default: withCtx(() => [
            _hoisted_6,
            _hoisted_7
          ]),
          _: 1
        }, 8, ["http-request"])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ], 64);
}
var IframeCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$a]]);
const _sfc_main$9 = defineComponent({
  name: "IframeView",
  components: {
    NodeViewWrapper
  },
  props: nodeViewProps
});
const _hoisted_1$L = {
  controls: "",
  loop: "",
  muted: ""
};
const _hoisted_2$J = ["src"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_node_view_wrapper = resolveComponent("node-view-wrapper");
  return openBlock(), createBlock(_component_node_view_wrapper, {
    as: "div",
    class: "iframe apex-video"
  }, {
    default: withCtx(() => [
      createElementVNode("video", _hoisted_1$L, [
        createElementVNode("source", {
          src: _ctx.node.attrs.src,
          type: "video/mp4"
        }, null, 8, _hoisted_2$J)
      ])
    ]),
    _: 1
  });
}
var IframeView = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$9]]);
const Iframe = Node$4.create({
  name: "iframe",
  group: "block",
  selectable: false,
  addAttributes() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      src: {
        default: null,
        parseHTML: (element) => {
          const src = element.getAttribute("src");
          return src;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "video"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "video",
      mergeAttributes(HTMLAttributes, {
        frameborder: 0,
        allowfullscreen: "true"
      })
    ];
  },
  addCommands() {
    return {
      setIframe: (options) => ({ commands }) => {
        return commands.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addOptions() {
    return {
      button({ editor }) {
        return {
          component: IframeCommandButton,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addNodeView() {
    return VueNodeViewRenderer(IframeView);
  }
});
const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
const Bold$1 = Mark$4.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node8) => node8.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const Bold = Bold$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleBold();
            },
            isActive: editor.isActive("bold"),
            icon: "bold",
            tooltip: t("editor.extensions.Bold.tooltip")
          }
        };
      }
    };
  }
});
const Underline$1 = Mark$4.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline()
    };
  }
});
const Underline = Underline$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleUnderline();
            },
            isActive: editor.isActive("underline"),
            icon: "underline",
            tooltip: t("editor.extensions.Underline.tooltip")
          }
        };
      }
    };
  }
});
const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
const Italic$1 = Mark$4.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node8) => node8.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
const Italic = Italic$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleItalic();
            },
            isActive: editor.isActive("italic"),
            icon: "italic",
            tooltip: t("editor.extensions.Italic.tooltip")
          }
        };
      }
    };
  }
});
const inputRegex$2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
const pasteRegex$2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
const Strike$1 = Mark$4.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
const Strike = Strike$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.toggleStrike();
            },
            isActive: editor.isActive("strike"),
            icon: "strikethrough",
            tooltip: t("editor.extensions.Strike.tooltip")
          }
        };
      }
    };
  }
});
function State(token) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  tt: function tt2(input, tokenOrState) {
    if (tokenOrState && tokenOrState.j) {
      this.j[input] = tokenOrState;
      return tokenOrState;
    }
    var token = tokenOrState;
    var nextState = this.j[input];
    if (nextState) {
      if (token) {
        nextState.t = token;
      }
      return nextState;
    }
    nextState = makeState();
    var templateState = takeT(this, input);
    if (templateState) {
      Object.assign(nextState.j, templateState.j);
      nextState.jr.append(templateState.jr);
      nextState.jr = templateState.jd;
      nextState.t = token || templateState.t;
    } else {
      nextState.t = token;
    }
    this.j[input] = nextState;
    return nextState;
  }
};
var makeState = function makeState2() {
  return new State();
};
var makeAcceptingState = function makeAcceptingState2(token) {
  return new State(token);
};
var makeT = function makeT2(startState, input, nextState) {
  if (!startState.j[input]) {
    startState.j[input] = nextState;
  }
};
var makeRegexT = function makeRegexT2(startState, regex, nextState) {
  startState.jr.push([regex, nextState]);
};
var takeT = function takeT2(state, input) {
  var nextState = state.j[input];
  if (nextState) {
    return nextState;
  }
  for (var i = 0; i < state.jr.length; i++) {
    var regex = state.jr[i][0];
    var _nextState = state.jr[i][1];
    if (regex.test(input)) {
      return _nextState;
    }
  }
  return state.jd;
};
var makeMultiT = function makeMultiT2(startState, chars, nextState) {
  for (var i = 0; i < chars.length; i++) {
    makeT(startState, chars[i], nextState);
  }
};
var makeBatchT = function makeBatchT2(startState, transitions) {
  for (var i = 0; i < transitions.length; i++) {
    var input = transitions[i][0];
    var nextState = transitions[i][1];
    makeT(startState, input, nextState);
  }
};
var makeChainT = function makeChainT2(state, str, endState, defaultStateFactory) {
  var i = 0, len = str.length, nextState;
  while (i < len && (nextState = state.j[str[i]])) {
    state = nextState;
    i++;
  }
  if (i >= len) {
    return [];
  }
  while (i < len - 1) {
    nextState = defaultStateFactory();
    makeT(state, str[i], nextState);
    state = nextState;
    i++;
  }
  makeT(state, str[len - 1], endState);
};
var DOMAIN = "DOMAIN";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var NUM = "NUM";
var PROTOCOL = "PROTOCOL";
var MAILTO = "MAILTO";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var SYM = "SYM";
var text2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DOMAIN,
  LOCALHOST,
  TLD,
  NUM,
  PROTOCOL,
  MAILTO,
  WS,
  NL,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  SYM
});
var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xF6gensberater-ctb verm\xF6gensberatung-pwb \u03B5\u03BB \u03B5\u03C5 \u0431\u0433 \u0431\u0435\u043B \u0434\u0435\u0442\u0438 \u0435\u044E \u043A\u0430\u0442\u043E\u043B\u0438\u043A \u043A\u043E\u043C \u049B\u0430\u0437 \u043C\u043A\u0434 \u043C\u043E\u043D \u043C\u043E\u0441\u043A\u0432\u0430 \u043E\u043D\u043B\u0430\u0439\u043D \u043E\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043A\u0440 \u10D2\u10D4 \u0570\u0561\u0575 \u05D9\u05E9\u05E8\u05D0\u05DC \u05E7\u05D5\u05DD \u0627\u0628\u0648\u0638\u0628\u064A \u0627\u062A\u0635\u0627\u0644\u0627\u062A \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062F\u0646 \u0627\u0644\u0628\u062D\u0631\u064A\u0646 \u0627\u0644\u062C\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629 \u0627\u0644\u0639\u0644\u064A\u0627\u0646 \u0627\u0644\u0645\u063A\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062A \u0627\u06CC\u0631\u0627\u0646 \u0628\u0627\u0631\u062A \u0628\u0627\u0632\u0627\u0631 \u0628\u06BE\u0627\u0631\u062A \u0628\u064A\u062A\u0643 \u067E\u0627\u06A9\u0633\u062A\u0627\u0646 \u0680\u0627\u0631\u062A \u062A\u0648\u0646\u0633 \u0633\u0648\u062F\u0627\u0646 \u0633\u0648\u0631\u064A\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064A\u0646 \u0642\u0637\u0631 \u0643\u0627\u062B\u0648\u0644\u064A\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064A\u0633\u064A\u0627 \u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092E \u0928\u0947\u091F \u092D\u093E\u0930\u0924 \u092D\u093E\u0930\u0924\u092E\u094D \u092D\u093E\u0930\u094B\u0924 \u0938\u0902\u0917\u0920\u0928 \u09AC\u09BE\u0982\u09B2\u09BE \u09AD\u09BE\u09B0\u09A4 \u09AD\u09BE\u09F0\u09A4 \u0A2D\u0A3E\u0A30\u0A24 \u0AAD\u0ABE\u0AB0\u0AA4 \u0B2D\u0B3E\u0B30\u0B24 \u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE \u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8 \u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD \u0C2D\u0C3E\u0C30\u0C24\u0C4D \u0CAD\u0CBE\u0CB0\u0CA4 \u0D2D\u0D3E\u0D30\u0D24\u0D02 \u0DBD\u0D82\u0D9A\u0DCF \u0E04\u0E2D\u0E21 \u0E44\u0E17\u0E22 \u0EA5\u0EB2\u0EA7 \uB2F7\uB137 \uB2F7\uCEF4 \uC0BC\uC131 \uD55C\uAD6D \u30A2\u30DE\u30BE\u30F3 \u30B0\u30FC\u30B0\u30EB \u30AF\u30E9\u30A6\u30C9 \u30B3\u30E0 \u30B9\u30C8\u30A2 \u30BB\u30FC\u30EB \u30D5\u30A1\u30C3\u30B7\u30E7\u30F3 \u30DD\u30A4\u30F3\u30C8 \u307F\u3093\u306A \u4E16\u754C \u4E2D\u4FE1 \u4E2D\u56FD \u4E2D\u570B \u4E2D\u6587\u7F51 \u4E9A\u9A6C\u900A \u4F01\u4E1A \u4F5B\u5C71 \u4FE1\u606F \u5065\u5EB7 \u516B\u5366 \u516C\u53F8 \u516C\u76CA \u53F0\u6E7E \u53F0\u7063 \u5546\u57CE \u5546\u5E97 \u5546\u6807 \u5609\u91CC \u5609\u91CC\u5927\u9152\u5E97 \u5728\u7EBF \u5927\u4F17\u6C7D\u8F66 \u5927\u62FF \u5929\u4E3B\u6559 \u5A31\u4E50 \u5BB6\u96FB \u5E7F\u4E1C \u5FAE\u535A \u6148\u5584 \u6211\u7231\u4F60 \u624B\u673A \u62DB\u8058 \u653F\u52A1 \u653F\u5E9C \u65B0\u52A0\u5761 \u65B0\u95FB \u65F6\u5C1A \u66F8\u7C4D \u673A\u6784 \u6DE1\u9A6C\u9521 \u6E38\u620F \u6FB3\u9580 \u70B9\u770B \u79FB\u52A8 \u7EC4\u7EC7\u673A\u6784 \u7F51\u5740 \u7F51\u5E97 \u7F51\u7AD9 \u7F51\u7EDC \u8054\u901A \u8BFA\u57FA\u4E9A \u8C37\u6B4C \u8D2D\u7269 \u901A\u8CA9 \u96C6\u56E2 \u96FB\u8A0A\u76C8\u79D1 \u98DE\u5229\u6D66 \u98DF\u54C1 \u9910\u5385 \u9999\u683C\u91CC\u62C9 \u9999\u6E2F".split(" ");
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION = /\uFE0F/;
var DIGIT = /\d/;
var SPACE = /\s/;
function init$2() {
  var customProtocols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var S_START = makeState();
  var S_NUM = makeAcceptingState(NUM);
  var S_DOMAIN = makeAcceptingState(DOMAIN);
  var S_DOMAIN_HYPHEN = makeState();
  var S_WS = makeAcceptingState(WS);
  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]];
  var makeDomainState = function makeDomainState2() {
    var state = makeAcceptingState(DOMAIN);
    state.j = {
      "-": S_DOMAIN_HYPHEN
    };
    state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
    return state;
  };
  var makeNearDomainState = function makeNearDomainState2(token) {
    var state = makeDomainState();
    state.t = token;
    return state;
  };
  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ["{", makeAcceptingState(OPENBRACE)], ["[", makeAcceptingState(OPENBRACKET)], ["<", makeAcceptingState(OPENANGLEBRACKET)], ["(", makeAcceptingState(OPENPAREN)], ["}", makeAcceptingState(CLOSEBRACE)], ["]", makeAcceptingState(CLOSEBRACKET)], [">", makeAcceptingState(CLOSEANGLEBRACKET)], [")", makeAcceptingState(CLOSEPAREN)], ["&", makeAcceptingState(AMPERSAND)], ["*", makeAcceptingState(ASTERISK)], ["@", makeAcceptingState(AT)], ["`", makeAcceptingState(BACKTICK)], ["^", makeAcceptingState(CARET)], [":", makeAcceptingState(COLON)], [",", makeAcceptingState(COMMA)], ["$", makeAcceptingState(DOLLAR)], [".", makeAcceptingState(DOT)], ["=", makeAcceptingState(EQUALS)], ["!", makeAcceptingState(EXCLAMATION)], ["-", makeAcceptingState(HYPHEN)], ["%", makeAcceptingState(PERCENT)], ["|", makeAcceptingState(PIPE)], ["+", makeAcceptingState(PLUS)], ["#", makeAcceptingState(POUND)], ["?", makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ["/", makeAcceptingState(SLASH)], [";", makeAcceptingState(SEMI)], ["~", makeAcceptingState(TILDE)], ["_", makeAcceptingState(UNDERSCORE)], ["\\", makeAcceptingState(BACKSLASH)]]);
  makeT(S_START, "\n", makeAcceptingState(NL));
  makeRegexT(S_START, SPACE, S_WS);
  makeT(S_WS, "\n", makeState());
  makeRegexT(S_WS, SPACE, S_WS);
  for (var i = 0; i < tlds.length; i++) {
    makeChainT(S_START, tlds[i], makeNearDomainState(TLD), makeDomainState);
  }
  var S_PROTOCOL_FILE = makeDomainState();
  var S_PROTOCOL_FTP = makeDomainState();
  var S_PROTOCOL_HTTP = makeDomainState();
  var S_MAILTO = makeDomainState();
  makeChainT(S_START, "file", S_PROTOCOL_FILE, makeDomainState);
  makeChainT(S_START, "ftp", S_PROTOCOL_FTP, makeDomainState);
  makeChainT(S_START, "http", S_PROTOCOL_HTTP, makeDomainState);
  makeChainT(S_START, "mailto", S_MAILTO, makeDomainState);
  var S_PROTOCOL_SECURE = makeDomainState();
  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL);
  var S_FULL_MAILTO = makeAcceptingState(MAILTO);
  makeT(S_PROTOCOL_FTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_FTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_HTTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_HTTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_FILE, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_SECURE, ":", S_FULL_PROTOCOL);
  makeT(S_MAILTO, ":", S_FULL_MAILTO);
  var S_CUSTOM_PROTOCOL = makeDomainState();
  for (var _i = 0; _i < customProtocols.length; _i++) {
    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
  }
  makeT(S_CUSTOM_PROTOCOL, ":", S_FULL_PROTOCOL);
  makeChainT(S_START, "localhost", makeNearDomainState(LOCALHOST), makeDomainState);
  makeRegexT(S_START, DIGIT, S_NUM);
  makeRegexT(S_START, LETTER, S_DOMAIN);
  makeRegexT(S_START, EMOJI, S_DOMAIN);
  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_NUM, DIGIT, S_NUM);
  makeRegexT(S_NUM, LETTER, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN);
  makeT(S_NUM, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN_HYPHEN, "-", S_DOMAIN_HYPHEN);
  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);
  S_START.jd = makeAcceptingState(SYM);
  return S_START;
}
function run$1(start8, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c) {
    return c.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start8;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      v: str.substr(cursor - tokenLength, tokenLength),
      s: cursor - tokenLength,
      e: cursor
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result2 = [];
  var len = str.length;
  var index6 = 0;
  while (index6 < len) {
    var first2 = str.charCodeAt(index6);
    var second = void 0;
    var char = first2 < 55296 || first2 > 56319 || index6 + 1 === len || (second = str.charCodeAt(index6 + 1)) < 56320 || second > 57343 ? str[index6] : str.slice(index6, index6 + 2);
    result2.push(char);
    index6 += char.length;
  }
  return result2;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
function noop(val) {
  return val;
}
function inherits(parent, child11) {
  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extended = Object.create(parent.prototype);
  for (var p in props) {
    extended[p] = props[p];
  }
  extended.constructor = child11;
  child11.prototype = extended;
  return child11;
}
function MultiToken() {
}
MultiToken.prototype = {
  t: "token",
  isLink: false,
  toString: function toString31() {
    return this.v;
  },
  toHref: function toHref() {
    return this.toString();
  },
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject: function toObject() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
};
function createTokenClass(type4, props) {
  function Token(value, tokens) {
    this.t = type4;
    this.v = value;
    this.tk = tokens;
  }
  inherits(MultiToken, Token, props);
  return Token;
}
var MailtoEmail = createTokenClass("email", {
  isLink: true
});
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  toHref: function toHref3() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    var tokens = this.tk;
    var hasProtocol2 = false;
    var hasSlashSlash = false;
    var result2 = [];
    var i = 0;
    while (tokens[i].t === PROTOCOL) {
      hasProtocol2 = true;
      result2.push(tokens[i].v);
      i++;
    }
    while (tokens[i].t === SLASH) {
      hasSlashSlash = true;
      result2.push(tokens[i].v);
      i++;
    }
    for (; i < tokens.length; i++) {
      result2.push(tokens[i].v);
    }
    result2 = result2.join("");
    if (!(hasProtocol2 || hasSlashSlash)) {
      result2 = "".concat(protocol, "://").concat(result2);
    }
    return result2;
  },
  hasProtocol: function hasProtocol() {
    return this.tk[0].t === PROTOCOL;
  }
});
var multi = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  MailtoEmail,
  Email,
  Text,
  Nl,
  Url
});
function init$1() {
  var S_START = makeState();
  var S_PROTOCOL = makeState();
  var S_MAILTO = makeState();
  var S_PROTOCOL_SLASH = makeState();
  var S_PROTOCOL_SLASH_SLASH = makeState();
  var S_DOMAIN = makeState();
  var S_DOMAIN_DOT = makeState();
  var S_TLD = makeAcceptingState(Url);
  var S_TLD_COLON = makeState();
  var S_TLD_PORT = makeAcceptingState(Url);
  var S_URL = makeAcceptingState(Url);
  var S_URL_NON_ACCEPTING = makeState();
  var S_URL_OPENBRACE = makeState();
  var S_URL_OPENBRACKET = makeState();
  var S_URL_OPENANGLEBRACKET = makeState();
  var S_URL_OPENPAREN = makeState();
  var S_URL_OPENBRACE_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENPAREN_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACE_SYMS = makeState();
  var S_URL_OPENBRACKET_SYMS = makeState();
  var S_URL_OPENANGLEBRACKET_SYMS = makeState();
  var S_URL_OPENPAREN_SYMS = makeState();
  var S_EMAIL_DOMAIN = makeState();
  var S_EMAIL_DOMAIN_DOT = makeState();
  var S_EMAIL = makeAcceptingState(Email);
  var S_EMAIL_COLON = makeState();
  var S_EMAIL_PORT = makeAcceptingState(Email);
  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail);
  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
  var S_LOCALPART = makeState();
  var S_LOCALPART_AT = makeState();
  var S_LOCALPART_DOT = makeState();
  var S_NL = makeAcceptingState(Nl);
  makeT(S_START, NL, S_NL);
  makeT(S_START, PROTOCOL, S_PROTOCOL);
  makeT(S_START, MAILTO, S_MAILTO);
  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH);
  makeT(S_START, TLD, S_DOMAIN);
  makeT(S_START, DOMAIN, S_DOMAIN);
  makeT(S_START, LOCALHOST, S_TLD);
  makeT(S_START, NUM, S_DOMAIN);
  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL);
  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_DOMAIN_DOT, TLD, S_TLD);
  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN);
  makeT(S_TLD, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_TLD, COLON, S_TLD_COLON);
  makeT(S_TLD, SLASH, S_URL);
  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
  makeT(S_TLD_PORT, SLASH, S_URL);
  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT);
  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL);
  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL, qsAccepting, S_URL);
  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
  makeT(S_TLD, AT, S_LOCALPART_AT);
  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART);
  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART, AT, S_LOCALPART_AT);
  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL);
  return S_START;
}
function run(start8, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state = start8;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = takeT(state, tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || takeT(state, tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      for (var i = cursor - multiLength; i < cursor; i++) {
        textTokens.push(tokens[i]);
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(parserCreateMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(parserCreateMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(parserCreateMultiToken(Text, input, textTokens));
  }
  return multis;
}
function parserCreateMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.substr(startIdx, endIdx - startIdx);
  return new Multi(value, tokens);
}
var INIT = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: false
};
function init13() {
  INIT.scanner = {
    start: init$2(INIT.customProtocols),
    tokens: text2
  };
  INIT.parser = {
    start: init$1(),
    tokens: multi
  };
  var utils = {
    createTokenClass
  };
  for (var i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser,
      utils
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init13();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find2(str) {
  var type4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  var filtered = [];
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.isLink && (!type4 || token.t === type4)) {
      filtered.push(token.toObject());
    }
  }
  return filtered;
}
function test(str) {
  var type4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type4 || tokens[0].t === type4);
}
function autolink(options) {
  return new Plugin$1({
    key: new PluginKey$1("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr } = newState;
      const transform = combineTransactionSteps(oldState.doc, transactions);
      const { mapping } = transform;
      const changes = getChangedRanges(transform);
      changes.forEach(({ oldRange, newRange }) => {
        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter((item) => item.mark.type === options.type).forEach((oldMark) => {
          const newFrom = mapping.map(oldMark.from);
          const newTo = mapping.map(oldMark.to);
          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter((item) => item.mark.type === options.type);
          if (!newMarks.length) {
            return;
          }
          const newMark = newMarks[0];
          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, void 0, " ");
          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, void 0, " ");
          const wasLink = test(oldLinkText);
          const isLink = test(newLinkText);
          if (wasLink && !isLink) {
            tr.removeMark(newMark.from, newMark.to, options.type);
          }
        });
        findChildrenInRange(newState.doc, newRange, (node8) => node8.isTextblock).forEach((textBlock) => {
          const text3 = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          find2(text3).filter((link2) => link2.isLink).map((link2) => ({
            ...link2,
            from: textBlock.pos + link2.start + 1,
            to: textBlock.pos + link2.end + 1
          })).filter((link2) => {
            const fromIsInRange = newRange.from >= link2.from && newRange.from <= link2.to;
            const toIsInRange = newRange.to >= link2.from && newRange.to <= link2.to;
            return fromIsInRange || toIsInRange;
          }).forEach((link2) => {
            tr.addMark(link2.from, link2.to, options.type.create({
              href: link2.href
            }));
          });
        });
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options) {
  return new Plugin$1({
    key: new PluginKey$1("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a2;
        const attrs = getAttributes(view.state, options.type.name);
        const link2 = (_a2 = event.target) === null || _a2 === void 0 ? void 0 : _a2.closest("a");
        if (link2 && attrs.href) {
          window.open(attrs.href, attrs.target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin$1({
    key: new PluginKey$1("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice11) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice11.content.forEach((node8) => {
          textContent += node8.textContent;
        });
        const link2 = find2(textContent).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link2) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link2.href
        });
        return true;
      }
    }
  });
}
const Link$1 = Mark$4.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow"
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      }
    };
  },
  parseHTML() {
    return [
      { tag: "a[href]" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "a",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text3) => find2(text3).filter((link2) => link2.isLink).map((link2) => ({
          text: link2.value,
          index: link2.start,
          data: link2
        })),
        type: this.type,
        getAttributes: (match) => {
          var _a2;
          return {
            href: (_a2 = match.data) === null || _a2 === void 0 ? void 0 : _a2.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});
const _sfc_main$8 = defineComponent({
  name: "AddLinkCommandButton",
  components: {
    ElDialog,
    ElForm,
    ElFormItem,
    ElInput,
    ElCheckbox,
    ElButton,
    CommandButton
  },
  props: {
    editor: {
      type: Editor$1,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", true);
    return { t, enableTooltip, isCodeViewMode };
  },
  data() {
    return {
      linkAttrs: {
        href: "",
        openInNewTab: true
      },
      addLinkDialogVisible: false
    };
  },
  watch: {
    addLinkDialogVisible() {
      this.linkAttrs = { href: "", openInNewTab: true };
    }
  },
  methods: {
    openAddLinkDialog() {
      this.addLinkDialogVisible = true;
    },
    closeAddLinkDialog() {
      this.addLinkDialogVisible = false;
    },
    addLink() {
      if (this.linkAttrs.openInNewTab) {
        this.editor.commands.setLink({
          href: this.linkAttrs.href,
          target: "_blank"
        });
      } else {
        this.editor.commands.setLink({ href: this.linkAttrs.href });
      }
      this.closeAddLinkDialog();
    }
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_form_item = resolveComponent("el-form-item");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_form = resolveComponent("el-form");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_command_button, {
      "is-active": _ctx.editor.isActive("link"),
      readonly: _ctx.isCodeViewMode,
      command: _ctx.openAddLinkDialog,
      "enable-tooltip": _ctx.enableTooltip,
      tooltip: _ctx.t("editor.extensions.Link.add.tooltip"),
      icon: "link"
    }, null, 8, ["is-active", "readonly", "command", "enable-tooltip", "tooltip"]),
    createVNode(_component_el_dialog, {
      modelValue: _ctx.addLinkDialogVisible,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.addLinkDialogVisible = $event),
      title: _ctx.t("editor.extensions.Link.add.control.title"),
      "append-to-body": true,
      width: "400px",
      "custom-class": "el-tiptap-edit-link-dialog"
    }, {
      footer: withCtx(() => [
        createVNode(_component_el_button, {
          size: "small",
          round: "",
          onClick: _ctx.closeAddLinkDialog
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.add.control.cancel")), 1)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_el_button, {
          type: "primary",
          size: "small",
          round: "",
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onClick: _ctx.addLink
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.add.control.confirm")), 1)
          ]),
          _: 1
        }, 8, ["onClick"])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_form, {
          model: _ctx.linkAttrs,
          "label-position": "right",
          size: "small"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_form_item, {
              label: _ctx.t("editor.extensions.Link.add.control.href"),
              prop: "href"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: _ctx.linkAttrs.href,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.linkAttrs.href = $event),
                  autocomplete: "off"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }, 8, ["label"]),
            createVNode(_component_el_form_item, { prop: "openInNewTab" }, {
              default: withCtx(() => [
                createVNode(_component_el_checkbox, {
                  modelValue: _ctx.linkAttrs.openInNewTab,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.linkAttrs.openInNewTab = $event)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.add.control.open_in_new_tab")), 1)
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model"])
      ]),
      _: 1
    }, 8, ["modelValue", "title"])
  ]);
}
var AddLinkCommandButton$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$8]]);
const Link = Link$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor }) {
        return {
          component: AddLinkCommandButton$1,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin$1({
        props: {
          handleClick(view, pos) {
            const { schema, doc: doc2, tr } = view.state;
            const range3 = getMarkRange(doc2.resolve(pos), schema.marks.link);
            if (!range3)
              return false;
            const $start = doc2.resolve(range3.from);
            const $end = doc2.resolve(range3.to);
            const transaction = tr.setSelection(new TextSelection$3($start, $end));
            view.dispatch(transaction);
            return true;
          }
        }
      })
    ];
  }
});
const TextStyle = Mark$4.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands.unsetMark(this.name);
      }
    };
  }
});
const Color$1 = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => element.style.color.replace(/['"]+/g, ""),
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const COLOR_SET = [
  "#f44336",
  "#e91e63",
  "#9c27b0",
  "#673ab7",
  "#3f51b5",
  "#2196f3",
  "#03a9f4",
  "#00bcd4",
  "#009688",
  "#4caf50",
  "#8bc34a",
  "#cddc39",
  "#ffeb3b",
  "#ffc107",
  "#ff9800",
  "#ff5722",
  "#000000"
];
const _sfc_main$7 = defineComponent({
  name: "ColorPopover",
  components: {
    ElButton,
    ElPopover,
    ElInput,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup(props) {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    const popoverRef = ref();
    const colorText = ref("");
    function confirmColor(color) {
      if (color) {
        props.editor.commands.setColor(color);
      } else {
        props.editor.commands.unsetColor();
      }
      unref(popoverRef).hide();
    }
    const selectedColor = computed(() => {
      return getMarkAttributes(props.editor.state, "textStyle").color || "";
    });
    watch(selectedColor, (color) => {
      colorText.value = color;
    });
    return {
      t,
      enableTooltip,
      isCodeViewMode,
      popoverRef,
      colorText,
      selectedColor,
      confirmColor
    };
  },
  computed: {
    colorSet() {
      const colorOptions = this.editor.extensionManager.extensions.find((e) => e.name === "color").options;
      return colorOptions.colors;
    }
  }
});
const _hoisted_1$K = { class: "color-set" };
const _hoisted_2$I = ["onClick"];
const _hoisted_3$G = { class: "color__wrapper" };
const _hoisted_4$1 = { class: "color-hex" };
const _hoisted_5 = /* @__PURE__ */ createTextVNode(" OK ");
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_command_button = resolveComponent("command-button");
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createBlock(_component_el_popover, {
    disabled: _ctx.isCodeViewMode,
    placement: "bottom",
    trigger: "click",
    "popper-class": "el-tiptap-popper",
    ref: "popoverRef"
  }, {
    reference: withCtx(() => [
      createElementVNode("span", null, [
        createVNode(_component_command_button, {
          "enable-tooltip": _ctx.enableTooltip,
          tooltip: _ctx.t("editor.extensions.TextColor.tooltip"),
          icon: "font-color",
          readonly: _ctx.isCodeViewMode
        }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$K, [
        (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.colorSet, (color) => {
          return openBlock(), createElementBlock("div", {
            key: color,
            class: "color__wrapper"
          }, [
            createElementVNode("div", {
              style: normalizeStyle({
                "background-color": color
              }),
              class: normalizeClass([{ "color--selected": _ctx.selectedColor === color }, "color"]),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"])),
              onClick: withModifiers(($event) => _ctx.confirmColor(color), ["stop"])
            }, null, 46, _hoisted_2$I)
          ]);
        }), 128)),
        createElementVNode("div", _hoisted_3$G, [
          createElementVNode("div", {
            class: "color color--remove",
            onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["prevent"])),
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.confirmColor(), ["stop"]))
          }, null, 32)
        ])
      ]),
      createElementVNode("div", _hoisted_4$1, [
        createVNode(_component_el_input, {
          modelValue: _ctx.colorText,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.colorText = $event),
          placeholder: "HEX",
          autofocus: "true",
          maxlength: "7",
          size: "small",
          class: "color-hex__input"
        }, null, 8, ["modelValue"]),
        createVNode(_component_el_button, {
          text: "",
          type: "primary",
          size: "small",
          class: "color-hex__button",
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.confirmColor(_ctx.colorText))
        }, {
          default: withCtx(() => [
            _hoisted_5
          ]),
          _: 1
        })
      ])
    ]),
    _: 1
  }, 8, ["disabled"]);
}
var ColorPopover = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$7]]);
const Color = Color$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      colors: COLOR_SET,
      button({ editor, t }) {
        return {
          component: ColorPopover,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addExtensions() {
    return [TextStyle];
  }
});
const inputRegex$1 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/;
const pasteRegex$1 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
const Highlight$1 = Mark$4.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands }) => {
        return commands.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands }) => {
        return commands.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
const _sfc_main$6 = defineComponent({
  name: "HighlightPopover",
  components: {
    ElButton,
    ElPopover,
    ElInput,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup(props) {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    const popoverRef = ref();
    const popoverVisible = ref(false);
    function confirmColor(color) {
      if (color) {
        props.editor.commands.setHighlight({ color });
      } else {
        props.editor.commands.unsetHighlight();
      }
      unref(popoverRef).hide();
    }
    const selectedColor = computed(() => {
      return getMarkAttributes(props.editor.state, "highlight").color || "";
    });
    return {
      t,
      enableTooltip,
      isCodeViewMode,
      popoverRef,
      selectedColor,
      popoverVisible,
      confirmColor
    };
  },
  computed: {
    colorSet() {
      const colorOptions = this.editor.extensionManager.extensions.find((e) => e.name === "highlight").options;
      return colorOptions.colors;
    }
  }
});
const _hoisted_1$J = { class: "color-set" };
const _hoisted_2$H = ["onClick"];
const _hoisted_3$F = { class: "color__wrapper" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createBlock(_component_el_popover, {
    disabled: _ctx.isCodeViewMode,
    placement: "bottom",
    trigger: "click",
    "popper-class": "el-tiptap-popper",
    ref: "popoverRef"
  }, {
    reference: withCtx(() => [
      createElementVNode("span", null, [
        createVNode(_component_command_button, {
          "enable-tooltip": _ctx.enableTooltip,
          tooltip: _ctx.t("editor.extensions.TextHighlight.tooltip"),
          icon: "highlight",
          readonly: _ctx.isCodeViewMode
        }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$J, [
        (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.colorSet, (color) => {
          return openBlock(), createElementBlock("div", {
            key: color,
            class: "color__wrapper"
          }, [
            createElementVNode("div", {
              style: normalizeStyle({
                "background-color": color
              }),
              class: normalizeClass([{ "color--selected": _ctx.selectedColor === color }, "color"]),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"])),
              onClick: withModifiers(($event) => _ctx.confirmColor(color), ["stop"])
            }, null, 46, _hoisted_2$H)
          ]);
        }), 128)),
        createElementVNode("div", _hoisted_3$F, [
          createElementVNode("div", {
            class: "color color--remove",
            onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["prevent"])),
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.confirmColor(), ["stop"]))
          }, null, 32)
        ])
      ])
    ]),
    _: 1
  }, 8, ["disabled"]);
}
var HighlightPopover = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render$6]]);
const Highlight = Highlight$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      multicolor: true,
      colors: COLOR_SET,
      button({ editor, t }) {
        return {
          component: HighlightPopover,
          componentProps: {
            editor
          }
        };
      }
    };
  }
});
const DEFAULT_FONT_FAMILY_NAMES = [
  "Arial",
  "Arial Black",
  "Georgia",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Verdana",
  "Courier New",
  "Lucida Console",
  "Monaco",
  "monospace"
];
const DEFAULT_FONT_FAMILY_MAP = DEFAULT_FONT_FAMILY_NAMES.reduce((obj, type4) => {
  obj[type4] = type4;
  return obj;
}, {});
const _sfc_main$5 = defineComponent({
  name: "FontFamilyDropdown",
  components: {
    ElDropdown,
    ElDropdownMenu,
    ElDropdownItem,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  computed: {
    fontFamilies() {
      const fontFamilyOptions = this.editor.extensionManager.extensions.find((e) => e.name === "fontFamily").options;
      return fontFamilyOptions.fontFamilyMap;
    },
    activeFontFamily() {
      return getMarkAttributes(this.editor.state, "textStyle").fontFamily || "";
    }
  },
  methods: {
    toggleFontType(name) {
      if (name === this.activeFontFamily) {
        this.editor.commands.unsetFontFamily();
      } else {
        this.editor.commands.setFontFamily(name);
      }
    }
  }
});
const _hoisted_1$I = ["data-font"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_dropdown_item = resolveComponent("el-dropdown-item");
  const _component_el_dropdown_menu = resolveComponent("el-dropdown-menu");
  const _component_el_dropdown = resolveComponent("el-dropdown");
  return openBlock(), createBlock(_component_el_dropdown, {
    placement: "bottom",
    trigger: "click",
    onCommand: _ctx.toggleFontType
  }, {
    dropdown: withCtx(() => [
      createVNode(_component_el_dropdown_menu, { class: "el-tiptap-dropdown-menu" }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.fontFamilies, (name) => {
            return openBlock(), createBlock(_component_el_dropdown_item, {
              key: name,
              command: name,
              class: normalizeClass([{
                "el-tiptap-dropdown-menu__item--active": name === _ctx.activeFontFamily
              }, "el-tiptap-dropdown-menu__item"])
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  "data-font": name,
                  style: normalizeStyle({ "font-family": name })
                }, toDisplayString(name), 13, _hoisted_1$I)
              ]),
              _: 2
            }, 1032, ["command", "class"]);
          }), 128))
        ]),
        _: 1
      })
    ]),
    default: withCtx(() => [
      createVNode(_component_command_button, {
        "enable-tooltip": _ctx.enableTooltip,
        tooltip: _ctx.t("editor.extensions.FontType.tooltip"),
        readonly: _ctx.isCodeViewMode,
        icon: "font-family"
      }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
    ]),
    _: 1
  }, 8, ["onCommand"]);
}
var FontFamilyDropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5]]);
const FontFamily = Extension.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"],
      fontFamilyMap: DEFAULT_FONT_FAMILY_MAP,
      button({ editor, t }) {
        return {
          component: FontFamilyDropdown,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (element) => element.style.fontFamily.replace(/['"]/g, ""),
            renderHTML: (attributes) => {
              if (!attributes.fontFamily) {
                return {};
              }
              return {
                style: `font-family: ${attributes.fontFamily}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (fontFamily2) => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: fontFamily2 }).run();
      },
      unsetFontFamily: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
      }
    };
  },
  addExtensions() {
    return [TextStyle];
  }
});
const DEFAULT_FONT_SIZES = [
  "8",
  "10",
  "12",
  "14",
  "16",
  "18",
  "20",
  "24",
  "30",
  "36",
  "48",
  "60",
  "72"
];
const DEFAULT_FONT_SIZE = "default";
const SIZE_PATTERN = /([\d.]+)px/i;
function convertToPX(styleValue) {
  const matches2 = styleValue.match(SIZE_PATTERN);
  if (!matches2)
    return "";
  const value = matches2[1];
  if (!value)
    return "";
  return value;
}
const _sfc_main$4 = defineComponent({
  name: "FontSizeDropdown",
  components: {
    ElDropdown,
    ElDropdownMenu,
    ElDropdownItem,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode, defaultSize: DEFAULT_FONT_SIZE };
  },
  computed: {
    fontSizes() {
      const fontSizeOptions = this.editor.extensionManager.extensions.find((e) => e.name === "fontSize").options;
      return fontSizeOptions.fontSizes;
    },
    activeFontSize() {
      return getMarkAttributes(this.editor.state, "textStyle").fontSize || "";
    }
  },
  methods: {
    toggleFontSize(size) {
      if (size === this.activeFontSize) {
        this.editor.commands.unsetFontSize();
      } else {
        this.editor.commands.setFontSize(size);
      }
    }
  }
});
const _hoisted_1$H = { "data-font-size": "default" };
const _hoisted_2$G = ["data-font-size"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_dropdown_item = resolveComponent("el-dropdown-item");
  const _component_el_dropdown_menu = resolveComponent("el-dropdown-menu");
  const _component_el_dropdown = resolveComponent("el-dropdown");
  return openBlock(), createBlock(_component_el_dropdown, {
    placement: "bottom",
    trigger: "click",
    onCommand: _ctx.toggleFontSize
  }, {
    dropdown: withCtx(() => [
      createVNode(_component_el_dropdown_menu, { class: "el-tiptap-dropdown-menu" }, {
        default: withCtx(() => [
          createVNode(_component_el_dropdown_item, {
            command: _ctx.defaultSize,
            class: normalizeClass([{
              "el-tiptap-dropdown-menu__item--active": _ctx.activeFontSize === _ctx.defaultSize
            }, "el-tiptap-dropdown-menu__item"])
          }, {
            default: withCtx(() => [
              createElementVNode("span", _hoisted_1$H, toDisplayString(_ctx.t("editor.extensions.FontSize.default")), 1)
            ]),
            _: 1
          }, 8, ["command", "class"]),
          (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.fontSizes, (fontSize2) => {
            return openBlock(), createBlock(_component_el_dropdown_item, {
              key: fontSize2,
              command: fontSize2,
              class: normalizeClass([{
                "el-tiptap-dropdown-menu__item--active": fontSize2 === _ctx.activeFontSize
              }, "el-tiptap-dropdown-menu__item"])
            }, {
              default: withCtx(() => [
                createElementVNode("span", { "data-font-size": fontSize2 }, toDisplayString(fontSize2), 9, _hoisted_2$G)
              ]),
              _: 2
            }, 1032, ["command", "class"]);
          }), 128))
        ]),
        _: 1
      })
    ]),
    default: withCtx(() => [
      createVNode(_component_command_button, {
        "enable-tooltip": _ctx.enableTooltip,
        tooltip: _ctx.t("editor.extensions.FontSize.tooltip"),
        readonly: _ctx.isCodeViewMode,
        icon: "font-size"
      }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
    ]),
    _: 1
  }, 8, ["onCommand"]);
}
var FontSizeDropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["render", _sfc_render$4]]);
const FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"],
      fontSizes: DEFAULT_FONT_SIZES,
      button({ editor, t }) {
        return {
          component: FontSizeDropdown,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (element) => convertToPX(element.style.fontSize) || "",
            renderHTML: (attributes) => {
              if (!attributes.fontSize) {
                return {};
              }
              return {
                style: `font-size: ${attributes.fontSize}px`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (fontSize2) => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: fontSize2 }).run();
      },
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: DEFAULT_FONT_SIZE }).removeEmptyTextStyle().run();
      }
    };
  },
  addExtensions() {
    return [TextStyle];
  }
});
const TiptapBtn = Mark$4.create({
  name: "btn",
  priority: 1e3,
  keepOnSplit: false,
  inclusive() {
    return false;
  },
  addOptions() {
    return {
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        style: ""
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      style: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "a",
      {
        class: "apex-blog-editor-btn",
        target: HTMLAttributes.target,
        href: HTMLAttributes.href
      },
      [
        "button",
        {
          onClick: "javascript:;",
          style: HTMLAttributes.style
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setBtn: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", false).run();
      }
    };
  },
  addProseMirrorPlugins() {
    const plugins = [];
    return plugins;
  }
});
const _sfc_main$3 = defineComponent({
  name: "AddLinkCommandButton",
  components: {
    ElDialog,
    ElForm,
    ElFormItem,
    ElInput,
    ElCheckbox,
    ElButton,
    CommandButton
  },
  props: {
    editor: {
      type: Editor$1,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", true);
    return { t, enableTooltip, isCodeViewMode };
  },
  data() {
    return {
      btnAttrs: {
        href: "",
        openInNewTab: true
      },
      addLinkDialogVisible: false
    };
  },
  watch: {
    addLinkDialogVisible() {
      this.btnAttrs = {
        href: "",
        openInNewTab: true
      };
    }
  },
  methods: {
    openAddLinkDialog() {
      this.addLinkDialogVisible = true;
    },
    closeAddLinkDialog() {
      this.addLinkDialogVisible = false;
    },
    addLink() {
      this.editor.commands.setBtn({
        href: this.btnAttrs.href,
        target: this.btnAttrs.openInNewTab ? "_blank" : "_self",
        style: ""
      });
      this.closeAddLinkDialog();
    }
  }
});
const _hoisted_1$G = /* @__PURE__ */ createTextVNode(/* @__PURE__ */ toDisplayString("\u662F\u5426\u65B0\u9875\u9762\u6253\u5F00"));
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_form_item = resolveComponent("el-form-item");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_form = resolveComponent("el-form");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_command_button, {
      "is-active": _ctx.editor.isActive("btn"),
      readonly: _ctx.isCodeViewMode,
      command: _ctx.openAddLinkDialog,
      "enable-tooltip": _ctx.enableTooltip,
      tooltip: "\u6DFB\u52A0 \u6309\u94AE",
      icon: "btn"
    }, null, 8, ["is-active", "readonly", "command", "enable-tooltip"]),
    createVNode(_component_el_dialog, {
      modelValue: _ctx.addLinkDialogVisible,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.addLinkDialogVisible = $event),
      title: "\u6DFB\u52A0\u6309\u94AE",
      "append-to-body": true,
      width: "400px",
      "custom-class": "el-tiptap-edit-link-dialog"
    }, {
      footer: withCtx(() => [
        createVNode(_component_el_button, {
          size: "small",
          round: "",
          onClick: _ctx.closeAddLinkDialog
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.add.control.cancel")), 1)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_el_button, {
          type: "primary",
          size: "small",
          round: "",
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onClick: _ctx.addLink
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.t("editor.extensions.Link.add.control.confirm")), 1)
          ]),
          _: 1
        }, 8, ["onClick"])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_form, {
          model: _ctx.btnAttrs,
          "label-position": "right",
          size: "small"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_form_item, {
              label: "\u8DF3\u8F6C\u94FE\u63A5",
              prop: "href"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: _ctx.btnAttrs.href,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.btnAttrs.href = $event),
                  autocomplete: "off"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            createVNode(_component_el_form_item, { prop: "openInNewTab" }, {
              default: withCtx(() => [
                createVNode(_component_el_checkbox, {
                  modelValue: _ctx.btnAttrs.openInNewTab,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.btnAttrs.openInNewTab = $event)
                }, {
                  default: withCtx(() => [
                    _hoisted_1$G
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model"])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var AddLinkCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$3]]);
const Button = TiptapBtn.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor }) {
        return {
          component: AddLinkCommandButton,
          componentProps: {
            editor
          }
        };
      }
    };
  }
});
const inputRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
const pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
const Code = Mark$4.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
const HardBreak = Node$4.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands, chain, state, editor }) => {
        return commands.first([
          () => commands.exitCode(),
          () => commands.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks6 = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
              if (dispatch2 && marks6 && keepMarks) {
                const filteredMarks = marks6.filter((mark7) => splittableMarks.includes(mark7.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
const HorizontalRule$1 = Node$4.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [
      { tag: "hr" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain }) => {
        return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
          var _a2;
          if (dispatch2) {
            const { $to } = tr.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              tr.setSelection(TextSelection$3.create(tr.doc, $to.pos));
            } else {
              const node8 = (_a2 = $to.parent.type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.create();
              if (node8) {
                tr.insert(posAfter, node8);
                tr.setSelection(TextSelection$3.create(tr.doc, posAfter));
              }
            }
            tr.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
const HorizontalRule = HorizontalRule$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.setHorizontalRule();
            },
            icon: "horizontal-rule",
            tooltip: t("editor.extensions.HorizontalRule.tooltip")
          }
        };
      }
    };
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append6(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice10(from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.length;
  if (from8 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from8), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get4(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach16(f, from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.length;
  if (from8 <= to) {
    this.forEachInner(f, from8, to, 0);
  } else {
    this.forEachInvertedInner(f, from8, to, 0);
  }
};
RopeSequence.prototype.map = function map29(f, from8, to) {
  if (from8 === void 0)
    from8 = 0;
  if (to === void 0)
    to = this.length;
  var result2 = [];
  this.forEach(function(elt, i) {
    return result2.push(f(elt, i));
  }, from8, to);
  return result2;
};
RopeSequence.from = function from7(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from8, to) {
    if (from8 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from8, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from8, to, start8) {
    for (var i = from8; i < to; i++) {
      if (f(this.values[i], start8 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from8, to, start8) {
    for (var i = from8 - 1; i >= to; i--) {
      if (f(this.values[i], start8 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from8, to, start8) {
    var leftLen = this.left.length;
    if (from8 < leftLen && this.left.forEachInner(f, from8, Math.min(to, leftLen), start8) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from8 - leftLen, 0), Math.min(this.length, to) - leftLen, start8 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from8, to, start8) {
    var leftLen = this.left.length;
    if (from8 > leftLen && this.right.forEachInvertedInner(f, from8 - leftLen, Math.max(to, leftLen) - leftLen, start8 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from8, leftLen), to, start8) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from8, to) {
    if (from8 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from8, to);
    }
    if (from8 >= leftLen) {
      return this.right.slice(from8 - leftLen, to - leftLen);
    }
    return this.left.slice(from8, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end7 = this.items.length;
  for (; ; end7--) {
    var next = this.items.get(end7 - 1);
    if (next.selection) {
      --end7;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end7, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item, i) {
    if (!item.step) {
      if (!remap) {
        remap = this$1$1.remapping(end7, i + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item.map));
      var step5 = item.step.map(remap.slice(mapFrom)), map30;
      if (step5 && transform.maybeStep(step5).doc) {
        map30 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map30, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map30) {
        remap.appendMap(map30, mapFrom);
      }
    } else {
      transform.maybeStep(item.step);
    }
    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1$1.items.slice(0, end7).append(addBefore.reverse().concat(addAfter)), this$1$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i = 0; i < transform.steps.length; i++) {
    var step5 = transform.steps[i].invert(transform.docs[i]);
    var item = new Item(transform.mapping.maps[i], step5, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from8, to) {
  var maps = new Mapping$4();
  this.items.forEach(function(item, i) {
    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from8 ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from8, to);
  return maps;
};
Branch.prototype.addMaps = function addMaps(array4) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array4.map(function(map30) {
    return new Item(map30);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start8 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item) {
    if (item.selection) {
      eventCount--;
    }
  }, start8);
  var iRebased = rebasedCount;
  this.items.forEach(function(item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map30 = mapping.maps[pos];
    if (item.step) {
      var step5 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map30, step5, selection));
    } else {
      rebasedItems.push(new Item(map30));
    }
  }, start8);
  var newMaps = [];
  for (var i = rebasedCount; i < newUntil; i++) {
    newMaps.push(new Item(mapping.maps[i]));
  }
  var items = this.items.slice(0, start8).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item) {
    if (!item.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0)
    upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function(item, i) {
    if (i >= upto) {
      items.push(item);
      if (item.selection) {
        events++;
      }
    } else if (item.step) {
      var step5 = item.step.map(remap.slice(mapFrom)), map30 = step5 && step5.getMap();
      mapFrom--;
      if (map30) {
        remap.appendMap(map30, mapFrom);
      }
      if (step5) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) {
          events++;
        }
        var newItem = new Item(map30.invert(), step5, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem)) {
          items[last] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(ropeSequence.from(items.reverse()), events);
};
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function(item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map30, step5, selection, mirrorOffset) {
  this.map = map30;
  this.step = step5;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge5(other) {
  if (this.step && other.step && !other.selection) {
    var step5 = other.step.merge(this.step);
    if (step5) {
      return new Item(step5.getMap().invert(), step5, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done2, undone, prevRanges, prevTime) {
  this.done = done2;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction4(history2, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased2;
  if (historyTr) {
    return historyTr.historyState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) {
      return new HistoryState(history2.done.addTransform(tr, null, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    } else {
      return new HistoryState(history2.done, history2.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history2.prevTime);
    }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased2), history2.undone.rebased(tr, rebased2), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) {
    return false;
  }
  if (!transform.docChanged) {
    return true;
  }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start8, end7) {
    for (var i = 0; i < prevRanges.length; i += 2) {
      if (start8 <= prevRanges[i + 1] && end7 >= prevRanges[i]) {
        adjacent = true;
      }
    }
  });
  return adjacent;
}
function rangesFor(map30) {
  var result2 = [];
  map30.forEach(function(_from, _to, from8, to) {
    return result2.push(from8, to);
  });
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges) {
    return null;
  }
  var result2 = [];
  for (var i = 0; i < ranges.length; i += 2) {
    var from8 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from8 <= to) {
      result2.push(from8, to);
    }
  }
  return result2;
}
function histTransaction(history2, state, dispatch2, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop) {
    return;
  }
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey$1("history");
var closeHistoryKey = new PluginKey$1("closeHistory");
function history(config) {
  config = {
    depth: config && config.depth || 100,
    newGroupDelay: config && config.newGroupDelay || 500
  };
  return new Plugin$1({
    key: historyKey,
    state: {
      init: function init14() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply22(tr, hist, state) {
        return applyTransaction4(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var handled = e.inputType == "historyUndo" ? undo$2(view.state, view.dispatch) : e.inputType == "historyRedo" ? redo$2(view.state, view.dispatch) : false;
          if (handled) {
            e.preventDefault();
          }
          return handled;
        }
      }
    }
  });
}
function undo$2(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, false);
  }
  return true;
}
function redo$2(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, true);
  }
  return true;
}
const History$1 = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo$2(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo$2(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});
const History = History$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return [
          {
            component: CommandButton,
            componentProps: {
              command: () => {
                editor.commands.undo();
              },
              icon: "undo",
              tooltip: t("editor.extensions.History.tooltip.undo")
            }
          },
          {
            component: CommandButton,
            componentProps: {
              command: () => {
                editor.commands.redo();
              },
              icon: "redo",
              tooltip: t("editor.extensions.History.tooltip.redo")
            }
          }
        ];
      }
    };
  }
});
const TextAlign$1 = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type4) => commands.updateAttributes(type4, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands }) => {
        return this.options.types.every((type4) => commands.resetAttributes(type4, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const TextAlign = TextAlign$1.extend({
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      types: ["heading", "paragraph", "list_item", "title"],
      button({
        editor,
        extension,
        t
      }) {
        return extension.options.alignments.reduce((acc, alignment) => {
          return acc.concat({
            component: CommandButton,
            componentProps: {
              command: () => {
                if (editor.isActive({ textAlign: alignment })) {
                  editor.commands.unsetTextAlign();
                } else {
                  editor.commands.setTextAlign(alignment);
                }
              },
              isActive: alignment === "left" ? false : editor.isActive({ textAlign: alignment }),
              icon: `align-${alignment}`,
              tooltip: t(`editor.extensions.TextAlign.buttons.align_${alignment}.tooltip`)
            }
          });
        }, []);
      }
    };
  }
});
var IndentProps = /* @__PURE__ */ ((IndentProps2) => {
  IndentProps2[IndentProps2["max"] = 7] = "max";
  IndentProps2[IndentProps2["min"] = 0] = "min";
  IndentProps2[IndentProps2["more"] = 1] = "more";
  IndentProps2[IndentProps2["less"] = -1] = "less";
  return IndentProps2;
})(IndentProps || {});
function updateIndentLevel(tr, delta, types2, editor) {
  const { doc: doc2, selection } = tr;
  if (!doc2 || !selection)
    return tr;
  if (!(selection instanceof TextSelection$3 || selection instanceof AllSelection$3)) {
    return tr;
  }
  const { from: from8, to } = selection;
  doc2.nodesBetween(from8, to, (node8, pos) => {
    const nodeType2 = node8.type;
    if (types2.includes(nodeType2.name)) {
      tr = setNodeIndentMarkup(tr, pos, delta);
      return false;
    } else if (isList(node8.type.name, editor.extensionManager.extensions)) {
      return false;
    }
    return true;
  });
  return tr;
}
function setNodeIndentMarkup(tr, pos, delta) {
  if (!tr.doc)
    return tr;
  const node8 = tr.doc.nodeAt(pos);
  if (!node8)
    return tr;
  const minIndent = 0;
  const maxIndent = 7;
  const indent2 = clamp((node8.attrs.indent || 0) + delta, minIndent, maxIndent);
  if (indent2 === node8.attrs.indent)
    return tr;
  const nodeAttrs = {
    ...node8.attrs,
    indent: indent2
  };
  return tr.setNodeMarkup(pos, node8.type, nodeAttrs, node8.marks);
}
function createIndentCommand({
  delta,
  types: types2
}) {
  return ({ state, dispatch: dispatch2, editor }) => {
    const { selection } = state;
    let { tr } = state;
    tr = tr.setSelection(selection);
    tr = updateIndentLevel(tr, delta, types2, editor);
    if (tr.docChanged) {
      dispatch2 && dispatch2(tr);
      return true;
    }
    return false;
  };
}
const Indent = Extension.create({
  name: "indent",
  addOptions() {
    return {
      types: ["paragraph", "heading", "blockquote"],
      minIndent: IndentProps.min,
      maxIndent: IndentProps.max,
      button({ editor, t }) {
        return [
          {
            component: CommandButton,
            componentProps: {
              command: () => {
                editor.commands.indent();
              },
              icon: "indent",
              tooltip: t("editor.extensions.Indent.buttons.indent.tooltip")
            }
          },
          {
            component: CommandButton,
            componentProps: {
              command: () => {
                editor.commands.outdent();
              },
              icon: "outdent",
              tooltip: t("editor.extensions.Indent.buttons.outdent.tooltip")
            }
          }
        ];
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          indent: {
            default: 0,
            parseHTML: (element) => {
              const identAttr = element.getAttribute("data-indent");
              return (identAttr ? parseInt(identAttr, 10) : 0) || 0;
            },
            renderHTML: (attributes) => {
              if (!attributes.indent) {
                return {};
              }
              return { ["data-indent"]: attributes.indent };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => createIndentCommand({
        delta: IndentProps.more,
        types: this.options.types
      }),
      outdent: () => createIndentCommand({
        delta: IndentProps.less,
        types: this.options.types
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.indent(),
      "Shift-Tab": () => this.editor.commands.outdent()
    };
  }
});
const ALLOWED_NODE_TYPES = [
  "paragraph",
  "heading",
  "list_item",
  "todo_item"
];
const NUMBER_VALUE_PATTERN = /^\d+(.\d+)?$/;
function isLineHeightActive(state, lineHeight) {
  const { selection, doc: doc2 } = state;
  const { from: from8, to } = selection;
  let keepLooking = true;
  let active = false;
  doc2.nodesBetween(from8, to, (node8) => {
    const nodeType2 = node8.type;
    const lineHeightValue = node8.attrs.lineHeight || DEFAULT_LINE_HEIGHT;
    if (ALLOWED_NODE_TYPES.includes(nodeType2.name)) {
      if (keepLooking && lineHeight === lineHeightValue) {
        keepLooking = false;
        active = true;
        return false;
      }
      return nodeType2.name !== "list_item" && nodeType2.name !== "todo_item";
    }
    return keepLooking;
  });
  return active;
}
function transformLineHeightToCSS(value) {
  if (!value)
    return "";
  let strValue = String(value);
  if (NUMBER_VALUE_PATTERN.test(strValue)) {
    const numValue = parseFloat(strValue);
    strValue = String(Math.round(numValue * 100)) + "%";
  }
  return parseFloat(strValue) * LINE_HEIGHT_100 + "%";
}
function transformCSStoLineHeight(value) {
  if (!value)
    return "";
  if (value === DEFAULT_LINE_HEIGHT)
    return "";
  let strValue = value;
  if (NUMBER_VALUE_PATTERN.test(value)) {
    const numValue = parseFloat(value);
    strValue = String(Math.round(numValue * 100)) + "%";
    if (strValue === DEFAULT_LINE_HEIGHT)
      return "";
  }
  return parseFloat(strValue) / LINE_HEIGHT_100 + "%";
}
function setTextLineHeight(tr, lineHeight) {
  const { selection, doc: doc2 } = tr;
  if (!selection || !doc2)
    return tr;
  if (!(selection instanceof TextSelection$3 || selection instanceof AllSelection$3)) {
    return tr;
  }
  const { from: from8, to } = selection;
  const tasks2 = [];
  const lineHeightValue = lineHeight && lineHeight !== DEFAULT_LINE_HEIGHT ? lineHeight : null;
  doc2.nodesBetween(from8, to, (node8, pos) => {
    const nodeType2 = node8.type;
    if (ALLOWED_NODE_TYPES.includes(nodeType2.name)) {
      const lineHeight2 = node8.attrs.lineHeight || null;
      if (lineHeight2 !== lineHeightValue) {
        tasks2.push({
          node: node8,
          pos,
          nodeType: nodeType2
        });
      }
      return nodeType2.name !== "list_item" && nodeType2.name !== "todo_item";
    }
    return true;
  });
  if (!tasks2.length)
    return tr;
  tasks2.forEach((task) => {
    const { node: node8, pos, nodeType: nodeType2 } = task;
    let { attrs } = node8;
    attrs = {
      ...attrs,
      lineHeight: lineHeightValue
    };
    tr = tr.setNodeMarkup(pos, nodeType2, attrs, node8.marks);
  });
  return tr;
}
function createLineHeightCommand(lineHeight) {
  return ({ state, dispatch: dispatch2 }) => {
    const { selection } = state;
    let { tr } = state;
    tr = tr.setSelection(selection);
    tr = setTextLineHeight(tr, lineHeight);
    if (tr.docChanged) {
      dispatch2 && dispatch2(tr);
      return true;
    }
    return false;
  };
}
const _sfc_main$2 = defineComponent({
  name: "LineHeightDropdown",
  components: {
    ElDropdown,
    ElDropdownMenu,
    ElDropdownItem,
    CommandButton
  },
  props: {
    editor: {
      type: Editor,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    return { t, enableTooltip, isCodeViewMode };
  },
  computed: {
    lineHeights() {
      const lineHeightOptions = this.editor.extensionManager.extensions.find((e) => e.name === "lineHeight").options;
      return lineHeightOptions.lineHeights;
    }
  },
  methods: {
    isLineHeightActive(lineHeight) {
      return isLineHeightActive(this.editor.state, lineHeight);
    }
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  const _component_el_dropdown_item = resolveComponent("el-dropdown-item");
  const _component_el_dropdown_menu = resolveComponent("el-dropdown-menu");
  const _component_el_dropdown = resolveComponent("el-dropdown");
  return openBlock(), createBlock(_component_el_dropdown, {
    placement: "bottom",
    trigger: "click",
    onCommand: _cache[0] || (_cache[0] = (lineHeight) => _ctx.editor.commands.setLineHeight(lineHeight))
  }, {
    dropdown: withCtx(() => [
      createVNode(_component_el_dropdown_menu, {
        slot: "dropdown",
        class: "el-tiptap-dropdown-menu"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment$6, null, renderList(_ctx.lineHeights, (lineHeight) => {
            return openBlock(), createBlock(_component_el_dropdown_item, {
              key: lineHeight,
              command: lineHeight,
              class: normalizeClass([{
                "el-tiptap-dropdown-menu__item--active": _ctx.isLineHeightActive(lineHeight)
              }, "el-tiptap-dropdown-menu__item"])
            }, {
              default: withCtx(() => [
                createElementVNode("span", null, toDisplayString(lineHeight), 1)
              ]),
              _: 2
            }, 1032, ["command", "class"]);
          }), 128))
        ]),
        _: 1
      })
    ]),
    default: withCtx(() => [
      createVNode(_component_command_button, {
        "enable-tooltip": _ctx.enableTooltip,
        tooltip: _ctx.t("editor.extensions.LineHeight.tooltip"),
        readonly: _ctx.isCodeViewMode,
        icon: "text-height"
      }, null, 8, ["enable-tooltip", "tooltip", "readonly"])
    ]),
    _: 1
  });
}
var LineHeightDropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$2]]);
const LineHeight = Extension.create({
  name: "lineHeight",
  addOptions() {
    return {
      types: ["paragraph", "heading", "list_item", "todo_item"],
      lineHeights: ["100%", "115%", "150%", "200%", "250%", "300%"],
      button({ editor }) {
        return {
          component: LineHeightDropdown,
          componentProps: {
            editor
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (element) => {
              return transformCSStoLineHeight(element.style.lineHeight) || null;
            },
            renderHTML: (attributes) => {
              if (!attributes.lineHeight) {
                return {};
              }
              const cssLineHeight = transformLineHeightToCSS(attributes.lineHeight);
              return {
                style: `line-height: ${cssLineHeight};`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (lineHeight) => createLineHeightCommand(lineHeight),
      unsetLineHeight: () => ({ commands }) => {
        return this.options.types.every((type4) => commands.resetAttributes(type4, "lineHeight"));
      }
    };
  }
});
const FormatClear = Extension.create({
  name: "formatClear",
  addCommands() {
    const commandsMap = {
      bold: "unsetBold",
      italic: "unsetItalic",
      underline: "unsetUnderline",
      strike: "unsetStrike",
      link: "unsetLink",
      fontFamily: "unsetFontFamily",
      fontSize: "unsetFontSize",
      color: "unsetColor",
      highlight: "unsetHighlight",
      textAlign: "unsetTextAlign",
      lineHeight: "unsetLineHeight"
    };
    return {
      formatClear: () => ({ editor }) => {
        const chainedCommand = Object.entries(commandsMap).reduce((chain, [name, command2]) => {
          const extension = editor.extensionManager.extensions.find((e) => e.name === name);
          if (extension) {
            return chain[command2]();
          }
          return chain;
        }, editor.chain());
        return chainedCommand.focus().run();
      }
    };
  },
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.formatClear();
            },
            icon: "clear-format",
            tooltip: t("editor.extensions.FormatClear.tooltip")
          }
        };
      }
    };
  }
});
const _sfc_main$1 = defineComponent({
  name: "FullscreenCommandButton",
  components: {
    CommandButton
  },
  props: {
    editor: {
      type: Editor$1,
      required: true
    }
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isFullscreen = inject("isFullscreen", false);
    const toggleFullscreen = inject("toggleFullscreen");
    return { t, enableTooltip, isFullscreen, toggleFullscreen };
  },
  computed: {
    buttonTooltip() {
      return this.isFullscreen ? this.t("editor.extensions.Fullscreen.tooltip.exit_fullscreen") : this.t("editor.extensions.Fullscreen.tooltip.fullscreen");
    }
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_command_button, {
      command: () => _ctx.toggleFullscreen(!_ctx.isFullscreen),
      "enable-tooltip": _ctx.enableTooltip,
      tooltip: _ctx.buttonTooltip,
      icon: _ctx.isFullscreen ? "compress" : "expand",
      "is-active": _ctx.isFullscreen
    }, null, 8, ["command", "enable-tooltip", "tooltip", "icon", "is-active"])
  ]);
}
var FullscreenCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render$1]]);
const Fullscreen = Extension.create({
  name: "fullscreen",
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor }) {
        return {
          component: FullscreenCommandButton
        };
      }
    };
  }
});
function printHtml(dom) {
  const style2 = Array.from(document.querySelectorAll("style, link")).reduce((str, style22) => str + style22.outerHTML, "");
  const content4 = style2 + dom.outerHTML;
  const iframe = document.createElement("iframe");
  iframe.id = "el-tiptap-iframe";
  iframe.setAttribute("style", "position: absolute; width: 0; height: 0; top: -10px; left: -10px;");
  document.body.appendChild(iframe);
  const frameWindow = iframe.contentWindow;
  const doc2 = iframe.contentDocument || iframe.contentWindow && iframe.contentWindow.document;
  if (doc2) {
    doc2.open();
    doc2.write(content4);
    doc2.close();
  }
  if (frameWindow) {
    iframe.onload = function() {
      try {
        setTimeout(() => {
          frameWindow.focus();
          try {
            if (!frameWindow.document.execCommand("print", false)) {
              frameWindow.print();
            }
          } catch (e) {
            frameWindow.print();
          }
          frameWindow.close();
        }, 10);
      } catch (err6) {
        Logger.error(err6);
      }
      setTimeout(function() {
        document.body.removeChild(iframe);
      }, 100);
    };
  }
}
function printEditorContent(view) {
  const editorContent = view.dom.closest(".el-tiptap-editor__content");
  if (editorContent) {
    printHtml(editorContent);
    return true;
  }
  return false;
}
const Print = Extension.create({
  name: "print",
  addOptions() {
    return {
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.print();
            },
            icon: "print",
            tooltip: t("editor.extensions.Print.tooltip")
          }
        };
      }
    };
  },
  addCommands() {
    return {
      print: () => ({ view }) => {
        return printEditorContent(view);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-p": () => this.editor.commands.print()
    };
  }
});
const SelectAll = Extension.create({
  name: "selectAll",
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor, t }) {
        return {
          component: CommandButton,
          componentProps: {
            command: () => {
              editor.commands.selectAll();
            },
            icon: "select-all",
            tooltip: t("editor.extensions.SelectAll.tooltip")
          }
        };
      }
    };
  }
});
const inlineElements = /^(a|abbr|acronym|area|base|bdo|big|br|button|caption|cite|code|col|colgroup|dd|del|dfn|em|frame|hr|iframe|img|input|ins|kbd|label|legend|link|map|object|optgroup|option|param|q|samp|script|select|small|span|strong|sub|sup|textarea|tt|var)$/;
function extendCodemirror(CodeMirror) {
  CodeMirror.extendMode("xml", {
    newlineAfterToken: function(type4, content4, textAfter, state) {
      let inline2 = false;
      if (this.configuration === "html") {
        inline2 = state.context ? inlineElements.test(state.context.tagName) : false;
      }
      return !inline2 && (type4 === "tag" && />$/.test(content4) && state.context || /^</.test(textAfter));
    }
  });
  CodeMirror.defineExtension("autoFormatRange", function(from8, to) {
    const cm = this;
    const outer = cm.getMode();
    const text3 = cm.getRange(from8, to).split("\n");
    const state = CodeMirror.copyState(outer, cm.getTokenAt(from8).state);
    const tabSize = cm.getOption("tabSize");
    let out = "";
    let lines = 0;
    let atSol = from8.ch === 0;
    function newline() {
      out += "\n";
      atSol = true;
      ++lines;
    }
    for (let i = 0; i < text3.length; ++i) {
      const stream = new CodeMirror.StringStream(text3[i], tabSize);
      while (!stream.eol()) {
        const inner = CodeMirror.innerMode(outer, state);
        const style2 = outer.token(stream, state);
        const cur = stream.current();
        stream.start = stream.pos;
        if (!atSol || /\S/.test(cur)) {
          out += cur;
          atSol = false;
        }
        if (!atSol && inner.mode.newlineAfterToken && inner.mode.newlineAfterToken(style2, cur, stream.string.slice(stream.pos) || text3[i + 1] || "", inner.state)) {
          newline();
        }
      }
      if (!stream.pos && outer.blankLine)
        outer.blankLine(state);
      if (!atSol && i < text3.length - 1)
        newline();
    }
    cm.operation(function() {
      cm.replaceRange(out, from8, to);
      for (let cur = from8.line + 1, end7 = from8.line + lines; cur <= end7; ++cur) {
        cm.indentLine(cur, "smart");
      }
      cm.setSelection(from8, cm.getCursor(false));
    });
  });
}
const _sfc_main = defineComponent({
  name: "CodeViewCommandButton",
  components: {
    CommandButton
  },
  setup() {
    const t = inject("t");
    const enableTooltip = inject("enableTooltip", true);
    const isCodeViewMode = inject("isCodeViewMode", false);
    const toggleIsCodeViewMode = inject("toggleIsCodeViewMode");
    return { t, enableTooltip, isCodeViewMode, toggleIsCodeViewMode };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_command_button = resolveComponent("command-button");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_command_button, {
      command: () => _ctx.toggleIsCodeViewMode(!_ctx.isCodeViewMode),
      "enable-tooltip": _ctx.enableTooltip,
      tooltip: _ctx.t("editor.extensions.CodeView.tooltip"),
      icon: "file-code",
      "is-active": _ctx.isCodeViewMode
    }, null, 8, ["command", "enable-tooltip", "tooltip", "is-active"])
  ]);
}
var CodeViewCommandButton = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render]]);
const DEFAULT_CODEMIRROR_OPTIONS = {
  lineNumbers: true,
  lineWrapping: true,
  tabSize: 2,
  tabMode: "indent",
  mode: "text/html"
};
const CodeView = Extension.create({
  name: "codeView",
  defaultOptions: {
    codemirror: null,
    codemirrorOptions: {
      ...DEFAULT_CODEMIRROR_OPTIONS
    }
  },
  onBeforeCreate() {
    if (!this.options.codemirror) {
      Logger.warn('"CodeView" extension requires the CodeMirror library.');
      return;
    }
    extendCodemirror(this.options.codemirror);
    this.options.codemirrorOptions = {
      ...DEFAULT_CODEMIRROR_OPTIONS,
      ...this.options.codemirrorOptions
    };
  },
  addOptions() {
    var _a2;
    return {
      ...(_a2 = this.parent) == null ? void 0 : _a2.call(this),
      button({ editor }) {
        return {
          component: CodeViewCommandButton
        };
      }
    };
  }
});
const ElementTiptapPlugin = {
  install(app) {
    app.component("element-tiptap", ElementTiptap);
    app.component("el-tiptap", ElementTiptap);
  }
};
const _hoisted_1$F = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$F = /* @__PURE__ */ createElementVNode("path", {
  d: "M432 160H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0 256H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM108.1 96h231.81A12.09 12.09 0 0 0 352 83.9V44.09A12.09 12.09 0 0 0 339.91 32H108.1A12.09 12.09 0 0 0 96 44.09V83.9A12.1 12.1 0 0 0 108.1 96zm231.81 256A12.09 12.09 0 0 0 352 339.9v-39.81A12.09 12.09 0 0 0 339.91 288H108.1A12.09 12.09 0 0 0 96 300.09v39.81a12.1 12.1 0 0 0 12.1 12.1z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$E = [
  _hoisted_2$F
];
function render$F(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$F, _hoisted_3$E);
}
var alignCenter = { render: render$F };
var alignCenter$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$F,
  "default": alignCenter
});
const _hoisted_1$E = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$E = /* @__PURE__ */ createElementVNode("path", {
  d: "M432 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-128H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-128H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-128H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$D = [
  _hoisted_2$E
];
function render$E(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$E, _hoisted_3$D);
}
var alignJustify = { render: render$E };
var alignJustify$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$E,
  "default": alignJustify
});
const _hoisted_1$D = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$D = /* @__PURE__ */ createElementVNode("path", {
  d: "M12.83 352h262.34A12.82 12.82 0 0 0 288 339.17v-38.34A12.82 12.82 0 0 0 275.17 288H12.83A12.82 12.82 0 0 0 0 300.83v38.34A12.82 12.82 0 0 0 12.83 352zm0-256h262.34A12.82 12.82 0 0 0 288 83.17V44.83A12.82 12.82 0 0 0 275.17 32H12.83A12.82 12.82 0 0 0 0 44.83v38.34A12.82 12.82 0 0 0 12.83 96zM432 160H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0 256H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$C = [
  _hoisted_2$D
];
function render$D(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$D, _hoisted_3$C);
}
var alignLeft = { render: render$D };
var alignLeft$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$D,
  "default": alignLeft
});
const _hoisted_1$C = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$C = /* @__PURE__ */ createElementVNode("path", {
  d: "M16 224h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm416 192H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm3.17-384H172.83A12.82 12.82 0 0 0 160 44.83v38.34A12.82 12.82 0 0 0 172.83 96h262.34A12.82 12.82 0 0 0 448 83.17V44.83A12.82 12.82 0 0 0 435.17 32zm0 256H172.83A12.82 12.82 0 0 0 160 300.83v38.34A12.82 12.82 0 0 0 172.83 352h262.34A12.82 12.82 0 0 0 448 339.17v-38.34A12.82 12.82 0 0 0 435.17 288z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$B = [
  _hoisted_2$C
];
function render$C(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$C, _hoisted_3$B);
}
var alignRight = { render: render$C };
var alignRight$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$C,
  "default": alignRight
});
const _hoisted_1$B = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m257.5 445.1-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"
}, null, -1);
const _hoisted_3$A = [
  _hoisted_2$B
];
function render$B(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$B, _hoisted_3$A);
}
var arrowLeft = { render: render$B };
var arrowLeft$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$B,
  "default": arrowLeft
});
const _hoisted_1$A = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "24",
  height: "32",
  viewBox: "0 0 384 512"
};
const _hoisted_2$A = /* @__PURE__ */ createElementVNode("path", {
  d: "M333.49 238a122 122 0 0 0 27-65.21C367.87 96.49 308 32 233.42 32H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h31.87v288H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h209.32c70.8 0 134.14-51.75 141-122.4 4.74-48.45-16.39-92.06-50.83-119.6zM145.66 112h87.76a48 48 0 0 1 0 96h-87.76zm87.76 288h-87.76V288h87.76a56 56 0 0 1 0 112z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$z = [
  _hoisted_2$A
];
function render$A(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$A, _hoisted_3$z);
}
var bold = { render: render$A };
var bold$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$A,
  "default": bold
});
const _hoisted_1$z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"
}, null, -1);
const _hoisted_3$y = [
  _hoisted_2$z
];
function render$z(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$z, _hoisted_3$y);
}
var btn = { render: render$z };
var btn$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$z,
  "default": btn
});
const _hoisted_1$y = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--icon-park-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 48 48"
};
const _hoisted_2$y = /* @__PURE__ */ createStaticVNode('<mask id="b"><g fill="none"><g stroke="#fff" clip-path="url(#a)"><path fill="#fff" stroke-linejoin="round" stroke-width="4.302" d="M44.782 24.17 31.918 7.1 14.135 20.5 27.5 37l3.356-2.336L44.782 24.17Z"></path><path stroke-linejoin="round" stroke-width="4.302" d="m27.5 37-3.839 3.075-10.563-.001-2.6-3.45-6.433-8.536L14.5 20.225"></path><path stroke-linecap="round" stroke-width="4.5" d="M13.206 40.072h31.36"></path></g><defs><clipPath id="a"><path fill="#000" d="M0 0h48v48H0z"></path></clipPath></defs></g></mask><path fill="currentColor" d="M0 0h48v48H0z" mask="url(#b)"></path>', 2);
const _hoisted_4 = [
  _hoisted_2$y
];
function render$y(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$y, _hoisted_4);
}
var clearFormat = { render: render$y };
var clearFormat$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$y,
  "default": clearFormat
});
const _hoisted_1$x = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "40",
  height: "32",
  viewBox: "0 0 640 512"
};
const _hoisted_2$x = /* @__PURE__ */ createElementVNode("path", {
  d: "m278.9 511.5-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2 43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6 144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$x = [
  _hoisted_2$x
];
function render$x(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$x, _hoisted_3$x);
}
var code = { render: render$x };
var code$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$x,
  "default": code
});
const _hoisted_1$w = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa6-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 320H32c-17.69 0-32 14.31-32 32s14.31 32 32 32h64v64c0 17.69 14.31 32 32 32s32-14.31 32-32v-96c0-17.7-14.3-32-32-32zm288 0h-96c-17.69 0-32 14.31-32 32v96c0 17.69 14.31 32 32 32s32-14.31 32-32v-64h64c17.69 0 32-14.31 32-32s-14.3-32-32-32zm-96-128h96c17.69 0 32-14.31 32-32s-14.31-32-32-32h-64V64c0-17.69-14.31-32-32-32s-32 14.31-32 32v96c0 17.7 14.3 32 32 32zM128 32c-17.7 0-32 14.31-32 32v64H32c-17.69 0-32 14.3-32 32s14.31 32 32 32h96c17.69 0 32-14.31 32-32V64c0-17.69-14.3-32-32-32z"
}, null, -1);
const _hoisted_3$w = [
  _hoisted_2$w
];
function render$w(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$w, _hoisted_3$w);
}
var compress2 = { render: render$w };
var compress$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$w,
  "default": compress2
});
const _hoisted_1$v = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "36",
  height: "32",
  viewBox: "0 0 576 512"
};
const _hoisted_2$v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m402.6 83.2 90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"
}, null, -1);
const _hoisted_3$v = [
  _hoisted_2$v
];
function render$v(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$v, _hoisted_3$v);
}
var edit = { render: render$v };
var edit$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$v,
  "default": edit
});
const _hoisted_1$u = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M328 256c0 39.8-32.2 72-72 72s-72-32.2-72-72 32.2-72 72-72 72 32.2 72 72zm104-72c-39.8 0-72 32.2-72 72s32.2 72 72 72 72-32.2 72-72-32.2-72-72-72zm-352 0c-39.8 0-72 32.2-72 72s32.2 72 72 72 72-32.2 72-72-32.2-72-72-72z"
}, null, -1);
const _hoisted_3$u = [
  _hoisted_2$u
];
function render$u(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$u, _hoisted_3$u);
}
var ellipsisH = { render: render$u };
var ellipsisH$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$u,
  "default": ellipsisH
});
const _hoisted_1$t = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa6-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 32H32C14.31 32 0 46.31 0 64v96c0 17.69 14.31 32 32 32s32-14.31 32-32V96h64c17.69 0 32-14.31 32-32s-14.3-32-32-32zm288 0h-96c-17.69 0-32 14.31-32 32s14.31 32 32 32h64v64c0 17.69 14.31 32 32 32s32-14.31 32-32V64c0-17.69-14.3-32-32-32zM128 416H64v-64c0-17.69-14.31-32-32-32S0 334.31 0 352v96c0 17.69 14.31 32 32 32h96c17.69 0 32-14.31 32-32s-14.3-32-32-32zm288-96c-17.69 0-32 14.31-32 32v64h-64c-17.69 0-32 14.31-32 32s14.31 32 32 32h96c17.69 0 32-14.31 32-32v-96c0-17.7-14.3-32-32-32z"
}, null, -1);
const _hoisted_3$t = [
  _hoisted_2$t
];
function render$t(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$t, _hoisted_3$t);
}
var expand = { render: render$t };
var expand$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$t,
  "default": expand
});
const _hoisted_1$s = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M432 320h-32a16 16 0 0 0-16 16v112H64V128h144a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16H48a48 48 0 0 0-48 48v352a48 48 0 0 0 48 48h352a48 48 0 0 0 48-48V336a16 16 0 0 0-16-16ZM488 0H360c-21.37 0-32.05 25.91-17 41l35.73 35.73L135 320.37a24 24 0 0 0 0 34L157.67 377a24 24 0 0 0 34 0l243.61-243.68L471 169c15 15 41 4.5 41-17V24a24 24 0 0 0-24-24Z"
}, null, -1);
const _hoisted_3$s = [
  _hoisted_2$s
];
function render$s(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$s, _hoisted_3$s);
}
var externalLink = { render: render$s };
var externalLink$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$s,
  "default": externalLink
});
const _hoisted_1$r = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-regular",
  width: "24",
  height: "32",
  viewBox: "0 0 384 512"
};
const _hoisted_2$r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m149.9 349.1-.2-.2-32.8-28.9 32.8-28.9c3.6-3.2 4-8.8.8-12.4l-.2-.2-17.4-18.6c-3.4-3.6-9-3.7-12.4-.4l-57.7 54.1c-3.7 3.5-3.7 9.4 0 12.8l57.7 54.1c1.6 1.5 3.8 2.4 6 2.4 2.4 0 4.8-1 6.4-2.8l17.4-18.6c3.3-3.5 3.1-9.1-.4-12.4zm220-251.2L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM256 51.9l76.1 76.1H256zM336 464H48V48h160v104c0 13.3 10.7 24 24 24h104zM209.6 214c-4.7-1.4-9.5 1.3-10.9 6L144 408.1c-1.4 4.7 1.3 9.6 6 10.9l24.4 7.1c4.7 1.4 9.6-1.4 10.9-6L240 231.9c1.4-4.7-1.3-9.6-6-10.9zm24.5 76.9.2.2 32.8 28.9-32.8 28.9c-3.6 3.2-4 8.8-.8 12.4l.2.2 17.4 18.6c3.3 3.5 8.9 3.7 12.4.4l57.7-54.1c3.7-3.5 3.7-9.4 0-12.8l-57.7-54.1c-3.5-3.3-9.1-3.2-12.4.4l-17.4 18.6c-3.3 3.5-3.1 9.1.4 12.4z"
}, null, -1);
const _hoisted_3$r = [
  _hoisted_2$r
];
function render$r(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$r, _hoisted_3$r);
}
var fileCode = { render: render$r };
var fileCode$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$r,
  "default": fileCode
});
const _hoisted_1$q = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--material-symbols",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M4 21q-.825 0-1.412-.587Q2 19.825 2 19q0-.825.588-1.413Q3.175 17 4 17h16q.825 0 1.413.587Q22 18.175 22 19q0 .825-.587 1.413Q20.825 21 20 21Zm3.15-7q-.675 0-1-.45-.325-.45-.075-1.1l4.25-11.3q.2-.475.687-.813Q11.5 0 12.025 0q.5 0 .975.337.475.338.675.813l4.25 11.3q.25.65-.075 1.1-.325.45-1.025.45-.3 0-.587-.2-.288-.2-.388-.475l-1-2.925H9.2l-1.05 2.925q-.1.275-.387.475-.288.2-.613.2ZM9.9 8.4h4.2l-2.05-5.8h-.1Z"
}, null, -1);
const _hoisted_3$q = [
  _hoisted_2$q
];
function render$q(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$q, _hoisted_3$q);
}
var fontColor = { render: render$q };
var fontColor$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$q,
  "default": fontColor
});
const _hoisted_1$p = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--bx",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M15 4h7v2h-7zm1 4h6v2h-6zm2 4h4v2h-4zM9.307 4l-6 16h2.137l1.875-5h6.363l1.875 5h2.137l-6-16H9.307zm-1.239 9L10.5 6.515 12.932 13H8.068z"
}, null, -1);
const _hoisted_3$p = [
  _hoisted_2$p
];
function render$p(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$p);
}
var fontFamily = { render: render$p };
var fontFamily$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$p,
  "default": fontFamily
});
const _hoisted_1$o = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--bx",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$o = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m22 6-3-4-3 4h2v4h-2l3 4 3-4h-2V6zM9.307 4l-6 16h2.137l1.875-5h6.363l1.875 5h2.137l-6-16H9.307zm-1.239 9L10.5 6.515 12.932 13H8.068z"
}, null, -1);
const _hoisted_3$o = [
  _hoisted_2$o
];
function render$o(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$o);
}
var fontSize = { render: render$o };
var fontSize$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$o,
  "default": fontSize
});
const _hoisted_1$n = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$n = /* @__PURE__ */ createElementVNode("path", {
  d: "M448 96v320h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H320a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V288H160v128h32a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H32a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h32V96H32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16h-32v128h192V96h-32a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h160a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$n = [
  _hoisted_2$n
];
function render$n(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_3$n);
}
var heading = { render: render$n };
var heading$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$n,
  "default": heading
});
const _hoisted_1$m = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--ic",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M8.94 16.56c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12L8.32.7a.996.996 0 1 0-1.41 1.41l1.68 1.68-5.15 5.15a1.49 1.49 0 0 0 0 2.12l5.5 5.5zM10 5.21 14.79 10H5.21L10 5.21zM19 17c1.1 0 2-.9 2-2 0-1.33-2-3.5-2-3.5s-2 2.17-2 3.5c0 1.1.9 2 2 2zm1 3H4c-1.1 0-2 .9-2 2s.9 2 2 2h16c1.1 0 2-.9 2-2s-.9-2-2-2z"
}, null, -1);
const _hoisted_3$m = [
  _hoisted_2$m
];
function render$m(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$m);
}
var highlight = { render: render$m };
var highlight$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$m,
  "default": highlight
});
const _hoisted_1$l = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$l = /* @__PURE__ */ createElementVNode("path", {
  d: "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$l = [
  _hoisted_2$l
];
function render$l(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_3$l);
}
var horizontalRule = { render: render$l };
var horizontalRule$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$l,
  "default": horizontalRule
});
const _hoisted_1$k = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-regular",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 336H54a6 6 0 0 1-6-6V118a6 6 0 0 1 6-6h404a6 6 0 0 1 6 6v276a6 6 0 0 1-6 6zM128 152c-22.091 0-40 17.909-40 40s17.909 40 40 40 40-17.909 40-40-17.909-40-40-40zM96 352h320v-80l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L192 304l-39.515-39.515c-4.686-4.686-12.284-4.686-16.971 0L96 304v48z"
}, null, -1);
const _hoisted_3$k = [
  _hoisted_2$k
];
function render$k(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$k);
}
var imageAlign = { render: render$k };
var imageAlign$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$k,
  "default": imageAlign
});
const _hoisted_1$j = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$j = /* @__PURE__ */ createElementVNode("path", {
  d: "M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$j = [
  _hoisted_2$j
];
function render$j(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$j, _hoisted_3$j);
}
var image = { render: render$j };
var image$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$j,
  "default": image
});
const _hoisted_1$i = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$i = /* @__PURE__ */ createElementVNode("path", {
  d: "m27.31 363.3 96-96a16 16 0 0 0 0-22.62l-96-96C17.27 138.66 0 145.78 0 160v192c0 14.31 17.33 21.3 27.31 11.3zM432 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm3.17-128H204.83A12.82 12.82 0 0 0 192 300.83v38.34A12.82 12.82 0 0 0 204.83 352h230.34A12.82 12.82 0 0 0 448 339.17v-38.34A12.82 12.82 0 0 0 435.17 288zm0-128H204.83A12.82 12.82 0 0 0 192 172.83v38.34A12.82 12.82 0 0 0 204.83 224h230.34A12.82 12.82 0 0 0 448 211.17v-38.34A12.82 12.82 0 0 0 435.17 160zM432 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$i = [
  _hoisted_2$i
];
function render$i(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_3$i);
}
var indent = { render: render$i };
var indent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$i,
  "default": indent
});
const _hoisted_1$h = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "20",
  height: "32",
  viewBox: "0 0 320 512"
};
const _hoisted_2$h = /* @__PURE__ */ createElementVNode("path", {
  d: "M320 48v32a16 16 0 0 1-16 16h-62.76l-80 320H208a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H16a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h62.76l80-320H112a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h192a16 16 0 0 1 16 16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$h = [
  _hoisted_2$h
];
function render$h(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_3$h);
}
var italic = { render: render$h };
var italic$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$h,
  "default": italic
});
const _hoisted_1$g = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$g = /* @__PURE__ */ createElementVNode("path", {
  d: "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$g = [
  _hoisted_2$g
];
function render$g(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_3$g);
}
var link = { render: render$g };
var link$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$g,
  "default": link
});
const _hoisted_1$f = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$f = /* @__PURE__ */ createElementVNode("path", {
  d: "m61.77 401 17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.83a157.41 157.41 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.29 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.72 6.13-3.19 11.72 2.63 15.94 7.71 4.69 20.38 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM496 224H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm-3.91 160H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.32c3.29-10.29 48.34-18.68 48.34-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.46 18.75-4.37 5.59-3 10.84 2.8 15.37l8.58 6.88c5.61 4.56 11 2.47 16.12-2.44a13.44 13.44 0 0 1 9.46-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.09 320z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$f = [
  _hoisted_2$f
];
function render$f(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_3$f);
}
var listOl = { render: render$f };
var listOl$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$f,
  "default": listOl
});
const _hoisted_1$e = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$e = /* @__PURE__ */ createElementVNode("path", {
  d: "M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$e = [
  _hoisted_2$e
];
function render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$e);
}
var listUl = { render: render$e };
var listUl$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$e,
  "default": listUl
});
const _hoisted_1$d = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$d = /* @__PURE__ */ createElementVNode("path", {
  d: "M100.69 363.29c10 10 27.31 2.93 27.31-11.31V160c0-14.32-17.33-21.31-27.31-11.31l-96 96a16 16 0 0 0 0 22.62zM432 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm3.17-128H204.83A12.82 12.82 0 0 0 192 300.83v38.34A12.82 12.82 0 0 0 204.83 352h230.34A12.82 12.82 0 0 0 448 339.17v-38.34A12.82 12.82 0 0 0 435.17 288zm0-128H204.83A12.82 12.82 0 0 0 192 172.83v38.34A12.82 12.82 0 0 0 204.83 224h230.34A12.82 12.82 0 0 0 448 211.17v-38.34A12.82 12.82 0 0 0 435.17 160zM432 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$d = [
  _hoisted_2$d
];
function render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$d);
}
var outdent = { render: render$d };
var outdent$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$d,
  "default": outdent
});
const _hoisted_1$c = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--material-symbols",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M18 7H6V4q0-.425.287-.713Q6.575 3 7 3h10q.425 0 .712.287Q18 3.575 18 4Zm0 5.5q.425 0 .712-.288.288-.287.288-.712t-.288-.713Q18.425 10.5 18 10.5t-.712.287Q17 11.075 17 11.5t.288.712q.287.288.712.288ZM8 19h8v-4H8v4Zm0 2q-.825 0-1.412-.587Q6 19.825 6 19v-2H3q-.425 0-.712-.288Q2 16.425 2 16v-5q0-1.275.875-2.137Q3.75 8 5 8h14q1.275 0 2.138.863Q22 9.725 22 11v5q0 .425-.288.712Q21.425 17 21 17h-3v2q0 .825-.587 1.413Q16.825 21 16 21Z"
}, null, -1);
const _hoisted_3$c = [
  _hoisted_2$c
];
function render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$c);
}
var print = { render: render$c };
var print$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$c,
  "default": print
});
const _hoisted_1$b = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$b = /* @__PURE__ */ createElementVNode("path", {
  d: "M464 32H336c-26.5 0-48 21.5-48 48v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48zm-288 0H48C21.5 32 0 53.5 0 80v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$b = [
  _hoisted_2$b
];
function render$b(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$b);
}
var quoteRight = { render: render$b };
var quoteRight$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$b,
  "default": quoteRight
});
const _hoisted_1$a = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$a = /* @__PURE__ */ createElementVNode("path", {
  d: "M500.33 0h-47.41a12 12 0 0 0-12 12.57l4 82.76A247.42 247.42 0 0 0 256 8C119.34 8 7.9 119.53 8 256.19 8.1 393.07 119.1 504 256 504a247.1 247.1 0 0 0 166.18-63.91 12 12 0 0 0 .48-17.43l-34-34a12 12 0 0 0-16.38-.55A176 176 0 1 1 402.1 157.8l-101.53-4.87a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12h200.33a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$a = [
  _hoisted_2$a
];
function render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$a);
}
var redo = { render: render$a };
var redo$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$a,
  "default": redo
});
const _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--jam",
  width: "35.56",
  height: "32",
  viewBox: "0 0 20 18"
};
const _hoisted_2$9 = /* @__PURE__ */ createElementVNode("path", {
  d: "M3.01 14a1 1 0 0 1 .988 1h12.004a1 1 0 0 1 1-1V4a1 1 0 0 1-1-1H4.01a1 1 0 0 1-1 1v10zm.988 3a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h.01V4a1 1 0 0 1-.998-1V1a1 1 0 0 1 .999-1H3.01a1 1 0 0 1 1 1h11.992a1 1 0 0 1 1-1H19a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1v10a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-1.998a1 1 0 0 1-1-1H3.998z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$9 = [
  _hoisted_2$9
];
function render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$9);
}
var selectAll = { render: render$9 };
var selectAll$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$9,
  "default": selectAll
});
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$8 = /* @__PURE__ */ createElementVNode("path", {
  d: "M496 224H293.9l-87.17-26.83A43.55 43.55 0 0 1 219.55 112h66.79A49.89 49.89 0 0 1 331 139.58a16 16 0 0 0 21.46 7.15l42.94-21.47a16 16 0 0 0 7.16-21.46l-.53-1A128 128 0 0 0 287.51 32h-68a123.68 123.68 0 0 0-123 135.64c2 20.89 10.1 39.83 21.78 56.36H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h480a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm-180.24 96A43 43 0 0 1 336 356.45 43.59 43.59 0 0 1 292.45 400h-66.79A49.89 49.89 0 0 1 181 372.42a16 16 0 0 0-21.46-7.15l-42.94 21.47a16 16 0 0 0-7.16 21.46l.53 1A128 128 0 0 0 224.49 480h68a123.68 123.68 0 0 0 123-135.64 114.25 114.25 0 0 0-5.34-24.36z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$8 = [
  _hoisted_2$8
];
function render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$8);
}
var strikethrough = { render: render$8 };
var strikethrough$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$8,
  "default": strikethrough
});
const _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$7 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z"
}, null, -1);
const _hoisted_3$7 = [
  _hoisted_2$7
];
function render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_3$7);
}
var table = { render: render$7 };
var table$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$7,
  "default": table
});
const _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$6 = /* @__PURE__ */ createElementVNode("path", {
  d: "M139.61 35.5a12 12 0 0 0-17 0L58.93 98.81l-22.7-22.12a12 12 0 0 0-17 0L3.53 92.41a12 12 0 0 0 0 17l47.59 47.4a12.78 12.78 0 0 0 17.61 0l15.59-15.62L156.52 69a12.09 12.09 0 0 0 .09-17zm0 159.19a12 12 0 0 0-17 0l-63.68 63.72-22.7-22.1a12 12 0 0 0-17 0L3.53 252a12 12 0 0 0 0 17L51 316.5a12.77 12.77 0 0 0 17.6 0l15.7-15.69 72.2-72.22a12 12 0 0 0 .09-16.9zM64 368c-26.49 0-48.59 21.5-48.59 48S37.53 464 64 464a48 48 0 0 0 0-96zm432 16H208a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h288a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H208a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h288a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H208a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h288a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$6
];
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$6);
}
var tasks = { render: render$6 };
var tasks$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$6,
  "default": tasks
});
const _hoisted_1$5 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "36",
  height: "32",
  viewBox: "0 0 576 512"
};
const _hoisted_2$5 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M304 32H16A16 16 0 0 0 0 48v96a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16v-32h56v304H80a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-40V112h56v32a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm256 336h-48V144h48c14.31 0 21.33-17.31 11.31-27.31l-80-80a16 16 0 0 0-22.62 0l-80 80C379.36 126 384.36 144 400 144h48v224h-48c-14.31 0-21.32 17.31-11.31 27.31l80 80a16 16 0 0 0 22.62 0l80-80C580.64 386 575.64 368 560 368z"
}, null, -1);
const _hoisted_3$5 = [
  _hoisted_2$5
];
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$5);
}
var textHeight = { render: render$5 };
var textHeight$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$5,
  "default": textHeight
});
const _hoisted_1$4 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--uil",
  width: "32",
  height: "32",
  viewBox: "0 0 24 24"
};
const _hoisted_2$4 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M10 18a1 1 0 0 0 1-1v-6a1 1 0 0 0-2 0v6a1 1 0 0 0 1 1ZM20 6h-4V5a3 3 0 0 0-3-3h-2a3 3 0 0 0-3 3v1H4a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2ZM10 5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v1h-4Zm7 14a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V8h10Zm-3-1a1 1 0 0 0 1-1v-6a1 1 0 0 0-2 0v6a1 1 0 0 0 1 1Z"
}, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$4
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$4);
}
var trashAlt = { render: render$4 };
var trashAlt$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$4,
  "default": trashAlt
});
const _hoisted_1$3 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "28",
  height: "32",
  viewBox: "0 0 448 512"
};
const _hoisted_2$3 = /* @__PURE__ */ createElementVNode("path", {
  d: "M32 64h32v160c0 88.22 71.78 160 160 160s160-71.78 160-160V64h32a16 16 0 0 0 16-16V16a16 16 0 0 0-16-16H272a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h32v160a80 80 0 0 1-160 0V64h32a16 16 0 0 0 16-16V16a16 16 0 0 0-16-16H32a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm400 384H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$3
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$3);
}
var underline = { render: render$3 };
var underline$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$3,
  "default": underline
});
const _hoisted_1$2 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$2 = /* @__PURE__ */ createElementVNode("path", {
  d: "M212.333 224.333H12c-6.627 0-12-5.373-12-12V12C0 5.373 5.373 0 12 0h48c6.627 0 12 5.373 12 12v78.112C117.773 39.279 184.26 7.47 258.175 8.007c136.906.994 246.448 111.623 246.157 248.532C504.041 393.258 393.12 504 256.333 504c-64.089 0-122.496-24.313-166.51-64.215-5.099-4.622-5.334-12.554-.467-17.42l33.967-33.967c4.474-4.474 11.662-4.717 16.401-.525C170.76 415.336 211.58 432 256.333 432c97.268 0 176-78.716 176-176 0-97.267-78.716-176-176-176-58.496 0-110.28 28.476-142.274 72.333h98.274c6.627 0 12 5.373 12 12v48c0 6.627-5.373 12-12 12z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$2 = [
  _hoisted_2$2
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_3$2);
}
var undo = { render: render$2 };
var undo$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$2,
  "default": undo
});
const _hoisted_1$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "32",
  height: "32",
  viewBox: "0 0 512 512"
};
const _hoisted_2$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M304.083 405.907c4.686 4.686 4.686 12.284 0 16.971l-44.674 44.674c-59.263 59.262-155.693 59.266-214.961 0-59.264-59.265-59.264-155.696 0-214.96l44.675-44.675c4.686-4.686 12.284-4.686 16.971 0l39.598 39.598c4.686 4.686 4.686 12.284 0 16.971l-44.675 44.674c-28.072 28.073-28.072 73.75 0 101.823 28.072 28.072 73.75 28.073 101.824 0l44.674-44.674c4.686-4.686 12.284-4.686 16.971 0l39.597 39.598zm-56.568-260.216c4.686 4.686 12.284 4.686 16.971 0l44.674-44.674c28.072-28.075 73.75-28.073 101.824 0 28.072 28.073 28.072 73.75 0 101.823l-44.675 44.674c-4.686 4.686-4.686 12.284 0 16.971l39.598 39.598c4.686 4.686 12.284 4.686 16.971 0l44.675-44.675c59.265-59.265 59.265-155.695 0-214.96-59.266-59.264-155.695-59.264-214.961 0l-44.674 44.674c-4.686 4.686-4.686 12.284 0 16.971l39.597 39.598zm234.828 359.28 22.627-22.627c9.373-9.373 9.373-24.569 0-33.941L63.598 7.029c-9.373-9.373-24.569-9.373-33.941 0L7.029 29.657c-9.373 9.373-9.373 24.569 0 33.941l441.373 441.373c9.373 9.372 24.569 9.372 33.941 0z"
}, null, -1);
const _hoisted_3$1 = [
  _hoisted_2$1
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_3$1);
}
var unlink = { render: render$1 };
var unlink$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: render$1,
  "default": unlink
});
const _hoisted_1 = {
  xmlns: "http://www.w3.org/2000/svg",
  "aria-hidden": "true",
  class: "iconify iconify--fa-solid",
  width: "36",
  height: "32",
  viewBox: "0 0 576 512"
};
const _hoisted_2 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M336.2 64H47.8C21.4 64 0 85.4 0 111.8v288.4C0 426.6 21.4 448 47.8 448h288.4c26.4 0 47.8-21.4 47.8-47.8V111.8c0-26.4-21.4-47.8-47.8-47.8zm189.4 37.7L416 177.3v157.4l109.6 75.5c21.2 14.6 50.4-.3 50.4-25.8V127.5c0-25.4-29.1-40.4-50.4-25.8z"
}, null, -1);
const _hoisted_3 = [
  _hoisted_2
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1, _hoisted_3);
}
var video = { render };
var video$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render,
  "default": video
});
export { Blockquote, Bold, BulletList, Button, Code, CodeBlock, CodeView, Color, Document, ElementTiptap, ElementTiptapPlugin, FontFamily, FontSize, FormatClear, Fullscreen, HardBreak, Heading, Highlight, History, HorizontalRule, Iframe, Image, Indent, Italic, LineHeight, Link, OrderedList, Paragraph, Print, SelectAll, Strike, Table, TaskList, Text$1 as Text, TextAlign, Underline, ElementTiptapPlugin as default };
